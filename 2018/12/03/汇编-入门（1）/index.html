<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">

  
  <script src="/js/script.js"></script>
  

  <title>caozhenwei</title>
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/css/bootstrap.css" >
</head>
  <body>
    <header class="header-content">
<div class="header">
  <div class="blog-title">
    <img class="logo" src="https://raw.githubusercontent.com/caozhenwei/blog_pic/master/header_image_small.jpeg">
    <a href="/" class="title">caozhenwei</a>
  </div>
  <nav class="navbar">
    <ul class="menu">
      
        <li class="menu-item">
          <a href="/" class="menu-item-link">Home</a>
        </li>
      
        <li class="menu-item">
          <a href="/archives" class="menu-item-link">Archives</a>
        </li>
      
    </ul>
  </nav>
</div>
</header>
    <main class="main">
      <div class="content">
  <article class="article">
    <div class="article-detail">
      <!-- 标题 -->
      <div class="article-title">
        <h2 class="title">汇编--入门（1）</h2>
      </div>

      <!-- 时间 -->
      <div class="article-meta">
        <span class="article-time">2018-12-03</span>
      </div>

      <!-- 文章内容 -->
      <div class="article-content">
        <h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>汇编语言是能直接操作 CPU 寄存器的语言，学好汇编语言能使我们更好的理解计算机的工作过程。上学那会儿学过<code>计算机原理与接口技术</code>这门课程，汇编多少接触过点儿，不过已经忘完了。现在好多开源代码的底层都是用汇编写的，没有点汇编基础还真的看不懂。那么问题来了，为什么底层的代码要用汇编编写呢？有人回答是汇编的效率更高。汇编和和高级语言最终都要被编译成机器语言，为什么说汇编的效率就更高呢？^_^</p>
<a id="more"></a>
<h4 id="机器语言"><a href="#机器语言" class="headerlink" title="机器语言"></a>机器语言</h4><p>机器语言是机器指令的集合。例如机器指令 1000 1001 1101 1000 表示把寄存器 BX 的内存送到 AX 中，汇编指令则写成 mov ax，bx。机器语言难于辨别和记忆，于是汇编语言诞生了。汇编语言的出现极大的解放了生产力，相比直接编写机器语言效率上大概提升 3 到 5 倍。</p>
<h4 id="汇编指令组成"><a href="#汇编指令组成" class="headerlink" title="汇编指令组成"></a>汇编指令组成</h4><p>汇编语言由 3 种指令组成：</p>
<ul>
<li>汇编指令：机器码的助记符号，有对应的机器码</li>
<li>伪指令：没有对应的机器码，由编译器执行，计算机并不执行</li>
<li>其它符号：如 + - * / 等，由编译器识别，没有对应的机器码</li>
</ul>
<h4 id="内存地址空间"><a href="#内存地址空间" class="headerlink" title="内存地址空间"></a>内存地址空间</h4><p>CPU 通过总线和内存、硬盘等设备连接，总线从逻辑上分为三类：地址总线、控制总线、数据总线。一个 CPU 有 N 根地址总线，则说这个 CPU 的地址总线宽度为 N，这 N 根线用 0 、1 表示的信息量为 2 的 N 次方，称其寻址能力为 2 的 N 次方。计算机的最小单位信息是 bit ，也就是一个二进制位，8 个 bit 组成一个 Byte，也就是一个字。换算关系如下所示：</p>
<pre><code>1TB = 1024GB ，1GB = 1024MB，1MB = 1024KB，1KB = 1024B，1B = 8bit
</code></pre><p>微机存储器的容量是以字节为最小单位来计算的，8086 有 20 位地址总线，即 1MB 的寻址能力。</p>
<p>把主存储器地址空间、显卡地址空间、网卡地址空间、系统 BIOS 地址空间的总和看作一个由若干个存储单元组成的逻辑存储器，这个逻辑存储器就是内存地址空间。</p>
<p>8086 是 16 位的 CPU ，则在内部能够一次性处理、传输、暂时存放的数据为 16 位。8086 有 20 位地址总线，即 1MB 的寻址能力。8086 CPU 的寄存器是 16 位的，那怎么用 16 位的寄存器来表示 20 位的地址总线呢？其实 8086 CPU 在内部用两个 16 位地址（段地址和偏移地址）合成一个 20 位的物理地址，即 <code>物理地址 = 段地址 * 16 + 偏移地址。段地址 * 16</code>又被叫做基础地址。</p>
<p>8086 有 4 个段寄存器：CS、DS、SS、ES。</p>
<p>CS 为代码段寄存器，IP 为指令指针寄存器。任意时刻，设 CS 中的内容为 M ，IP 中的内容为 N ，则 8086 将从内存 M * 16 + N 单元开始，读取一条指令并执行。</p>
<h4 id="8086-工作过程"><a href="#8086-工作过程" class="headerlink" title="8086 工作过程"></a>8086 工作过程</h4><p>8086 工作过程简要描述：</p>
<ul>
<li>1.从 CS：IP 指向的内存单元读取指令到指令缓存器</li>
<li>2.IP = IP + 所读指令的长度，从而指向下一条指令</li>
<li>3.执行指令并从第 1 步开始重复</li>
</ul>
<p>知道了 8086 CPU 执行指令的过程，那么我们就可以修改 CS 或 IP 或同时修改 CS 和 IP 来控制 CPU 。</p>
<ul>
<li>修改 CS、IP 的的指令，“jmp 段地址：偏移地址”    jmp 2:3，</li>
<li><p>仅修改 IP 的内容，“jmp 某一合法寄存器”   jmp ax，</p>
<p>  执行前 ax = 1000H，CS = 2000H，IP = 0003H</p>
<p>  执行后 ax = 1000H，CS = 2000H，IP = 1000H</p>
</li>
</ul>
<h4 id="8086-其它寄存器"><a href="#8086-其它寄存器" class="headerlink" title="8086 其它寄存器"></a>8086 其它寄存器</h4><p><img src="https://raw.githubusercontent.com/caozhenwei/blog_pic/master/asm/66E6F523-C27E-413B-844C-E6046F8DE297.png" alt="MacDown logo"></p>
<p>从上图可以看出 8086 CPU 内部有 14 个寄存器，一下子也不用记住这么多，随着学习的深入，慢慢的就都认识了。</p>
<p>8086 的所有寄存器都是 16 位的，其中有 4 个通用寄存器，分别为 AX，BX，CX，DX。8086 上一代的 CPU 是 8 位的，为了保持兼容，这 4 个通用寄存器又可以分为两个独立的 8 位寄存器来使用：</p>
<ul>
<li>AX 分为 AH 和 AL</li>
<li>BX 分为 BH 和 BL</li>
<li>CX 分为 CH 和 CL</li>
<li>DX 分为 DH 和 DL</li>
</ul>
<p>其它的寄存器以后再慢慢介绍。</p>
<h4 id="几个简单的汇编指令"><a href="#几个简单的汇编指令" class="headerlink" title="几个简单的汇编指令"></a>几个简单的汇编指令</h4><table>
<thead>
<tr>
<th>汇编指令</th>
<th>控制 CPU 完成的操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>mov ax,1</td>
<td>将 1 送入寄存器 ax</td>
<td></td>
</tr>
<tr>
<td>mov al,1</td>
<td>将 1 送入寄存器 ax 的低 8 位</td>
<td></td>
</tr>
<tr>
<td>add ax 8</td>
<td>将寄存器 ax 中的数值加 8</td>
<td></td>
</tr>
<tr>
<td>mov ax,bx</td>
<td>将 bx 中的数据送入 ax</td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>通过本文章我们知道了 8086 CPU 的工作过程，即从 CS：IP 处取指令放到缓冲器，新 IP 值为原 IP + 指令长度，执行指令并从头开始；知道了修改 CS 或 IP 或 CS 和 IP 的 jum 方法；知道了 4 个通用寄存器，AX、BX、CX、DX 并且知道它们可以单独作为两个 8 位寄存器使用；了解了基本汇编指令 mov、add 的用法。下篇介绍下怎么在 mac 环境下搭建汇编编程环境。不积跬步无以至千里，继续加油。</p>

      </div>
    </div>
  </article>

  <!-- 目录 -->
  <aside id="toc-sidebar">
    <div id="toc" class="toc-article">
    <strong class="toc-title">目录</strong>
    
        <ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#前言"><span class="nav-text">前言</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#机器语言"><span class="nav-text">机器语言</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#汇编指令组成"><span class="nav-text">汇编指令组成</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内存地址空间"><span class="nav-text">内存地址空间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8086-工作过程"><span class="nav-text">8086 工作过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8086-其它寄存器"><span class="nav-text">8086 其它寄存器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#几个简单的汇编指令"><span class="nav-text">几个简单的汇编指令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#总结"><span class="nav-text">总结</span></a></li></ol>
    
    </div>
  </aside>
</div>

<footer id="footer">
    <p> Powered_by
     <a href="http://hexo.io/" target="_blank">Hexo</a>
     and 
     <a href="https://github.com/caozhenwei/zw_theme" target="_blank">Hexo-theme-zw_theme  
     </a> 
      , copyright &copy; 2018 - 2019 caozhenwei All Rights Reserved.
    </p>
</footer>
    </main>
  </body>
</html>