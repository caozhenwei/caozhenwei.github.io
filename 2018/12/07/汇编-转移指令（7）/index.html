<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">

  
  <script src="/js/script.js"></script>
  

  <title>caozhenwei</title>
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/css/bootstrap.css" >
</head>
  <body>
    <header class="header-content">
<div class="header">
  <div class="blog-title">
    <img class="logo" src="https://raw.githubusercontent.com/caozhenwei/blog_pic/master/header_image_small.jpeg">
    <a href="/" class="title">caozhenwei</a>
  </div>
  <nav class="navbar">
    <ul class="menu">
      
        <li class="menu-item">
          <a href="/" class="menu-item-link">Home</a>
        </li>
      
        <li class="menu-item">
          <a href="/archives" class="menu-item-link">Archives</a>
        </li>
      
    </ul>
  </nav>
</div>
</header>
    <main class="main">
      <div class="content">
  <article class="article">
    <div class="article-detail">
      <!-- 标题 -->
      <div class="article-title">
        <h2 class="title">汇编--转移指令（7）</h2>
      </div>

      <!-- 时间 -->
      <div class="article-meta">
        <span class="article-time">2018-12-07</span>
      </div>

      <!-- 文章内容 -->
      <div class="article-content">
        <p>本篇主要介绍 8086CPU 的转移指令。</p>
<a id="more"></a>
<h4 id="转移指令"><a href="#转移指令" class="headerlink" title="转移指令"></a>转移指令</h4><p>修改 IP 或 同时修改 CS 和 IP 的指令称为转移指令。也就是说转移指令是能控制 CPU 执行内存中某处代码的指令。</p>
<!--more-->
<p>8086CPU 转移行为分类：</p>
<ul>
<li><p>只修改 IP ，称为段内转移，例如：jmp ax</p>
<p>  根据转移指令对 IP 修改范围，段内转移又可以分为：</p>
<ul>
<li>短转移：修改范围为 -128 ~ 127，2^7 = 128<ul>
<li>近转移：修改范围为 -32768 ~ 32767，2^15 = 32768</li>
</ul>
</li>
</ul>
</li>
<li>同时修改 CS 和 IP ，称为段间转移，例如：jmp 1000:0</li>
</ul>
<h4 id="依据位移进行转移的-jmp-指令"><a href="#依据位移进行转移的-jmp-指令" class="headerlink" title="依据位移进行转移的 jmp 指令"></a>依据位移进行转移的 jmp 指令</h4><p>jmp short 标号（转到标号处执行指令）</p>
<ul>
<li>8 位位移 = “标号”处的地址 - jmp 指令后的第一个字节的地址</li>
<li>short 指明此处的位移为 8 位位移</li>
<li>8 位位移的范围为 -128 ～ 127 ，用补码表示</li>
<li>8 位位移由编译程序在编译时算出</li>
</ul>
<p>jmp near ptr 标号      16 位位移</p>
<p>例如下面的程序:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">	start:  mov ax,0			;长度为3</span><br><span class="line">			jmp short s 		;长度为2</span><br><span class="line">			add ax,1			;长度为3</span><br><span class="line">        s:  inc ax			    ;长度为1	</span><br><span class="line">			mov ax,4c00h</span><br><span class="line">			int 21H	</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<p>当程序执行完后 ax 中的内容为 1 ，因为执行 jmp short s 后跳过了 add ax，1。从 debug （下图所示）中可以清楚的看到 jmp short s 直接由编译器编译成了 jmp 0008。来验证一下上面的计算方法 “8 位位移 = “标号”处的地址 - jmp 指令后的第一个字节的地址”，标号处的偏移地址为 8（3+2+3） ，jmp 指令后的第一个字节的地址为 5（3+2），即 8 位位移为 3，也就是下图中 jmp 处对应的机器码 EB03 中的 03。</p>
<p><img src="https://raw.githubusercontent.com/caozhenwei/blog_pic/master/asm/6/3.png" alt="3"></p>
<p>我们在上面的 jmp 指令前后各加一条指令再来验证下，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">	start:  mov ax,0			;长度为3</span><br><span class="line">			mov bx,0			;长度为3</span><br><span class="line">			jmp short s 		;长度为2</span><br><span class="line">			add ax,1			;长度为3</span><br><span class="line">			add ax,1			;长度为3</span><br><span class="line">        s:  inc ax			    ;长度为1	</span><br><span class="line">			mov ax,4c00h</span><br><span class="line">			int 21H	</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<p>标号处的偏移地址为 14，jmp 指令后的第一个字节的地址为 8，则 8 位位移为 6。如下图所示。</p>
<p><img src="https://raw.githubusercontent.com/caozhenwei/blog_pic/master/asm/6/4.png" alt="4"></p>
<p>“jmp near ptr 标号” 和 “jmp short 标号” 的功能相近，实现的段内近转移，它的功能为：</p>
<ul>
<li>16 位位移 = “标号”处的地址 - jmp 指令后的第一个字节的地址</li>
<li>near ptr 指明此处的位移为 16 位位移</li>
<li>16 位位移的范围为 -32768 ～ 32767 ，用补码表示</li>
<li>16 位位移由编译程序在编译时算出</li>
</ul>
<h4 id="转移的目的地址在指令中的-jmp-指令"><a href="#转移的目的地址在指令中的-jmp-指令" class="headerlink" title="转移的目的地址在指令中的 jmp 指令"></a>转移的目的地址在指令中的 jmp 指令</h4><p>“jmp far ptr 标号” 实现的是段间转移，也称为远转移，功能如下：</p>
<ul>
<li>（CS）= 标号处所在段的段地址</li>
<li>（IP）= 标号在段中的偏移地址</li>
</ul>
<p>far ptr 表明了指令用标号段的段地址和偏移地址来同时修改 CS 和 IP。代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">	start:  mov ax,0</span><br><span class="line">			mov bx,0</span><br><span class="line">			jmp far ptr s </span><br><span class="line">			db 256 dup (0)</span><br><span class="line">        s:  add ax,1</span><br><span class="line">			inc ax	</span><br><span class="line">			mov ax,4c00h</span><br><span class="line">			int 21H	</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<p>在 debug 中能够清楚的看到 jmp far ptr s 要跳转的段地址和偏移地址</p>
<p><img src="https://github.com/caozhenwei/blog_pic/raw/master/asm/6/5.png" alt="5"></p>
<h4 id="转移地址在内存中的-jmp-指令"><a href="#转移地址在内存中的-jmp-指令" class="headerlink" title="转移地址在内存中的 jmp 指令"></a>转移地址在内存中的 jmp 指令</h4><p>转移地址在内存中的 jmp 指令有两种方式：</p>
<ul>
<li>jmp word ptr 内存单元地址（段内转移）</li>
<li>jmp dword ptr 内存单元地址（段间转移）</li>
</ul>
<p>“jmp word ptr 内存单元地址” 的功能是从内存单元地址开始处存放着一个字，是转移的偏移地址。</p>
<p>“jmp dword ptr 内存单元地址” 的功能是从内存单元地址开始处存放着两个字节，高地址处的字是转移的目的段地址，低地址处是转移的目的偏移地址。</p>
<h4 id="jcxz-指令"><a href="#jcxz-指令" class="headerlink" title="jcxz 指令"></a>jcxz 指令</h4><p>jcxz 是条件转移指令，指令格式为：jcxz 标号（如果 cx 的值为 0，跳到标号处执行），所有的条件转移指令都是短转移。</p>
<h4 id="loop-指令"><a href="#loop-指令" class="headerlink" title="loop 指令"></a>loop 指令</h4><p>loop 指令为循环指令，指令格式为：loop 标号 （如果 cx 的值为不为 0 ，跳到标号处执行），所有的循环指令都是短转移。</p>

      </div>
    </div>
  </article>

  <!-- 目录 -->
  <aside id="toc-sidebar">
    <div id="toc" class="toc-article">
    <strong class="toc-title">目录</strong>
    
        <ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#转移指令"><span class="nav-text">转移指令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#依据位移进行转移的-jmp-指令"><span class="nav-text">依据位移进行转移的 jmp 指令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#转移的目的地址在指令中的-jmp-指令"><span class="nav-text">转移的目的地址在指令中的 jmp 指令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#转移地址在内存中的-jmp-指令"><span class="nav-text">转移地址在内存中的 jmp 指令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#jcxz-指令"><span class="nav-text">jcxz 指令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#loop-指令"><span class="nav-text">loop 指令</span></a></li></ol>
    
    </div>
  </aside>
</div>

<footer id="footer">
    <p> Powered_by
     <a href="http://hexo.io/" target="_blank">Hexo</a>
     and 
     <a href="https://github.com/caozhenwei/zw_theme" target="_blank">Hexo-theme-zw_theme  
     </a> 
      , copyright &copy; 2018 - 2019 caozhenwei All Rights Reserved.
    </p>
</footer>
    </main>
  </body>
</html>