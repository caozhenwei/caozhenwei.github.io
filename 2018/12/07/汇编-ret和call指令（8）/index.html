<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">

  
  <script src="/js/script.js"></script>
  

  <title>caozhenwei</title>
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/css/bootstrap.css" >
</head>
  <body>
    <header class="header-content">
<div class="header">
  <div class="blog-title">
    <img class="logo" src="https://raw.githubusercontent.com/caozhenwei/blog_pic/master/header_image_small.jpeg">
    <a href="/" class="title">caozhenwei</a>
  </div>
  <nav class="navbar">
    <ul class="menu">
      
        <li class="menu-item">
          <a href="/" class="menu-item-link">Home</a>
        </li>
      
        <li class="menu-item">
          <a href="/archives" class="menu-item-link">Archives</a>
        </li>
      
    </ul>
  </nav>
</div>
</header>
    <main class="main">
      <div class="content">
  <article class="article">
    <div class="article-detail">
      <!-- 标题 -->
      <div class="article-title">
        <h2 class="title">汇编--ret和call指令（8）</h2>
      </div>

      <!-- 时间 -->
      <div class="article-meta">
        <span class="article-time">2018-12-07</span>
      </div>

      <!-- 文章内容 -->
      <div class="article-content">
        <p>ret 和 call 指令都是转移指令，它们都修改 IP，或同时修改 CS 和 IP，经常用它们来共同完成子程序的设计</p>
<a id="more"></a>
<h4 id="ret-和-retf-指令"><a href="#ret-和-retf-指令" class="headerlink" title="ret 和 retf 指令"></a>ret 和 retf 指令</h4><p>ret 指令用栈中的内容来修改 IP，实现近转移。</p>
<p>retf 指令用栈中的数据来修改 CS 和 IP 内容来实现远转移。</p>
<p>CPU 执行 ret 指令时相当于 </p>
<ul>
<li>pop ip</li>
</ul>
<p>CPU 执行 retf 指令时相当于 </p>
<ul>
<li>pop ip</li>
<li>pop cs</li>
</ul>
<p>下面的程序 ret 指令执行后，CS：IP 执行代码段的第一条指令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assume cs:codesg,ss:stack</span><br><span class="line">stack segment</span><br><span class="line">	db 16 dup (0)</span><br><span class="line">stack ends</span><br><span class="line">codesg segment</span><br><span class="line">			mov ax,4c00h</span><br><span class="line">			int 21h</span><br><span class="line">	start:  mov ax,stack</span><br><span class="line">			mov ss,ax</span><br><span class="line">			mov sp,16</span><br><span class="line">			mov ax,0</span><br><span class="line">			push ax</span><br><span class="line">			mov bx,0</span><br><span class="line">			ret	</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<p>在 debug 中可以清楚的看到当执行完 ret 指令后，CS：IP 指向了程序的第一条指令。<br><img src="https://raw.githubusercontent.com/caozhenwei/blog_pic/master/asm/8/1.png" alt="1"></p>
<p>下面的程序 retf 指令执行后，CS：IP 执行代码段的第一条指令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assume cs:codesg,ss:stack</span><br><span class="line">stack segment</span><br><span class="line">	db 16 dup (0)</span><br><span class="line">stack ends</span><br><span class="line">codesg segment</span><br><span class="line">			mov ax,4c00h</span><br><span class="line">			int 21h</span><br><span class="line">	start:  mov ax,stack</span><br><span class="line">			mov ss,ax</span><br><span class="line">			mov sp,16</span><br><span class="line">			mov ax,0</span><br><span class="line">			push cs</span><br><span class="line">			push ax</span><br><span class="line">			mov bx,0</span><br><span class="line">			retf	</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<p>在 debug 中可以清楚的看到当执行完 retf 指令后，CS：IP 指向了程序的第一条指令。<br><img src="https://raw.githubusercontent.com/caozhenwei/blog_pic/master/asm/8/2.png" alt="2"></p>
<h4 id="call-指令"><a href="#call-指令" class="headerlink" title="call 指令"></a>call 指令</h4><p>执行 call 指令时，进行两步操作：</p>
<ul>
<li>将当前的 IP 或 CS 和 IP 压入栈中</li>
<li>转移</li>
</ul>
<p><mark>call 指令不能实现短转移</mark>。</p>
<h4 id="依据位移进行转移的-call-指令"><a href="#依据位移进行转移的-call-指令" class="headerlink" title="依据位移进行转移的 call 指令"></a>依据位移进行转移的 call 指令</h4><p>call 标号（将当前的 IP 压入栈后再跳到标号处执行）</p>
<p>执行 “call 标号” 相当于一下两步操作</p>
<ul>
<li>push IP</li>
<li>jmp near ptr 标号</li>
</ul>
<h4 id="转移的目的地址在指令中的-call-指令"><a href="#转移的目的地址在指令中的-call-指令" class="headerlink" title="转移的目的地址在指令中的 call 指令"></a>转移的目的地址在指令中的 call 指令</h4><p>指令 “call far ptr 标号” 实现的段间转移，CPU 在执行时相当于以下 3 步操作：</p>
<ul>
<li>push CS</li>
<li>push IP</li>
<li>jmp far ptr 标号</li>
</ul>
<h4 id="转移地址在寄存器中的-call-指令"><a href="#转移地址在寄存器中的-call-指令" class="headerlink" title="转移地址在寄存器中的 call 指令"></a>转移地址在寄存器中的 call 指令</h4><p>指令 “call 16位寄存器” 被 CPU 执行时，相当于以下 2 步操作：</p>
<ul>
<li>push IP</li>
<li>jmp 16位寄存器</li>
</ul>
<h4 id="转移地址在内存中的-call-指令"><a href="#转移地址在内存中的-call-指令" class="headerlink" title="转移地址在内存中的 call 指令"></a>转移地址在内存中的 call 指令</h4><p>转移地址在内存中的 call 指令有两种格式</p>
<ol>
<li>call word ptr 内存单元地址</li>
</ol>
<p>CPU 在执行上述指令的时候相当于以下 2 步：</p>
<ul>
<li>push IP</li>
<li>jmp word ptr 内存单元地址</li>
</ul>
<p>比如下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">	mov sp,10H</span><br><span class="line">	mov ax,0123H</span><br><span class="line">	mov ds:[0],ax</span><br><span class="line">	call word ptr ds:[0]</span><br><span class="line"></span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line">codesg ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>在执行完 “call word ptr 内存单元” 后相当于执行了 “push ip” 和 “jmp word ptr 内存单元地址” 两条指令，push 后栈顶要向上移动 2 个单元，即 sp 中的值减 2（10H - 2 = 0EH）。“jmp word ptr 内存单元地址” 相当于用内存单元中的值去修改 IP，执行后 IP 为 0123H（“jmp word ptr 内存单元地址” 忘了的话返回前面的文章复习一下）。在 debug 中可以清楚的看到结果。</p>
<p><img src="https://raw.githubusercontent.com/caozhenwei/blog_pic/master/asm/8/3.png" alt="3"></p>
<ol>
<li>call dword ptr 内存单元地址</li>
</ol>
<p>CPU 在执行上述指令的时候相当于以下 2 步操作：</p>
<ul>
<li>push cs</li>
<li>push ip</li>
<li>jmp dword ptr 内存单元地址</li>
</ul>
<p>例如下面的代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">	mov sp,10H</span><br><span class="line">	mov ax,0123H</span><br><span class="line">	mov ds:[0],ax</span><br><span class="line">	mov word ptr ds:[2],0</span><br><span class="line">	call dword ptr ds:[0]</span><br><span class="line"></span><br><span class="line">	mov ax,4c00H </span><br><span class="line">	int 21H</span><br><span class="line">codesg ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>执行 “call dword ptr ds:[0]” 后，cs 的值为 0 ，ip 为 0123H，sp 为 0ch，在 debug 中显示如下：</p>
<p><img src="https://raw.githubusercontent.com/caozhenwei/blog_pic/master/asm/8/4.png" alt="4"></p>
<h4 id="call-和-ret-的配合使用"><a href="#call-和-ret-的配合使用" class="headerlink" title="call 和 ret 的配合使用"></a>call 和 ret 的配合使用</h4><p>我们知道使用 call 指令的时候会先进行入栈操作，然后再跳到标号处去执行程序，ret 是用栈中的数据去修改 IP 或 CS 和 IP 来达到控制 CPU 执行指令的目的，这样就可以用 call 和 ret 指令来实现调用子程序的目的。例如下面的程序是调用子程序来实现 2 的 3 次方并将结果存放到 bx 中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">	mov ax,1</span><br><span class="line">	mov cx,3</span><br><span class="line">	call s </span><br><span class="line">	mov bx,ax</span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21H</span><br><span class="line">s: add ax,ax</span><br><span class="line">	loop s</span><br><span class="line">	ret</span><br><span class="line">codesg ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>执行完后，我们看到 bx 中内容为 8 ，是我们希望得到的结果，在 debug 中显示如下：</p>
<p><img src="https://raw.githubusercontent.com/caozhenwei/blog_pic/master/asm/8/5.png" alt="5"></p>
<h4 id="一些思考"><a href="#一些思考" class="headerlink" title="一些思考"></a>一些思考</h4><p>上面的程序中我们没有向子程序中传递参数，那怎么实现向子程序传递参数呢？我们可以用一个寄存器来传递，即调用者将要传递的参数放到某个合法的寄存器中，子程序执行的时候来修改这个寄存器，这样就实现了传递参数并返回的功能。那么要传递一堆参数给子程序该怎么办呢？其实可以把这堆参数放到内存里，寄存器只保留这个内存的首部地址即可。要是调用者和子程序都使用了相同的寄存器，这岂不是混乱了？一般的做法是在调用子程序的时候把寄存器的值都入栈，等到子程序返回时再把出栈来恢复主程序寄存器的值。</p>

      </div>
    </div>
  </article>

  <!-- 目录 -->
  <aside id="toc-sidebar">
    <div id="toc" class="toc-article">
    <strong class="toc-title">目录</strong>
    
        <ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#ret-和-retf-指令"><span class="nav-text">ret 和 retf 指令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#call-指令"><span class="nav-text">call 指令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#依据位移进行转移的-call-指令"><span class="nav-text">依据位移进行转移的 call 指令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#转移的目的地址在指令中的-call-指令"><span class="nav-text">转移的目的地址在指令中的 call 指令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#转移地址在寄存器中的-call-指令"><span class="nav-text">转移地址在寄存器中的 call 指令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#转移地址在内存中的-call-指令"><span class="nav-text">转移地址在内存中的 call 指令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#call-和-ret-的配合使用"><span class="nav-text">call 和 ret 的配合使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#一些思考"><span class="nav-text">一些思考</span></a></li></ol>
    
    </div>
  </aside>
</div>

<footer id="footer">
    <p> Powered_by
     <a href="http://hexo.io/" target="_blank">Hexo</a>
     and 
     <a href="https://github.com/caozhenwei/zw_theme" target="_blank">Hexo-theme-zw_theme  
     </a> 
      , copyright &copy; 2017 - 2018 caozhenwei All Rights Reserved.
    </p>
</footer>
    </main>
  </body>
</html>