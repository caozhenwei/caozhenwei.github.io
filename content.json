{"meta":{"title":"caozhenwei","subtitle":null,"description":"caozhenwei 在 Github 上的个人博客","author":"caozhenwei","url":"https://github.com/caozhenwei"},"pages":[{"title":"Tags","date":"2018-03-21T11:44:58.000Z","updated":"2018-03-22T03:36:37.824Z","comments":true,"path":"Tags/index.html","permalink":"https://github.com/caozhenwei/Tags/index.html","excerpt":"","text":"123333"},{"title":"about","date":"2018-03-22T02:33:25.000Z","updated":"2018-03-22T03:43:01.345Z","comments":true,"path":"about/index.html","permalink":"https://github.com/caozhenwei/about/index.html","excerpt":"","text":""}],"posts":[{"title":"CSS之伪类和伪元素","slug":"CSS之伪类和伪元素","date":"2018-07-03T08:25:45.000Z","updated":"2018-07-12T05:33:59.756Z","comments":true,"path":"2018/07/03/CSS之伪类和伪元素/","link":"","permalink":"https://github.com/caozhenwei/2018/07/03/CSS之伪类和伪元素/","excerpt":"w3school 上的定义伪类用于向某些选择器添加特殊的效果。","text":"w3school 上的定义伪类用于向某些选择器添加特殊的效果。 伪类W3C 上的定义The pseudo-class concept is introduced to permit selection based on information that lies outside of the document tree or that cannot be expressed using the other simple selectors. A pseudo-class always consists of a “colon” (:) followed by the name of the pseudo-class and optionally by a value between parentheses. Pseudo-classes are allowed in all sequences of simple selectors contained in a selector. Pseudo-classes are allowed anywhere in sequences of simple selectors, after the leading type selector or universal selector (possibly omitted). Pseudo-class names are case-insensitive. Some pseudo-classes are mutually exclusive, while others can be applied simultaneously to the same element. Pseudo-classes may be dynamic, in the sense that an element may acquire or lose a pseudo-class while a user interacts with the document. 伪类存在的意义是为了通过选择器找到那些不存在 DOM 树中的信息以及不能被常规 CSS 选择器获取到的信息。伪类总是由“冒号”(:)和伪类的名称以及括号之间的值组成。在选择器中包含的所有简单选择器序列中都允许使用伪类。在引导类型选择器或通用选择器(可能省略了)之后，伪类可以在简单的选择器序列中任意位置进行。伪类的名称是不区分大小写的。有些伪类是互斥的，而另一些则可以同时应用于相同的元素。伪类可以是动态的，因为元素可以在用户与文档交互时获得或丢失伪类。 Selector Meaning CSS :active 选择正在被激活的元素 1 :hover 选择被鼠标悬浮着元素 1 :link 选择未被访问的元素 1 :visited 选择已被访问的元素 1 :first-child 选择满足是其父元素的第一个子元素的元素 2 :lang 选择带有指定 lang 属性的元素 2 :focus 选择拥有键盘输入焦点的元素 2 :enable 选择每个已启动的元素 3 :disable 选择每个已禁止的元素 3 :checked 选择每个被选中的元素 3 :target 选择当前的锚点元素 3 :first-of-type 选择满足是其父元素的第一个某类型子元素的元素 3 :last-of-type 选择满足是其父元素的最后一个某类型子元素的元素 3 :only-of-type 选择满足是其父元素的唯一一个某类型子元素的元素 3 :nth-of-type(n) 选择满足是其父元素的第n个某类型子元素的元素 3 :nth-last-of-type(n) 选择满足是其父元素的倒数第n个某类型的元素 3 :only-child 选择满足是其父元素的唯一一个子元素的元素 3 :last-child 选择满足是其父元素的最后一个元素的元素 3 :nth-child(n) 选择满足是其父元素的第n个子元素的元素 3 :nth-last-child(n) 选择满足是其父元素的倒数第n个子元素的元素 3 :empty 选择满足没有子元素的元素 3 :in-range 选择满足值在指定范围内的元素 3 :out-of-range 选择值不在指定范围内的元素 3 :invalid 选择满足值为无效值的元素 3 :valid 选择满足值为有效值的元素 3 :not(selector) 选择不满足selector的元素 3 :optional 选择为可选项的表单元素，即没有“required”属性 3 :read-only 选择有”readonly”的表单元素 3 :read-write 选择没有”readonly”的表单元素 3 :root 选择根元素 3 w3school 上的定义CSS 伪元素用于向某些选择器设置特殊效果。 W3C 上的定义Pseudo-elements create abstractions about the document tree beyond those specified by the document language. For instance, document languages do not offer mechanisms to access the first letter or first line of an element’s content. Pseudo-elements allow authors to refer to this otherwise inaccessible information. Pseudo-elements may also provide authors a way to refer to content that does not exist in the source document (e.g., the ::before and ::after pseudo-elements give access to generated content). A pseudo-element is made of two colons (::) followed by the name of the pseudo-element. This :: notation is introduced by the current document in order to establish a discrimination between pseudo-classes and pseudo-elements. For compatibility with existing style sheets, user agents must also accept the previous one-colon notation for pseudo-elements introduced in CSS levels 1 and 2 (namely, :first-line, :first-letter, :before and :after). This compatibility is not allowed for the new pseudo-elements introduced in this specification. Only one pseudo-element may appear per selector, and if present it must appear after the sequence of simple selectors that represents the subjects of the selector. Note: A future version of this specification may allow multiple pseudo-elements per selector. Selector Meaning CSS ::first-letter 选择指定元素的第一个单词 1 ::first-line 选择指定元素的第一行 1 ::after 在指定元素的内容前面插入内容 2 ::before 在指定元素的内容后面插入内容 2 ::selection 选择指定元素中被用户选中的内容 3 W3C 指万维网联盟（World Wide Web Consortium） 如何阅读W3C规范（高博翻译版）http://www.chinaw3c.org/how-to-read-spec-gb.html","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://github.com/caozhenwei/tags/CSS/"}]},{"title":"CSS选择器","slug":"CSS选择器","date":"2018-06-27T11:23:50.000Z","updated":"2018-07-09T09:28:26.167Z","comments":true,"path":"2018/06/27/CSS选择器/","link":"","permalink":"https://github.com/caozhenwei/2018/06/27/CSS选择器/","excerpt":"基本规则每个规则有两个基本部分：选择器和声名块（可以由一个或多个声名组成）。","text":"基本规则每个规则有两个基本部分：选择器和声名块（可以由一个或多个声名组成）。 元素选择器 h1 &#123;color: gray;&#125; 选择器分组 h2, p &#123;color: gray;&#125; 通配选择器 * &#123;color: gray;&#125; 声名分组 h1 &#123;color: gray; font: 18px;&#125; 结合选择器和声名分组 h2, p &#123;color: gray; font: 18px;&#125; h2&#123; /* 标签选择 */&#125;p,h1&#123; /* 使用逗号实现元素合集 */&#125;div h1,div h2&#123; /* 使用空格实现后代元素(子元素和子孙元素)查询，表示div的后代元素h1，h1和div的合集，在从合集中查找后代元素h2，最后查询到的为h2列表 */ background-color: #2b542c;&#125;p&gt;h1&#123; /* &gt;表示直接子元素 */&#125;p+h1&#123; /* +表示紧接在后面的同胞元素，选择h1元素 */&#125;html&gt;body table+ul&#123; /* 在html元素中查询直接子元素body，在body中查询后代元素table，在table元素后面查询同胞元素ul，即在最后选择的为ul列表 */&#125;body *&#123; /* *通配符选择器，匹配所有元素，表示匹配body的所有后代元素 */&#125;p.class1.class2&#123; /* .表示class类选择器，p为标签，连在一块写，表示多重筛选，一个元素可以有多个样式 */&#125;#id1&#123; /* #id选择器，一个元素只能有一个id，所有元素的id不能相同 */&#125; 类选择器&lt;p class=\"test\"&gt;aaa&lt;/p&gt; .p &#123;color: gray;&#125; 多类选择器 &lt;p class=\"test test1\"&gt;aaa&lt;/p&gt; .test &#123;color: gray;&#125; ID 选择器&lt;p id=\"test\"&gt;aaa&lt;/p&gt; #test &#123;color: gray;&#125; 属性选择器&lt;p class=\"test\"&gt;aaa&lt;/p&gt; p[class] &#123;color: gray;&#125; 根据多个属性选择，下面的例子将同时有 href 和 title 属性的 a 标签的文本设置为粗体 a[herf][title] &#123;font-weight: bold;&#125; 根据具体属性值选择 只选 moons 属性值为 1 的那些 planet 元素 planet[moons= \"1\"] &#123;font-weight: bold;&#125; 根据部分属性选择 &lt;p class=\"test test1\"&gt;aaa&lt;/p&gt; p[class~\"test\"] &#123;color: gray;&#125; 类型 描述 [p^=”test”] 选择 p 属性值以 test 开头的所有元素 [p$”test”] 选择 p 属性值以 test 结尾的所有元素 [p^=”test”] 选择 p 属性值中包含字符串 test 的所有元素 p[attribute1][attribute2]&#123; /* [] 属性选择器，表示具有某种属性的所有元素，多个参数表示同时具有多个属性，class也可以作为一个属性筛选 */&#125;a[href=\"http://www.123.com\"]&#123; /* =具有某个属性，且属性值等于指定值的所有元素 */&#125;div[class~=\"class1\"]&#123; /* ~=具有某个属性，且属性值包含指定值的所有元素 */&#125;input[title^=\"title1\"]&#123; /* ^=指定属性的值以指定字符串开头 */&#125;input[title$=\"title1\"]&#123; /* $=指定属性的值以指定字符串结尾 */&#125;input[title*=\"title1\"]&#123; /* *=指定属性的值包含指定字符串 */&#125;input[title|=\"title1\"]&#123; /* |=指定属性的值等于title1或者以title1-开头 */&#125; 后代选择器h1 p &#123;color: gray;&#125; 只选择 h1 子元素的 p 元素 h1 &gt; p &#123;color: gray;&#125; 选择相邻兄弟元素，例如下面的修改紧接着 h1 元素后出现的 p 元素颜色 h1 + p &#123;color: gray;&#125;","categories":[],"tags":[]},{"title":"CSS之float","slug":"CSS之float","date":"2018-06-25T11:48:47.000Z","updated":"2018-07-04T09:15:32.249Z","comments":true,"path":"2018/06/25/CSS之float/","link":"","permalink":"https://github.com/caozhenwei/2018/06/25/CSS之float/","excerpt":"设置了 float 属性的元素会根据属性值向左或向右浮动，我们称设置了 float 属性的元素为浮动元素。浮动元素会从普通文档流中脱离，但浮动元素影响的不仅是自己，它会影响周围的元素对齐进行环绕。如果被设置了浮动，那浮动元素会生成一个块级框。","text":"设置了 float 属性的元素会根据属性值向左或向右浮动，我们称设置了 float 属性的元素为浮动元素。浮动元素会从普通文档流中脱离，但浮动元素影响的不仅是自己，它会影响周围的元素对齐进行环绕。如果被设置了浮动，那浮动元素会生成一个块级框。 浮动元素的包含块就是离浮动元素最近的块级祖先元素。 浮动元素在浮动的时候，其 margin 不会超过包含块的 padding 。 如果有多个浮动元素，后面的浮动元素的 margin 不会超过前面浮动元素的 margin。 如果两个元素一个向左浮动，一个向右浮动，左浮动元素的 marginRight 不会和右浮动元素的 marginLeft 相邻。 浮动元素顶端不会超过包含块的内边界底端，如果有多个浮动元素，下一个浮动元素的顶端不会超过上一个浮动元素的底端。 如果有非浮动元素和浮动元素同时存在，并且非浮动元素在前，则浮动元素不会不会高于非浮动元素。 浮动元素会尽可能地向顶端对齐、向左或向右对齐。 clear 属性：确保当前元素的左右两侧不会有浮动元素。 如果浮动非替换元素，则要指定一个明确的宽度，否则，它们会尽可能地窄。 替换元素是浏览器根据其标签的元素与属性来判断显示具体的内容。img、input、textarea、select、object 等都是替换元素，这些元素都没有实际的内容。替换元素可以增加行框高度，但不增加 line-height。 非替换元素：大多数元素是不可替换元素，他们将内容直接告诉浏览器，将其显示出来。比如 p的内容、label的内容；浏览器将把这段内容直接显示出来。","categories":[],"tags":[]},{"title":"CSS之Flex布局","slug":"CSS之Flex布局","date":"2018-06-19T02:22:18.000Z","updated":"2018-06-19T03:58:20.799Z","comments":true,"path":"2018/06/19/CSS之Flex布局/","link":"","permalink":"https://github.com/caozhenwei/2018/06/19/CSS之Flex布局/","excerpt":"Flex布局是什么？Flex 是 Flexible Box 的缩写，意为”弹性盒子”，用来为盒状模型提供最大的灵活性。布局的传统解决方案是基于盒状模型，依赖 display 属性 + position 属性 + float 属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。学习 Flex 布局要先了弹性容器和项目。给容器添加 display: flex 就表示它要用弹性布局，弹性盒子里面的子元素称为项目。","text":"Flex布局是什么？Flex 是 Flexible Box 的缩写，意为”弹性盒子”，用来为盒状模型提供最大的灵活性。布局的传统解决方案是基于盒状模型，依赖 display 属性 + position 属性 + float 属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。学习 Flex 布局要先了弹性容器和项目。给容器添加 display: flex 就表示它要用弹性布局，弹性盒子里面的子元素称为项目。 弹性盒子模型弹性盒子的模型如下所示。 弹性盒子有两条轴，默认的水平主轴和竖直轴。主轴的开始位置（与边框的交叉点）叫做 main start，结束位置叫做 main end；交叉轴的开始位置叫做 cross start，结束位置叫做cross end。项目默认沿主轴排列。单个项目占据的主轴空间叫做 main size，占据的交叉轴空间叫做 cross size 。 上面的这段对于没接触过 CSS 的同学估计会稍微难理解点。一时看不懂很正常，接着往下看就会明白了。先说两条轴，说到这里我们思考一下，为什么要有两条轴呢？想象一大堆元素在盒子里等着我们来摆放它们的位置，怎么来摆放呢，肯定要确定一个放置的方向啊，那就对了，可以在水平方向上从左到右、从右到左，当然也可以在垂直方向上从上到下或者从下到上，这种方向就是上面说的那两条轴。 使用弹性布局注意事项使用弹性布局后要注意下面几点： 容器添加弹性布局后，仅仅是容器内容采用弹性布局，而容器本身在文档流中的定位方式依然遵循常规文档流 display:flex; 容器添加弹性布局后，显示为块级元素； display:inline-flex; 容器添加弹性布局后，显示为行级元素； 设为 Flex 布局后，子元素的 float、clear 和 vertical-align 属性将失效。但是position 属性，依然生效。 弹性容器常用属性 flex-direction flex-wrap flex-flow justify-content align-items align-content flex-directionflex-direction 属性决定主轴的方向（即项目的排列方向）。 .box &#123; flex-direction: row | row-reverse | column | column-reverse;&#125; row：从左上角开始，由左到右排列。row-reverse：从右上角开始，由右向左排列。column：从左上角开始，由上往下排列。column-reverse：从左下角开始，由下向上排列。 flex-wrapflex-wrap 属性定义，规定如果一条轴线排不下，如何换行。 .box&#123; flex-wrap: nowrap | wrap | wrap-reverse;&#125; nowrap（默认）：不换行。wrap：换行，第一行在上方。wrap-reverse：换行，第一行在下方。 flex-flowflex-flow 属性是 flex-direction 属性和 flex-wrap 属性的简写形式，默认值为 row nowrap。 .box &#123; flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;&#125; justify-contentjustify-content 属性定义了项目在主轴上的对齐方式。 .box &#123; justify-content: flex-start | flex-end | center | space-between | space-around;&#125; flex-start（默认值）：左对齐flex-end：右对齐center： 居中space-between：两端对齐，项目之间的间隔都相等。space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 align-itemsalign-items 属性定义项目在交叉轴上如何对齐。 .box &#123; align-items: flex-start | flex-end | center | baseline | stretch;&#125; flex-start：交叉轴的起点对齐。flex-end：交叉轴的终点对齐。center：交叉轴的中点对齐。baseline: 项目的第一行文字的基线对齐。stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 align-contentalign-content 属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 .box &#123; align-content: flex-start | flex-end | center | space-between | space-around | stretch;&#125; flex-start：与交叉轴的起点对齐。flex-end：与交叉轴的终点对齐。center：与交叉轴的中点对齐。space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。stretch（默认值）：轴线占满整个交叉轴。 项目常用属性 order flex-grow flex-shrink flex-basis flex align-self order 属性定义项目的排列顺序。数值越小，排列越靠前，默认为 0 。 flex-grow 属性定义项目的放大比例，默认为 0 ，即如果存在剩余空间，也不放大。 flex-shrink 属性定义了项目的缩小比例，默认为 1，即如果空间不足，该项目将缩小。 flex-basis 属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为 auto ，即项目的本来大小。 flex 属性是 flex-grow, flex-shrink 和 flex-basis 的简写，默认值为 0 1 auto。后两个属性可选。 align-self 属性允许单个项目有与其他项目不一样的对齐方式，可覆盖 align-items 属性。默认值为 auto，表示继承父元素的 align-items 属性，如果没有父元素，则等同于 stretch。 参考链接 https://scotch.io/tutorials/a-visual-guide-to-css3-flexbox-properties#basics https://css-tricks.com/snippets/css/a-guide-to-flexbox https://www.processon.com","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://github.com/caozhenwei/tags/CSS/"}]},{"title":"Cycript 简单使用","slug":"Cycript-简单使用","date":"2018-05-28T08:56:29.000Z","updated":"2018-07-04T09:16:18.147Z","comments":true,"path":"2018/05/28/Cycript-简单使用/","link":"","permalink":"https://github.com/caozhenwei/2018/05/28/Cycript-简单使用/","excerpt":"cycript 官方文档 http://www.cycript.org/manual/ Cycript 允许开发人员在 iOS 或 Mac OS X 上使用 objective - c++ 和 JavaScript 语法的混合工具来探索和修改运行的应用程序，通过一个具有语法高亮和标签完成功能的交互式控制台。(它还能在 Android 和 Linux 上独立运行，并提供对 Java 的访问，但没有注入。)","text":"cycript 官方文档 http://www.cycript.org/manual/ Cycript 允许开发人员在 iOS 或 Mac OS X 上使用 objective - c++ 和 JavaScript 语法的混合工具来探索和修改运行的应用程序，通过一个具有语法高亮和标签完成功能的交互式控制台。(它还能在 Android 和 Linux 上独立运行，并提供对 Java 的访问，但没有注入。) Cycript allows developers to explore and modify running applications on either iOS or Mac OS X using a hybrid of Objective-C++ and JavaScript syntax through an interactive console that features syntax highlighting and tab completion. (It also runs standalone on Android and Linux and provides access to Java, but without injection.) ssh 到手机后，启动 app 并且确保它在前台运行，然后执行 cycript -p WeChat 出现 cy# 提示符号表示成功。 常用操作 显示 alertalertView = [[UIAlertView alloc] initWithTitle:@”test” message:@”Cycript” delegate:nil cancelButtonTitle:@”OK” otherButtonTitles:nil];[alertView show]; 查看当前控制器UIApp.keyWindow.rootViewController.visibleViewController 获取 bundle info[[NSBundle mainBundle] infoDictionary].toString() 显示 Controller 的层次结构_printHierarchy 是 UIViewController 的一个私有方法，你可以用它将 view controller 层次打印到控制台。[[[UIWindow keyWindow] rootViewController] _printHierarchy].toString() 修改某个 label 的文字#0x1530cd5f0.text = @&quot;111&quot; 修改某个 view 的 backgroundColor#0x1409777b0.backgroundColor = [UIColor redColor] 打印 view 层级[[UIApp keyWindow] recursiveDescription].toString() 打印层级树[[UIApp keyWindow] _autolayoutTrace].toString() _ivarDescription 获取某个类的属性[choose(FixTitleColorButton)[0] _ivarDescription].toString() _methodDescription[choose(FixTitleColorButton)[0] _methodDescription].toString() 打印视图的响应者 [#0x12e5629f0 nextResponder]","categories":[],"tags":[]},{"title":"iOS 逆向之砸壳","slug":"iOS-逆向之砸壳","date":"2018-05-28T01:45:17.000Z","updated":"2018-07-04T09:16:40.812Z","comments":true,"path":"2018/05/28/iOS-逆向之砸壳/","link":"","permalink":"https://github.com/caozhenwei/2018/05/28/iOS-逆向之砸壳/","excerpt":"前言从 AppStore 下载的 App 是被苹果使用 FairPlay 技术加密过的， 可执行文件被套上了一层保护壳， 而 class-dump Hopper 等工具无法作用于加密过的 App。 在这种情况下， 想要获取头文件， 需要先解密 App 的可执行文件， 俗称“砸壳”。 砸壳的工具有好多种，其核心原理就是将内存中已解密的镜像 “dump” 出来，再生成新的镜像文件，从而达到解密的效果。可执行程序要想运行起来，必须由操作系统把可执行文件加载进内存，iOS 中用的是 DYLD。","text":"前言从 AppStore 下载的 App 是被苹果使用 FairPlay 技术加密过的， 可执行文件被套上了一层保护壳， 而 class-dump Hopper 等工具无法作用于加密过的 App。 在这种情况下， 想要获取头文件， 需要先解密 App 的可执行文件， 俗称“砸壳”。 砸壳的工具有好多种，其核心原理就是将内存中已解密的镜像 “dump” 出来，再生成新的镜像文件，从而达到解密的效果。可执行程序要想运行起来，必须由操作系统把可执行文件加载进内存，iOS 中用的是 DYLD。 dumpdecrypteddumpdecrypted 就是由越狱社区的知名人士 Stefan Esser（ @i0n1c） 出品的一款砸壳工具， 被越狱社区广泛运用在 iOS 逆向工程研究中。下面介绍怎么用 dumpdecrypted 给 app 砸壳。下载 dumpdecrypted 地址为 https://github.com/stefanesser/dumpdecrypted/下载完成后直接 make （如果安装了不同的 iOS SDK，可以调整 Makefile 文件），一切顺利的话会生成名为 dumpdecrypted.dylib 的动态库，先暂时放在这里留着备用。 SSH 连接越狱 iDivice为了书写和描述，我们把 iPhone、iPad、iPod 等 统称为 iDivice 。iDivice 越狱后有 root 和 mobile 两个账户，默认密码为 alpine ，建议马上修改这个默认的密码，防止其他人通过这个默认密码登录 iDivice 。修改命令如下： $ su root$ passwdChanging password for root.New password:Retype new password: 越狱 iDivice 使用 Cydia 搜索 openSSH ，安装即可。连接方式有两种 2.1 WiFi 连接首先确保 iDivice 和 电脑在统一局域网，连接操作如下 $ ssh root@x.x.x.x 其中 x.x.x.x 为 iDivice 的 ip 地址。 2.2 USB连接2.2.1 安装 usbmuxd$ brew install usbmuxd 2.2.2 端口映射$ iproxy 2345 22 相当于把 iDivice 的 22 端口映射到电脑的 2345 端口 2.2.3 连接新开一个终端窗口，并且保持 2.2 中的终端窗口没有被关闭 $ ssh -p 2345 root@127.0.0.1 获取两个路径查看 app 进程，这里以 WeChat 为例 ，这里要保证 WeChat 在前台运行 $ ps -ef | grep /var/mobile/ 501 506 1 0 0:00.00 ?? 1:19.23 /var/mobile/Containers/Bundle/Application/F14174A6-AEC8-4AD4-A09A-9049FDCBB55E/WeChat.app/WeChat 0 1529 1482 0 0:00.00 ttys001 0:00.01 grep /var/mobile/ 先记下这个路径备用 查看 app Document 路径这个需要用到 cycript 这个工具。cycript 是混合了 oc 与 js 语法的一个工具, 让开发者在命令行下和应用交互，在运行时查看和修改应用，挂钩相关的进程后，我们就可以用 oc 的方法来查看 app Document 路径了。挂钩进程 $ cycript -p WeChatcy# [[NSFileManager defaultManager] URLsForDirectory:NSDocumentDirectory inDomains:NSUserDomainMask]@[#\"file:///var/mobile/Containers/Data/Application/6475E209-3EF7-4264-ADC5-FBE0264516BF/Documents/\"]cy# 退出 cy# 模式的快捷键为 ctl + d，把上面输出的路径也记下来备用。 把第一步中生成的 dumpdecripted.dylib 动态库拷贝到该 app 的 Document 目录下该操作要用到 scp 命令。scp 是 secure copy 的缩写, 基于 ssh 登陆进行安全的远程文件拷贝命令。例子：两台机器IP分别为：A 192.168.11.10，B 192.168.11.11，如果想把 A 根目录上的 a.jpg 文件拷到 B 上，命令如下：在A服务器上操作 命令为： $ scp /a.jpg root@192.168.11.11:/ 所以此时把生成的 dumpdecripted.dylib 动态库拷贝到该 app 的 Document 目录，命令如下：在 mac的终端上操作 $ scp dumpdecrypted.dylib root@x.x.x.x:/var/mobile/Containers/Data/Application/6475E209-3EF7-4264-ADC5-FBE0264516BF/Documents/ 开始砸壳进入 Document 目录$ cd /var/mobile/Containers/Data/Application/6475E209-3EF7-4264-ADC5-FBE0264516BF/Documents/ 砸壳 $ DYLD_INSERT_LIBRARIES=dumpdecrypted.dylib /var/mobile/Containers/Bundle/Application/F14174A6-AEC8-4AD4-A09A-9049FDCBB55E/WeChat.app/WeChatmach-o decryption dumperDISCLAIMER: This tool is only meant for security research purposes, not for application crackers.[+] detected 64bit ARM binary in memory.[+] offset to cryptid found: @0x1000fcca8(from 0x1000fc000) = ca8[+] Found encrypted data at address 00004000 of length 58818560 bytes - type 1.[+] Opening /private/var/mobile/Containers/Bundle/Application/F14174A6-AEC8-4AD4-A09A-9049FDCBB55E/WeChat.app/WeChat for reading.[+] Reading header[+] Detecting header type[+] Executable is a plain MACH-O image[+] Opening WeChat.decrypted for writing.[+] Copying the not encrypted start of the file[+] Dumping the decrypted data into the file[+] Copying the not encrypted remainder of the file[+] Setting the LC_ENCRYPTION_INFO-&gt;cryptid to 0 at offset ca8[+] Closing original file[+] Closing dump file$ ls00000000000000000000000000000000 MMResourceMgr OpenImResource db.globalconfigCrashReport MMappedKV SafeMode.dat dumpdecrypted.dylibLocalInfo.lst MemoryStat WeChat.decrypted heavy_user_id_mapping.dat 此时就可以在当前目录下看到被砸壳后的 WeChat.decrypted。 获取可执行文件的所有头文件从 iDvice 上把解密后的文件拷到电脑的桌面上，在电脑终端上操作 $ scp root@x.x.x.x:/var/mobile/Containers/Data/Application/6475E209-3EF7-4264-ADC5-FBE0264516BF/Documents/WeChat.decrypted ~/Desktop/``` 获取 .h 文件需要用到 class-dump 工具，下载地址为 http://stevenygard.com/projects/class-dump/。把砸壳后的可执行文件的所有 .h 文件输出到 wechat_test_h 文件夹下``` bashclass-dump -H WeChat.decrypted -o wechat_test_h 这时候就能看到所有 WeChat 的头文件了。 相关链接FairPlay https://en.wikipedia.org/wiki/FairPlaydumpdecrypted https://github.com/stefanesser/dumpdecrypted/class-dump http://stevenygard.com/projects/class-dump/","categories":[],"tags":[]},{"title":"Logos 语法","slug":"Logos-语法","date":"2018-05-24T06:30:55.000Z","updated":"2018-07-04T09:16:56.444Z","comments":true,"path":"2018/05/24/Logos-语法/","link":"","permalink":"https://github.com/caozhenwei/2018/05/24/Logos-语法/","excerpt":"前言这篇文章翻译自 http://iphonedevwiki.net/index.php/Logos，主要是 logos 语法。Logos 是 Theos 开发套件的一个组成部分，它允许使用一组特殊的预处理器指令，轻松地、清晰地编写方法来 hook 代码。","text":"前言这篇文章翻译自 http://iphonedevwiki.net/index.php/Logos，主要是 logos 语法。Logos 是 Theos 开发套件的一个组成部分，它允许使用一组特殊的预处理器指令，轻松地、清晰地编写方法来 hook 代码。 综述","categories":[],"tags":[]},{"title":"Mach-O 学习","slug":"Mach-O-学习","date":"2018-05-22T07:10:31.000Z","updated":"2018-06-26T09:59:28.473Z","comments":true,"path":"2018/05/22/Mach-O-学习/","link":"","permalink":"https://github.com/caozhenwei/2018/05/22/Mach-O-学习/","excerpt":"Mach-O，是 Mach object 文件格式的缩写，同样也是 OS X 和 iOS 系统中可执行文件格式。类似于 Linux 下的 elf。除了可执行文件外，动态链接库、静态链接库等都是这种格式的。了解 Mach-O ，也助于我们更好的学习 iOS 逆向工程。","text":"Mach-O，是 Mach object 文件格式的缩写，同样也是 OS X 和 iOS 系统中可执行文件格式。类似于 Linux 下的 elf。除了可执行文件外，动态链接库、静态链接库等都是这种格式的。了解 Mach-O ，也助于我们更好的学习 iOS 逆向工程。 Mach-O 结构简单介绍Mach-O 主要由三部分组成：Header、Load commands、Raw segment data，如下图所示： Header保存了 Mach-O 的一些基本信息，包括了平台、文件类型、LoadCommands 的个数等等。 LoadCommands这些指令非常清晰地指示加载器如何设置并且加载二进制数据，这一段紧跟 Header，加载 Mach-O 文件时会使用这里的数据来确定内存的分布。 Data 每一个 segment 的具体数据都保存在这里，这里包含了具体的代码、数据等等。 Mach-O 三部分结构详细介绍Header我们可以用 otool 先来看看 iOS 中一个可执行文件的头信息，这里拿微信来看看，otool -h WeChat: $ otool -h WeChat Mach header magic cputype cpusubtype caps filetype ncmds sizeofcmds flags 0xfeedface 12 9 0x00 2 86 8192 0x00218085Mach header magic cputype cpusubtype caps filetype ncmds sizeofcmds flags 0xfeedfacf 16777228 0 0x00 2 86 8984 0x00218085 下面详细介绍下这都代表什么意思。 头信息的结构可以在 /usr/include/mach-o/loader.h 中查看 /* * The 32-bit mach header appears at the very beginning of the object file for * 32-bit architectures. */struct mach_header &#123; uint32_t magic; /* mach magic number identifier */ cpu_type_t cputype; /* cpu specifier */ cpu_subtype_t cpusubtype; /* machine specifier */ uint32_t filetype; /* type of file */ uint32_t ncmds; /* number of load commands */ uint32_t sizeofcmds; /* the size of all the load commands */ uint32_t flags; /* flags */&#125;;/* Constant for the magic field of the mach_header (32-bit architectures) */#define MH_MAGIC 0xfeedface /* the mach magic number */#define MH_CIGAM 0xcefaedfe /* NXSwapInt(MH_MAGIC) *//* * The 64-bit mach header appears at the very beginning of object files for * 64-bit architectures. */struct mach_header_64 &#123; uint32_t magic; /* mach magic number identifier */ cpu_type_t cputype; /* cpu specifier */ cpu_subtype_t cpusubtype; /* machine specifier */ uint32_t filetype; /* type of file */ uint32_t ncmds; /* number of load commands */ uint32_t sizeofcmds; /* the size of all the load commands */ uint32_t flags; /* flags */ uint32_t reserved; /* reserved */&#125;;/* Constant for the magic field of the mach_header_64 (64-bit architectures) */#define MH_MAGIC_64 0xfeedfacf /* the 64-bit mach magic number */#define MH_CIGAM_64 0xcffaedfe /* NXSwapInt(MH_MAGIC_64) */ magic : 魔数从上面的宏定义可以看出 0xfeedface 代表的是 32 位，0xfeedfacf 代表 64 位cputype : cpu 的类型在 /usr/include/mach/machine.h 中可以看到相关的定义 /* * Machine types known by all. */ #define CPU_TYPE_ANY ((cpu_type_t) -1)#define CPU_TYPE_VAX ((cpu_type_t) 1)/* skip ((cpu_type_t) 2) *//* skip ((cpu_type_t) 3) *//* skip ((cpu_type_t) 4) *//* skip ((cpu_type_t) 5) */#define CPU_TYPE_MC680x0 ((cpu_type_t) 6)#define CPU_TYPE_X86 ((cpu_type_t) 7)#define CPU_TYPE_I386 CPU_TYPE_X86 /* compatibility */#define CPU_TYPE_X86_64 (CPU_TYPE_X86 | CPU_ARCH_ABI64)/* skip CPU_TYPE_MIPS ((cpu_type_t) 8) *//* skip ((cpu_type_t) 9) */#define CPU_TYPE_MC98000 ((cpu_type_t) 10)#define CPU_TYPE_HPPA ((cpu_type_t) 11)#define CPU_TYPE_ARM ((cpu_type_t) 12)#define CPU_TYPE_ARM64 (CPU_TYPE_ARM | CPU_ARCH_ABI64)#define CPU_TYPE_MC88000 ((cpu_type_t) 13)#define CPU_TYPE_SPARC ((cpu_type_t) 14)#define CPU_TYPE_I860 ((cpu_type_t) 15)/* skip CPU_TYPE_ALPHA ((cpu_type_t) 16) *//* skip ((cpu_type_t) 17) */#define CPU_TYPE_POWERPC ((cpu_type_t) 18)#define CPU_TYPE_POWERPC64 (CPU_TYPE_POWERPC | CPU_ARCH_ABI64) cupsubtype cpu 的子类型和 cputype 一样，也可以在 /usr/include/mach/machine.h 中可以看到相关的定义，其中有关于 PowerPC 的，Mips 的等等，这里列一下关于 ARM 的: ........./* * ARM subtypes */#define CPU_SUBTYPE_ARM_ALL ((cpu_subtype_t) 0)#define CPU_SUBTYPE_ARM_V4T ((cpu_subtype_t) 5)#define CPU_SUBTYPE_ARM_V6 ((cpu_subtype_t) 6)#define CPU_SUBTYPE_ARM_V5TEJ ((cpu_subtype_t) 7)#define CPU_SUBTYPE_ARM_XSCALE ((cpu_subtype_t) 8)#define CPU_SUBTYPE_ARM_V7 ((cpu_subtype_t) 9)#define CPU_SUBTYPE_ARM_V7F ((cpu_subtype_t) 10) /* Cortex A9 */#define CPU_SUBTYPE_ARM_V7S ((cpu_subtype_t) 11) /* Swift */#define CPU_SUBTYPE_ARM_V7K ((cpu_subtype_t) 12)#define CPU_SUBTYPE_ARM_V6M ((cpu_subtype_t) 14) /* Not meant to be run under xnu */#define CPU_SUBTYPE_ARM_V7M ((cpu_subtype_t) 15) /* Not meant to be run under xnu */#define CPU_SUBTYPE_ARM_V7EM ((cpu_subtype_t) 16) /* Not meant to be run under xnu */......... filetype 文件的类型相关定义在 /usr/include/mach-o/loader.h 中 #define MH_OBJECT 0x1 /* relocatable object file */#define MH_EXECUTE 0x2 /* demand paged executable file */#define MH_FVMLIB 0x3 /* fixed VM shared library file */#define MH_CORE 0x4 /* core file */#define MH_PRELOAD 0x5 /* preloaded executable file */#define MH_DYLIB 0x6 /* dynamically bound shared library */#define MH_DYLINKER 0x7 /* dynamic link editor */#define MH_BUNDLE 0x8 /* dynamically bound bundle file */#define MH_DYLIB_STUB 0x9 /* shared library stub for static */......... 常用的如下： MH_OBJECT 编译过程中产生的 *.obj 文件 MH_EXECUTABLE 可执行二进制文件 MH_DYLIB 动态库 ncmds 指的是加载命令 (load commands) 的数量sizeofcmds 表示 load commands 的总字节大小flags 一个包含一组位标志的整数，它显示了 Mach-O 文件格式的某些可选特性的状态。 加载命令这些加载命令在 Mach-O 文件加载解析时，被内核加载器或者动态链接器调用，指导如何设置加载对应的二进制数据段，加载命令的种类有很多种，在 /usr/include/mach-o/loader.h 头文件有简单的注释 struct load_command &#123; uint32_t cmd; /* type of load command */ uint32_t cmdsize; /* total size of command in bytes */&#125;;/* * After MacOS X 10.1 when a new load command is added that is required to be * understood by the dynamic linker for the image to execute properly the * LC_REQ_DYLD bit will be or'ed into the load command constant. If the dynamic * linker sees such a load command it it does not understand will issue a * \"unknown load command required for execution\" error and refuse to use the * image. Other load commands without this bit that are not understood will * simply be ignored. */#define LC_REQ_DYLD 0x80000000/* Constants for the cmd field of all load commands, the type */#define LC_SEGMENT 0x1 /* segment of this file to be mapped */#define LC_SYMTAB 0x2 /* link-edit stab symbol table info */#define LC_SYMSEG 0x3 /* link-edit gdb symbol table info (obsolete) */#define LC_THREAD 0x4 /* thread */#define LC_UNIXTHREAD 0x5 /* unix thread (includes a stack) */#define LC_LOADFVMLIB 0x6 /* load a specified fixed VM shared library */#define LC_IDFVMLIB 0x7 /* fixed VM shared library identification */#define LC_IDENT 0x8 /* object identification info (obsolete) */#define LC_FVMFILE 0x9 /* fixed VM file inclusion (internal use) */#define LC_PREPAGE 0xa /* prepage command (internal use) */#define LC_DYSYMTAB 0xb /* dynamic link-edit symbol table info */#define LC_LOAD_DYLIB 0xc /* load a dynamically linked shared library */......... LC_SYMTAB 符号表地址 LC_DYSYMTAB 动态符号表地址 LC_LOAD_DYLINKER 使用何种动态加载库 LC_UUID 文件的唯一标识 LC_VERSION_MIN_MACOSX 二进制文件要求的最低操作系统版本 LC_SOURCE_VERSION 构建该二进制文件使用的源代码版本 LC_MAIN 设置程序主线程的入口地址和栈大小 通过 otool -lv 来查看一下 WeChat $ otool -lv WeChat WeChat (architecture armv7):Mach header magic cputype cpusubtype caps filetype ncmds sizeofcmds flags MH_MAGIC ARM V7 0x00 EXECUTE 89 8292 NOUNDEFS DYLDLINK TWOLEVEL WEAK_DEFINES BINDS_TO_WEAK PIELoad command 0 cmd LC_SEGMENT cmdsize 56 segname __PAGEZERO vmaddr 0x00000000 vmsize 0x00004000 fileoff 0 filesize 0 maxprot --- initprot --- nsects 0 flags (none)Load command 1 cmd LC_SEGMENT cmdsize 736 segname __TEXT vmaddr 0x00004000 vmsize 0x034dc000 fileoff 0 filesize 55427072 maxprot r-x initprot r-x nsects 10 flags (none)Section sectname __text segname __TEXT addr 0x0000aff0 size 0x02d4bac4 offset 28656 align 2^4 (16) reloff 0 nreloc 0 type S_REGULARattributes PURE_INSTRUCTIONS SOME_INSTRUCTIONS reserved1 0 reserved2 0......... 其中每个 load command 的结构如下： struct segment_command &#123; /* for 32-bit architectures */ uint32_t cmd; /* LC_SEGMENT */ uint32_t cmdsize; /* includes sizeof section structs */ char segname[16]; /* segment name */ uint32_t vmaddr; /* memory address of this segment */ uint32_t vmsize; /* memory size of this segment */ uint32_t fileoff; /* file offset of this segment */ uint32_t filesize; /* amount to map from the file */ vm_prot_t maxprot; /* maximum VM protection */ vm_prot_t initprot; /* initial VM protection */ uint32_t nsects; /* number of sections in segment */ uint32_t flags; /* flags */&#125;;/* * The 64-bit segment load command indicates that a part of this file is to be * mapped into a 64-bit task's address space. If the 64-bit segment has * sections then section_64 structures directly follow the 64-bit segment * command and their size is reflected in cmdsize. */struct segment_command_64 &#123; /* for 64-bit architectures */ uint32_t cmd; /* LC_SEGMENT_64 */ uint32_t cmdsize; /* includes sizeof section_64 structs */ char segname[16]; /* segment name */ uint64_t vmaddr; /* memory address of this segment */ uint64_t vmsize; /* memory size of this segment */ uint64_t fileoff; /* file offset of this segment */ uint64_t filesize; /* amount to map from the file */ vm_prot_t maxprot; /* maximum VM protection */ vm_prot_t initprot; /* initial VM protection */ uint32_t nsects; /* number of sections in segment */ uint32_t flags; /* flags */&#125;; cmd 是 load command 的类型cmdsize 代表 load command 的大小segname 段名字vmaddr 段的虚拟内存起始地址vmsize 段的虚拟内存大小fileoff 段在文件中的偏移量filesize 段在文件中的大小maxprot 段页面所需要的最高内存保护initprot 段页面初始的内存保护nsects 段中包含 section 的数量flags 其他杂项标志位 Datasection 的机构如下： struct section &#123; /* for 32-bit architectures */ char sectname[16]; /* name of this section */ char segname[16]; /* segment this section goes in */ uint32_t addr; /* memory address of this section */ uint32_t size; /* size in bytes of this section */ uint32_t offset; /* file offset of this section */ uint32_t align; /* section alignment (power of 2) */ uint32_t reloff; /* file offset of relocation entries */ uint32_t nreloc; /* number of relocation entries */ uint32_t flags; /* flags (section type and attributes)*/ uint32_t reserved1; /* reserved (for offset or index) */ uint32_t reserved2; /* reserved (for count or sizeof) */&#125;;struct section_64 &#123; /* for 64-bit architectures */ char sectname[16]; /* name of this section */ char segname[16]; /* segment this section goes in */ uint64_t addr; /* memory address of this section */ uint64_t size; /* size in bytes of this section */ uint32_t offset; /* file offset of this section */ uint32_t align; /* section alignment (power of 2) */ uint32_t reloff; /* file offset of relocation entries */ uint32_t nreloc; /* number of relocation entries */ uint32_t flags; /* flags (section type and attributes)*/ uint32_t reserved1; /* reserved (for offset or index) */ uint32_t reserved2; /* reserved (for count or sizeof) */ uint32_t reserved3; /* reserved */&#125;; sectname section 名segname 该 section 所属的 segment 名addr 该 section 在内存的启始位置size 该 section 的大小offset 该 section 的文件偏移align 字节大小对齐reloff 重定位入口的文件偏移nreloc 需要重定位的入口数量flags 包含 section 的 type 和 attributes 可以通过 otool –s 查看某 segment 的某个 section： $ otool -s __TEXT __text WeChatWeChat (architecture armv7):Contents of (__TEXT,__text) section0000aff0 af03b5f0 8d04f84d f6444606 f2c070fe 0000b000 f644304d 447871fc 314df2c0 46904479 0000b010 68096800 680c6800 8000f846 b9955935 0000b020 70e8f644 304df2c0 68004478 58306800......... MachOView除了用 otool 查看 Mach-O 外，还可以通过 MachOView 可视化工具来查看MachOView下载地址：http://sourceforge.net/projects/machoview/MachOView源码地址：https://github.com/gdbinit/MachOView效果如下： 相关资料Mach-O-File-Format","categories":[],"tags":[]},{"title":"CSS学习之盒子模型","slug":"CSS学习之盒子模型","date":"2018-04-20T06:44:17.000Z","updated":"2018-07-04T09:16:03.002Z","comments":true,"path":"2018/04/20/CSS学习之盒子模型/","link":"","permalink":"https://github.com/caozhenwei/2018/04/20/CSS学习之盒子模型/","excerpt":"要设置 HTML 元素的样式，首先我们要选中 HTML 元素。常用的选中方式有 id 选择器和类选择器。 id 选择器以 # 来定义，类选择器以 . 来定义。","text":"要设置 HTML 元素的样式，首先我们要选中 HTML 元素。常用的选中方式有 id 选择器和类选择器。 id 选择器以 # 来定义，类选择器以 . 来定义。 CSS选择器CSS 的语法如下：例子如下： &lt;html&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /&gt;&lt;title&gt;选择器&lt;/title&gt;&lt;head&gt;&lt;style type=\"text/css\"&gt; #p &#123; background-color: yellow; &#125; .div1 &#123; background-color: red; width: 100px; height: 100px; &#125; .pos_abs2 &#123;&lt;/style&gt;&lt;/head&gt;&lt;body id=\"body\"&gt; &lt;div class=\"div1\"&gt; &lt;p&gt;div1&lt;/p&gt; &lt;/div&gt; &lt;p id=\"p\"&gt;这里要用id选择器来选中&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 这里我们用类选择器选中 div 标签并把它的背景设置为红色，宽高分别为 100px ，用 id 选择器选中 p 标签元算并把它的背景设置为黄色。效果如下： 盒子模型我们可以把 CSS 中的元素理解为一个盒子，整个页面就是一个盒子套一个盒子。盒子模型是有两种标准的，一个是标准模型，一个是 IE 模型。 这两种模型相似之处是从里到外都是 content ,padding ,border ,margin 。不同之处是标准模型的宽高只是内容（content）的宽高，而在 IE 模型中盒模型的宽高是内容(content)+填充(padding)+边框(border)的总宽高。 传统布局这里之所以说是传统布局是因为后面还要介绍 Flex 布局。传统布局主要是用 position、display、float 等属性来布局。下面会依次介绍这几个属性。 position 属性position 属性是指定一个元素的定位方法类型，分别是 static、fixed、relative、absolute。 static 定位是 HTML 元素的默认值，即没有定位，元素出现在正常的流中。 relative 是以自身在正常文档流的位置进行相应的偏移。 absolute 如果某个元素的 position 为 absolute ，那么这个元素就会按照其祖先元素中设置了 position 属性的元素来定位（从 padding 开始的地方），如果不存在这样设置了 position 的祖先元素，则会以 body 为定位对象。这个元素在文档流中溢出后，其文档流中的下一个元素将获得其位置。 fixed 是特殊的 absolute，即 fixed 总是以浏览器的可视窗口进行定位。 下面来看几个简单的例子。 &lt;html&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /&gt;&lt;title&gt;postion相关属性&lt;/title&gt;&lt;head&gt;&lt;style type=\"text/css\"&gt; #body &#123; background-color: #ccc; &#125; .pos_sta &#123; background-color: red; width: 100px; height: 100px; position: static; left: 200px; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body id=\"body\"&gt; &lt;div class=\"pos_sta\"&gt; &lt;p&gt;div1&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果如下 从上的例子中可以看出，static 这种定位不会受到 top ，bottom ,left ,right 的影响，这四个 CSS 属性样式用于定位对象盒子，必须定义 position 属性值为 absolute 或者 relative 此取值方可生效。一般 left 和 right 在一个样式是只能使用其一，不能 left 和 right 都设置。 定位为 relative 时 &lt;html&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /&gt;&lt;title&gt;postion相关属性&lt;/title&gt;&lt;head&gt;&lt;style type=\"text/css\"&gt; #body &#123; background-color: #ccc; &#125; .pos_relative1 &#123; background-color: red; width: 100px; height: 100px; &#125; .pos_relative2 &#123; background-color: green; width: 100px; height: 100px; position: relative; left: 150px; &#125; .pos_relative3 &#123; background-color: blue; width: 100px; height: 100px; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body id=\"body\"&gt; &lt;div class=\"pos_relative1\"&gt; &lt;p&gt;div1&lt;/p&gt; &lt;/div&gt; &lt;div class=\"pos_relative2\"&gt; &lt;p&gt;div2&lt;/p&gt; &lt;/div&gt; &lt;div class=\"pos_relative3\"&gt; &lt;p&gt;div3&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果如下 从上述代码可以看出，当对 div2 设置 position 为 relative 时，只是在它原来的基础上进行偏移，并没有影响下面的元素。 定位为 absolute 时, &lt;html&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /&gt;&lt;title&gt;postion相关属性&lt;/title&gt;&lt;head&gt;&lt;style type=\"text/css\"&gt; #body &#123; background-color: #ccc; &#125; .pos_abs1 &#123; background-color: red; width: 100px; height: 100px; &#125; .pos_abs2_parent &#123; background-color: Pink; width: 100px; height: 100px; position: absolute; left: 50px; top: 50px; &#125; .pos_abs2 &#123; background-color: green; width: 100px; height: 100px; position: absolute; left: 50px; top: 50px; &#125; .pos_abs3 &#123; background-color: blue; width: 100px; height: 100px; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body id=\"body\"&gt; &lt;div class=\"pos_abs1\"&gt; &lt;p&gt;div1&lt;/p&gt; &lt;/div&gt; &lt;div class=\"pos_abs2_parent\"&gt; &lt;div class=\"pos_abs2\"&gt; &lt;p&gt;div2&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"pos_abs3\"&gt; &lt;p&gt;div3&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果如下 从上述代码可以看出，当对 div2 设置 position 为 absolute 时,它就从正常的文档流中脱离出来了，如果 pos_abs2 有祖先元素设置了 position 属性，则以其设置了 position 属性的元素为祖先元素来定位。 定位为 fixed 时, &lt;html&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /&gt; &lt;title&gt;postion相关属性&lt;/title&gt; &lt;head&gt; &lt;style type=\"text/css\"&gt; #body { background-color: #ccc; } .pos_abs1 { background-color: red; width: 100px; height: 100px; } .pos_abs2_parent { background-color: Pink; width: 100px; height: 100px; position: absolute; left: 150px; top: 150px; } .pos_abs2 { background-color: green; width: 100px; height: 100px; position: fixed; left: 50px; top: 50px; } .pos_abs3 { background-color: blue; width: 100px; height: 100px; } &lt;/style&gt; &lt;/head&gt; &lt;body id=\"body\"&gt; &lt;div class=\"pos_abs1\"&gt; &lt;p&gt;div1&lt;/p&gt; &lt;/div&gt; &lt;div class=\"pos_abs2_parent\"&gt; &lt;div class=\"pos_abs2\"&gt; &lt;p&gt;div2&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"pos_abs3\"&gt; &lt;p&gt;div3&lt;/p&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 从上述代码可以看出，当对 div2 设置 position 为 fixed 时,总是以浏览器的可视窗口进行定位。 display 属性CSS 入门学习那篇里说过 CSS 将元素分为块级元素和行内元素，但是我们可以用 display 来规定元素应该生成的框的类型。其常用的值有 block、inline、inline-block、inherit、none 等。 block通过对一个行内元素设置 display:block;可以将行内元素设置为块级元素，进而设置它的宽高和上下左右的 padding 和 margin 。 inlinedisplay:inline 的作用即可以将一个块级元素转换成行内元素，那么这个块级元素将不能再设置宽和高以及上下方向的 margin 和 padding 。 inline-block设置了 inline-block 属性的元素既具有 block 元素可以设置 width 和 height 属性的特性，又保持了 inline 元素不换行的特性。 inheritinherit，表示子元素会继承父元素的 display 属性。 参考链接 w3school divcss5","categories":[],"tags":[]},{"title":"CSS入门学习","slug":"css-学习","date":"2018-04-11T08:38:20.000Z","updated":"2018-07-06T02:50:07.341Z","comments":true,"path":"2018/04/11/css-学习/","link":"","permalink":"https://github.com/caozhenwei/2018/04/11/css-学习/","excerpt":"CSS是什么CSS 指的是层叠样式表 (Cascading Style Sheets)，说白了就是来定义 HTML 元素的样式的。根据层叠样式表来理解下 CSS ，样式表好理解，就是有样式的“表”，那层叠指的是什么呢？层叠指的是一层一层叠加的效果，我们可以在多个地方来设置某个元素的样式，这个元素的最终显示结果是它们共同叠加的效果。叠加效果是有相关规则的，比如谁的优先级更高、谁会覆盖谁等，下面会有相关介绍。","text":"CSS是什么CSS 指的是层叠样式表 (Cascading Style Sheets)，说白了就是来定义 HTML 元素的样式的。根据层叠样式表来理解下 CSS ，样式表好理解，就是有样式的“表”，那层叠指的是什么呢？层叠指的是一层一层叠加的效果，我们可以在多个地方来设置某个元素的样式，这个元素的最终显示结果是它们共同叠加的效果。叠加效果是有相关规则的，比如谁的优先级更高、谁会覆盖谁等，下面会有相关介绍。 CSS 是用来写样式的，但是写几个元素放在浏览器里就有样式了，这是什么鬼？例子如下： &lt;html&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /&gt;&lt;head&gt;&lt;/head&gt;&lt;body id=\"body\"&gt; &lt;div&gt; &lt;H1&gt;aaa&lt;/H1&gt; &lt;H2&gt;bbb&lt;/H2&gt; &lt;p&gt;ccc&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 可以很明显的看到 aaa、bbb 被放大并且加粗了。这是因为浏览器有默认的样式，并且不同浏览器会有不同的样式。这就需要考虑不同浏览器的兼容问题了，这个问题先放在这里，下面有解决的办法。 CSS样式怎么来写怎么来写样式呢？主要有以下几种方法： 属性样式 内部样式 引用样式 属性样式属性样式，html 代码还是上个例子的代码，CSS 代码如下： &lt;H1 style='color: red'&gt;aaa&lt;/H1&gt;&lt;H2 style='color: green'&gt;bbb&lt;/H2&gt;&lt;p style='color: gray'&gt;ccc&lt;/p&gt; 效果如下： 内部样式内部样式&lt;style type=\"text/css\"&gt; H1 &#123; color: red; &#125; H2 &#123; color: green; &#125; p &#123; color: gray; &#125;&lt;/style&gt; 效果同上面的一样 引用样式引用样式default.html &lt;html&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /&gt;&lt;head&gt;&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"default.css\" /&gt; &lt;/head&gt;&lt;body id=\"body\"&gt; &lt;div&gt; &lt;H1&gt;aaa&lt;/H1&gt; &lt;H2&gt;bbb&lt;/H2&gt; &lt;p&gt;ccc&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; default.css H1 &#123; color: red;&#125;H2 &#123; color: green;&#125;p &#123; color: gray;&#125; 效果同上面的一样。 样式的优先级接着来说一下如果多个地方都设置了某一标签的样式该来怎么展示的问题。属性样式 &gt; 内部样式 &gt; 引用样式，层叠效果是各个设置效果的叠加，有相同的话是后面的覆盖前面的。举例：1.属性样式的优先级高于内部样式 例子中同时设置了 H1 标签的属性样式为 color:green、内部样式为 vred ，最终效果为 color:red。 &lt;html&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /&gt;&lt;head&gt;&lt;style type=\"text/css\"&gt; H1 &#123; color: red; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body id=\"body\"&gt; &lt;div&gt; &lt;H1 style='color:green'&gt;aaa&lt;/H1&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 2.样式的叠加，例子中设置了 p 标签的属性样式为 color:green、内部样式为 color:red;font-size: 50px;,最终效果为 color: green;font-size: 50px; 。 &lt;html&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /&gt;&lt;head&gt;&lt;style type=\"text/css\"&gt; p &#123; color: red; font-size: 50px; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body id=\"body\"&gt; &lt;div&gt; &lt;p style='color:green'&gt;ccc&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 浏览器的默认样式上文提到浏览器有默认的样式，其主要目地是为了让没有样式的页面显示起来不至于那么寒碜～～～。为了保持兼容性，一般会重置不同浏览器默认的样式，称为重置样式表。已经有很多别人写好的重置样式表，这里就不再造轮子，直接拿过来用。 CSS Reset strppd.css normalize.css CSS标准文档流文档流指的是元素排版布局过程中，元素会自动从左往右，从上往下的流式排列。CSS 中的元素分为两种：块级元素和行内元素。 块级元素霸占一行，不能与其它任何元素并列，能设置宽、高等属性，默认的宽度为父容器的宽度。 行内元素行内元素与其它元素并排，不能设置宽、高，默认的宽度就是文字的宽度。 HTML 中，标签分为两种：文本级和容器级，常见的文本级标签：p、span、a、等，常见的容器级标签：div、h、li等。容器级的标签，里面可以放置任何东西；文本级的标签里面，只能放置文字、图片、表单元素。 下面来看一下标准文档流中块级元素和行内元素展示样子。下面的例子中我们可以看到 div 独自占一行，而 sapn 是与其它元素并列展示。 HTML &lt;body id=\"body\"&gt; &lt;div&gt;1&lt;/div&gt; &lt;div&gt;2&lt;/div&gt; &lt;div&gt;3&lt;/div&gt; &lt;span&gt;aaa&lt;/span&gt; &lt;span&gt;bbb&lt;/span&gt; &lt;span&gt;ccc&lt;/span&gt; &lt;div&gt;4&lt;/div&gt; &lt;span&gt;ddd&lt;/span&gt;&lt;/body&gt; CSS #body &#123; background-color: #ccc; &#125;div &#123; background-color: green; width: 200px; height: 50px; margin-top: 10px;&#125;span &#123; background-color: red;&#125; 效果如下： 行内元素和块级元素是可以相互转换的，元素也可以脱离文档流，在后面的文章里会有介绍。 总结通过上面的学习我们知道了 CSS 是什么，并且知道了怎么在 HTML 中来写样式，了解了样式的优先级，明白了浏览器的默认样式和文档流。接下来会继续学习基于盒状模型并依赖 display 属性 + position 属性 + float 属性的传统布局。 参考链接 w3school","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://github.com/caozhenwei/tags/CSS/"}]},{"title":"常用 git 命令总结","slug":"常用-git-命令总结","date":"2018-03-19T12:17:59.000Z","updated":"2018-07-09T08:33:09.062Z","comments":true,"path":"2018/03/19/常用-git-命令总结/","link":"","permalink":"https://github.com/caozhenwei/2018/03/19/常用-git-命令总结/","excerpt":"前言git 是什么它是一个版本控制工具。 版本控制是一种记录一个或若干个文件内容变化，以便将来查阅特定版本修订情况的系统。 想想当年写毕业论文的情况，写了一个最终版，发现不行，在原来的基础上又修改下重新存为“最终版1”、“最终版2”、“打死也不改版1”、“打死也不改版2”…。如果自己知道有 git 这种强大的版本控制工具呢，肯定不会存好多版本，打开好多版本，来来回回的复制粘贴，简直蠢的要死。git 是在商业公司 BitKeeper 停止与 Linux 开源社区合作后，由 Linux 开源社区开发的版本控制工具。","text":"前言git 是什么它是一个版本控制工具。 版本控制是一种记录一个或若干个文件内容变化，以便将来查阅特定版本修订情况的系统。 想想当年写毕业论文的情况，写了一个最终版，发现不行，在原来的基础上又修改下重新存为“最终版1”、“最终版2”、“打死也不改版1”、“打死也不改版2”…。如果自己知道有 git 这种强大的版本控制工具呢，肯定不会存好多版本，打开好多版本，来来回回的复制粘贴，简直蠢的要死。git 是在商业公司 BitKeeper 停止与 Linux 开源社区合作后，由 Linux 开源社区开发的版本控制工具。 git 基础操作配置 git/etc/gitconfig 文件：系统中对所有用户都普遍适用的配置。若使用 git config 时用 --system 选项，读写的就是这个文件。 ~/.gitconfig 文件：用户目录下的配置文件只适用于该用户。若使用 git config 时用 --global 选项，读写的就是这个文件。 当前项目的 git 目录中的配置文件（也就是工作目录中的 .git/config 文件）：这里的配置仅仅针对当前项目有效。每一个级别的配置都会覆盖上层的相同配置，所以 .git/config 里的配置会覆盖 /etc/gitconfig 中的同名变量。 配置用户信息 $ git config --global user.name “你的名字\"$ git config --global user.email “你的邮箱” 检查配置信息 $ git config --list$ git config user.name //检查 git 的某一项配置，例如名字 gitignore 里配置需要忽略的文件。养成初始化就配置 gitignore 文件的习惯，要不每回 git status 的时候会看到一大堆没必要提交的文件，Xcode 里可以做如下配置： # Xcode## gitignore contributors: remember to update Global/Xcode.gitignore, Objective-C.gitignore &amp; Swift.gitignore## Build generatedbuild/DerivedData/## Various settings*.pbxuser!default.pbxuser*.mode1v3!default.mode1v3*.mode2v3!default.mode2v3*.perspectivev3!default.perspectivev3xcuserdata/## Other*.moved-aside*.xccheckout*.xcscmblueprint## Obj-C/Swift specific*.hmap*.ipa*.dSYM.zip*.dSYM# CocoaPods## We recommend against adding the Pods directory to your .gitignore. However# you should judge for yourself, the pros and cons are mentioned at:# https://guides.cocoapods.org/using/using-cocoapods.html#should-i-check-the-pods-directory-into-source-control## Pods/# Carthage## Add this line if you want to avoid checking in source code from Carthage dependencies.# Carthage/CheckoutsCarthage/Build# fastlane## It is recommended to not store the screenshots in the git repo. Instead, use fastlane to re-generate the# screenshots whenever they are needed.# For more information about the recommended setup visit:# https://docs.fastlane.tools/best-practices/source-control/#source-controlfastlane/report.xmlfastlane/Preview.htmlfastlane/screenshotsfastlane/test_output# Code Injection## After new code Injection tools there's a generated folder /iOSInjectionProject# https://github.com/johnno1962/injectionforxcodeiOSInjectionProject/ 更多的配置可以参考 这里。 获取 git 仓库在现有目录中初始化仓库$ git init 克隆现有的仓库$ git clone &lt;url&gt; 克隆一个带子模块的项目$ git clone &lt;url&gt;$ git submodule init$ git submodule update 基础命令用 git 管理文件后，对于任何一个文件，在 git 内都只有三种状态：已提交（committed），已修改（modified）和已暂存（staged）。 已提交:表示该文件已经被安全地保存在本地数据库中了； 已修改:表示修改了某个文件，但还没有提交保存； 已暂存:表示把已修改的文件放在下次提交时要保存的清单中。 文件流转的三个工作区域：git 的工作目录，暂存区域，以及本地仓库。从项目中取出某个版本的所有文件和目录，用以开始后续工作的叫做工作目录。这些文件实际上都是从 git 目录中的压缩对象数据库中提取出来的，接下来就可以在工作目录中对这些文件进行编辑。 所谓的暂存区域只不过是个简单的文件，一般都放在 git 目录中。有时候人们会把这个文件叫做索引文件，不过标准说法还是叫暂存区域。基本的 git 工作流程如下： 在工作目录中修改某些文件。 对修改后的文件进行快照，然后保存到暂存区域。 提交更新，将保存在暂存区域的文件快照永久转储到 Git 目录中。 $ git status //检查当前文件状态$ git add . //添加文件到暂存区$ git commit -m \"message\" //提交更新 其实 git add 的潜台词就是把目标文件快照放入暂存区域，也就是 add file into staged area，同时未曾跟踪过的文件标记为需要跟踪。这样就好理解后续 add 操作的实际意义了。它是一个多功能命令，可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等。 移除文件 $ git rm 文件 删除文件但是让文件留在磁盘上 $ git rm --cached README 查看提交历史 $ git log 用 oneline 将每个提交放在一行显示 $ git log --pretty=oneline 用 ASCII 字符串表示的简单图形，形象地展示了每个提交所在的分支及其分化衍合情况 git log --pretty=format:\"%h %s\" --graph format 常用的格式占位符写法及其代表的意义 选项 说明 %H 提交对象（commit）的完整哈希字串 %h 提交对象的简短哈希字串 %T 树对象（tree）的完整哈希字串 %t 树对象的简短哈希字串 %P 父对象（parent）的完整哈希字串 %p 父对象的简短哈希字串 %an 作者（author）的名字 %ae 作者的电子邮件地址 %ad 作者修订日期（可以用 -date= 选项定制格式） %ar 作者修订日期，按多久以前的方式显示 %cn 提交者(committer)的名字 %ce 提交者的电子邮件地址 %cd 提交日期 %cr 提交日期，按多久以前的方式显示 %s 提交说明 例如，列出所有最近两周内的提交：$ git log --since=2.weeks git log 支持的选项 选项 说明 -p 按补丁格式显示每个更新之间的差异 –stat 显示每次更新的文件修改统计信息 –shortstat 只显示 –stat 中最后的行数修改添加移除统计 –name-only 仅在提交信息后显示已修改的文件清单 –name-status 显示新增、修改、删除的文件清单 –abbrev-commit 仅显示 SHA-1 的前几个字符，而非所有的 40 个字符 –relative-date 使用较短的相对时间显示（比如，“2 weeks ago”） –graph 显示 ASCII 图形表示的分支合并历史 –pretty 使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format（后跟指定格式）。 撤消对文件的修改$ git checkout -- [file] 撤消对所有文件的修改$ git checkout -- . 或者 $ git checkout . 显示还没有暂存起来的改动，不是这次工作和上次提交之间的差异$ git diff 已经暂存起来的文件和上次提交时的快照之间的差异$ git diff --cached //git 1.6.1 及更高版本还允许使用 git diff --staged，效果是相同的 git 别名$ git config --global alias.st status 这意味着，当要输入 git status 时，只需要输入 git st。查看别名的位置可以使用上面提到的 git config -—list 命令。如果想要执行外部命令，可以在命令前面加入 ! 符号，操作如下：git config --global alias.ls '!ls' git 分支分支基础分支是 git 最大的亮点，也是它的杀手锏。git 的分支分为远程分支，远程跟踪分支和跟踪分支。 远程分支就是在远程仓库上的普通分支。 远程跟踪分支是在本地的只读的记录远程分支状态的分支，其指向用户无法移动，当你做任何网络通信操作时，它们会自动移动。 跟踪分支是从远程跟踪分支上生成的本地分支。 分支常用命令查看分支 $ git branch 分支创建 $ git branch 分支名 分支切换 $ git checkout 分支名 查看每一个分支的最后一次提交 $ git branch -v 查看哪些分支已经合并到当前分支 $ git branch —merged 查看所有包含未合并工作的分支$ git branch --no-merged 分支合并，如把 test 分支合并到 master 分支 $ git checkout master$ git merge test 查看分支历史 $ git log --oneline --graph 新建一个分支并同时切换到该分支上 $ git checkout -b 分支名 删除分支 $ git branch -d 分支名 查看当前配置有哪些远程仓库 $ git remote 显示对应的克隆地址 $ git remote -v 添加远程仓库 $ git remote add [shortname] [url] 推送数据到远程仓库 $ git push origin master 远程仓库的重命名 $ git remote rename a b 远程仓库的删除 $ git remote rm xxx 查看远端仓库的详细信息 $ git remote show origin 某个远程仓库在本地的简短名称，比如想把 pb 改成 paul $ git remote rename pb paul git tag打标签是我们经常用到的命令，通常是在发布新版本或者切换到以前的特定版本修改 bug 的时候用。git 使用两种主要类型的标签：轻量标签（lightweight）与附注标签（annotated）。轻量标签很像一个不会改变的分支，它只是一个特定提交的引用。附注标签是存储在 git 数据库中的一个完整对象。创建附注标签 $ git tag -a v1.4 -m 'my version 1.4’ 创建轻量标签 $ git tag v1.4-lw 后期打标签 $ git tag -a v1.2 9fceb02 （需要在命令的末尾指定提交的校验和或部分校验和） 列出标签 $ git tag 把标签推送到远程仓库服务器上 $ git push origin [tagname] 检出标签（也就是在特定的标签上创建一个新分支） $ git checkout -b version2 v2.0.0 参考链接https://git-scm.com/book/zh/v2","categories":[],"tags":[{"name":"开发","slug":"开发","permalink":"https://github.com/caozhenwei/tags/开发/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-03-19T00:57:22.000Z","updated":"2018-07-04T09:16:29.461Z","comments":true,"path":"2018/03/19/hello-world/","link":"","permalink":"https://github.com/caozhenwei/2018/03/19/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment /frac{7x+5}","categories":[],"tags":[{"name":"开发","slug":"开发","permalink":"https://github.com/caozhenwei/tags/开发/"}]},{"title":"春天里的故事","slug":"春天里的故事","date":"2018-03-19T00:57:22.000Z","updated":"2018-07-04T09:17:43.837Z","comments":true,"path":"2018/03/19/春天里的故事/","link":"","permalink":"https://github.com/caozhenwei/2018/03/19/春天里的故事/","excerpt":"春天的颜色真是五彩缤纷，太阳是红灿灿的，天空是湛蓝的，树梢是嫩绿的，迎春花是娇黄的……难怪诗人爱吟咏春天，画家爱描绘春天，因为春天是世界一切美的融合，一切色彩的总会。","text":"春天的颜色真是五彩缤纷，太阳是红灿灿的，天空是湛蓝的，树梢是嫩绿的，迎春花是娇黄的……难怪诗人爱吟咏春天，画家爱描绘春天，因为春天是世界一切美的融合，一切色彩的总会。 我的小情人喔！ 调皮的小宝宝 我也来逛逛吧 春天的水，平平的，静静的。春天的水，没有风的时候就像一面平滑的玻璃镜子一样。有风时，春天的水，在阳光的照耀下，泛起水波，闪闪发光，就像春姑娘佩戴的闪亮亮的头饰一样。春天的水，流过庄稼、田地，悄悄地给足充分的营养。春天的水活了，便孕育了一批批新的生命——鱼儿欢快地在水中游来游去。 可和宝妈 我现在最爱的玩具就它了！ 我很奇怪，这五彩缤纷的色彩为什么会不约而同地选择春天来到大地?每个人都有春天。无论是你，或者是我，每个人在春天里都可以有欢笑，有爱情，有陶醉。 小狗狗回头","categories":[],"tags":[{"name":"生活","slug":"生活","permalink":"https://github.com/caozhenwei/tags/生活/"}]},{"title":"使用 hexo 搭建 blog","slug":"使用-hexo-搭建-blog","date":"2018-03-17T06:13:28.000Z","updated":"2018-07-04T09:20:39.696Z","comments":true,"path":"2018/03/17/使用-hexo-搭建-blog/","link":"","permalink":"https://github.com/caozhenwei/2018/03/17/使用-hexo-搭建-blog/","excerpt":"背景上篇文章刚介绍用了 Octopress 搭建 blog，这边又用 hexo 来搭建 blog，到底是几个意思？你过来，我保证不打死你！问起原因，只能说 Octopress 构建的时候有些慢并且我不喜欢它的主题（虽然它的主题很多，不喜欢就不喜欢呗，还找这么多理由干什么）。下面开始介绍怎么用 hexo 搭建 blog。","text":"背景上篇文章刚介绍用了 Octopress 搭建 blog，这边又用 hexo 来搭建 blog，到底是几个意思？你过来，我保证不打死你！问起原因，只能说 Octopress 构建的时候有些慢并且我不喜欢它的主题（虽然它的主题很多，不喜欢就不喜欢呗，还找这么多理由干什么）。下面开始介绍怎么用 hexo 搭建 blog。 本机相关环境macOS High Sierra 10.13.3 node v8.10.0 npm 5.6.0 git version 2.14.3 (Apple Git-98) 安装 Hexo什么是 Hexo？Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 需要的环境Node.js 和 Git 安装 Hexo$ npm install -g hexo-cli 初始化 $ hexo init &lt;folder&gt; 进入初始化的文件夹 $ cd &lt;folder&gt; 安装相关模块 $ npm install 在 _config.yml 中配置相关的信息 写文章$ hexo new [layout] &lt;title&gt;$ hexo generate$ hexo server 2018.6.15添加可以用草稿的方式暂时不发布那些还没有写完的文章，具体的操作是指定 layout 为 draft，这种布局在建立时会被保存到 source/_drafts 文件夹，可通过 publish 命令将草稿移动到 source/_posts 文件夹，该命令的使用方式与 new 十分类似，您也可在命令中指定 layout 来指定布局。如果你希望强行预览草稿，更改配置文件render_drafts: true 或者用如下方式启动 server ：hexo server --drafts 。 然后就能在 http://localhost:4000 看到效果了 部署到 github 上创建相关的仓库到 github 上创建一个 username.github.io 的 rep $ hexo-deployer-git.$ npm install hexo-deployer-git --save$ hexo deploy 美化主题1.clonegit clone https://github.com/Haojen/hexo-theme-Anisina.git themes/Anisina 2.配置修改 _config.yml 中的 themes 为 Anisina 即可。 评论注册来必力，在 _config.yml 中增加相应的 id 。 图片地址在配置中经常要用到某一张图片的 url ，这是我们可以把图片传到 github 的仓库中，然后在仓库中查看图像即可获得相应的图片的 url 。 社交平台的配置github 只需要用户名就行。微博的可以在设置中配置个性域名，然后把个性域名配置到 _config.yml 中。 番外Node.js 是什么？ Node.js 就是运行在服务端的 JavaScript。Node.js 是一个基于 Chrome JavaScript 运行时建立的一个平台。Node.js 是一个事件驱动 I/O 服务端JavaScript 环境，基于 Google 的 V8 引擎，V8 引擎执行 Javascript 的速度非常快，性能非常好。 用 Homebrew 装 Node.js 安装 Homebrew/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" 安装 Node.jsbrew install node 参考链接hexo 官网、来必力评论模块、Anisina 主题","categories":[],"tags":[]},{"title":"用 Octopress 搭建属于自己的 github 博客 ","slug":"用-Octopress-搭建属于自己的-github-博客","date":"2018-03-16T08:02:58.000Z","updated":"2018-06-15T07:17:18.334Z","comments":true,"path":"2018/03/16/用-Octopress-搭建属于自己的-github-博客/","link":"","permalink":"https://github.com/caozhenwei/2018/03/16/用-Octopress-搭建属于自己的-github-博客/","excerpt":"本文章介绍了自己用 Octopress 搭建 blog 的过程，其中查了好多资料，看了好多文章，也走了不少弯路。现在记录下来，方便后人学习，自己也做个备忘。废话不多说，开工！","text":"本文章介绍了自己用 Octopress 搭建 blog 的过程，其中查了好多资料，看了好多文章，也走了不少弯路。现在记录下来，方便后人学习，自己也做个备忘。废话不多说，开工！ 搭建 blog 时的本机环境macOS High Sierra (10.13.3) ruby 2.3.1p112 gem 2.5.1 bundle 1.16.1 git version 2.14.3 (Apple Git-98) 安装 Octopress什么是 Octopress ？ Octopress 是一个基于 Ruby 的开源 Blogging Framework，从写 blog，到发布，你完全可以用 Shell 里面的命令搞定。这样，写起 Blog 来，会让技术控们觉得很有成就感。。。 安装 Octopress $ git clone git://github.com/imathis/octopress.git octopress$ cd octopress 因为墙的原因，所以要修改 gem 的 source $ gem sources --add https://ruby.taobao.org/ --remove https://rubygems.org/$ gem sources -l 请确保只有 ruby.taobao.org 安装依赖 $ gem install bundler$ bundle install 安装默认的 Octopress 主题$ rake install 在 github 上创建仓库到 github 上创建仓库到 github 上创建一个 username.github.io 的 repo，比如我的github 名字为 caozhenwei ，我就创建了一个名字为 caozhenwei.github.io 的仓库。 完成 github 和 Octopress 的关联执行下面的命令并依照提示完成 github 和 Octopress 的关联 $ rake setup_github_pages(For example, 'git@github.com:your_username/your_username.github.io.git) or 'https://github.com/your_username/your_username.github.io')//比如我的我就输入如下： git@github.com: caozhenwei/caozhenwei.github.io.git 创建配置生成博客 $ rake generate$ rake deploy 生成后 push 到 github 上，在这之前需要配置下 SSH Key。在终端下输入 $ ssh-keygen -t rsa -C \"邮箱地址\" 按三次回车即可，成功后就可以在用户目录下找到 .ssh 目录，里面有 id_rsa 和 id_rsa.pub 两个文件，把 id_rsa.pub 放到 github 的 SSH keys 即可。 git 用户账户信息的配置： $ git config --global user.name \"你的github用户名\"$ git config --global user.email \"你的github邮箱地址\" 然后再提交： $ git add .$ git commit -m 'create blog'$ git push origin source 完成后等待几秒就能访问 http://username.github.io 看到自己的博客了。 当然，你也可以在 push 到 github 上之前先在本地预览一下，命令如下$ rake preview 你可以在本地的浏览器里打开 localhost:4000 来预览生成的 blog 。 安装第三方主题如果你喜欢上面的默认的主题，这里的步骤就没必要执行了。我比较 abacus 主题，下面是安装步骤：$ cd octopress$ git clone https://github.com/bhrigu123/abacus.themes/abacus$ rake install['abacus']$ rake generate 到这一步，你的 blog 已经基本搭建完了，终于能写了。blog 是用 Markdown 语言来写的。Markdown 是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。在 mac 下可以使用 MacDown 软件来写。想下载 MacDown 点我。需要更多的主题点我。 开始写 blog：$ rake new_post['title'] ＃title 是你要写的 blog 的标题 执行完上面的命令后会在 source/_posts 下面生成 xxx.markdown 文件，我们的 blog 就在 xxx.markdown 中编写。编写完后执行： $ rake generate$ rake preview //在浏览器输入： localhost:4000 在本地先预览效果，满意后在 push 到 github 上。$ git add .$ git commit -m \"comment\" $ git push origin source$ rake deploy 折腾后的收获在执行 gem install bundler的时候，一会儿切换源，一会说 ruby 版本不对。看来是对 gem 不熟悉。那什么是RubyGems？RubyGems 是一个方便而强大的 Ruby 程序包管理器，Ruby 的第三方插件是用 gem 方式来管理，非常容易发布和共享，一个简单的命令就可以安装上第三方的扩展库。特点：能远程安装包，包之间依赖关系的管理，简单可靠的卸载，查询机制，能查询本地和远程服务器的包信息，能保持一个包的不同版本，基于 Web 的查看接口，能查看你安装的 gem 的信息。Ruby1.9.1 以后的版本自带 RubyGems。要切换 ruby 版本用什么好呢？笔者刚开始用了 rvm, 后来又用了 rbenv。安装的时候又用到了 homebrew。本着 生命不息，折腾不止的精神，重新的学习了以上各命令的用法。常用方法如下： rvm 常用命令 rvm remove ruby-1.8.7 --docs —gems ＃删除某个版本的ruby，并且把文档和gems都删除rvm use ruby-1.8.7 --default ＃选择版本rvm info ＃查询当前版本rvm list ＃列出版本rvm implode ＃删除rvm命令 rbenv 常用命令 rbenv install --list ＃列出所有可以安装的Ruby版本rbenv install version ＃version是具体要安装的版本，在上面列出的可以安装的目录中选择一个rbenv versions ＃查看本地安装的ruby版本rbenv global version #设置全局使用的ruby版本rbenv shell version ＃设置在当前shell中使用的ruby版本，生成了一个RBENV_VERSION的变量rbenv local version ＃设置在当前目录中的ruby版本，会在当前目录下生成.rbenv-version文件。rbenv uninstall 2.00 #卸载指定ruby版本rbenv rehash #每当安装新的 Ruby 版本，或 gem 都要运行一下，不然有可能会出现新安装的不起作用的现象 Homebrew 常用命令 brew uninstall rbenv ＃卸载rbenvbrew list ＃列出已安装的软件brew update ＃更新brewbrew home ＃用浏览器打开 brew 的官方网站brew info ＃显示软件信息brew deps ＃ 显示包依赖 参考链接Octopress 的配置、Octopress 主题、RubyGems 镜像、homebrew、homebrew 官网、rbenv、rvm","categories":[],"tags":[{"name":"开发","slug":"开发","permalink":"https://github.com/caozhenwei/tags/开发/"}]},{"title":"mac下常用命令和快捷键","slug":"mac下常用命令","date":"2018-02-19T06:24:47.000Z","updated":"2018-07-04T09:17:13.973Z","comments":true,"path":"2018/02/19/mac下常用命令/","link":"","permalink":"https://github.com/caozhenwei/2018/02/19/mac下常用命令/","excerpt":"前言使用命令行或者使用快捷键会大大的提高工作效率，本问会总结一些经常用到的快捷键和命令。统统列出来肯定是列不全的，只能边用边总结，文章持续更新中。。。","text":"前言使用命令行或者使用快捷键会大大的提高工作效率，本问会总结一些经常用到的快捷键和命令。统统列出来肯定是列不全的，只能边用边总结，文章持续更新中。。。 mac下常用快捷键打开实用工具cmd + shift + U 去往任意路径的文件夹cmd + shift + U 强制退出cmd + option + esc mac终端下常用命令查看系统支持的 shell 列表cat /etc/shells 删除所有系统日志sudo rm -rf /private/var/log/* 获得一个文件的 md5 值openssl md5 /Users/caozhenwei/Desktop/12345/html.dek 查看内核版本uname -a mac 下添加类似于 linux 的 tree 命令 find . -print | sed -e &#39;s;[^/]*/;|____;g;s;____|; |;g&#39;在 .bash_profile 中加入上面面这条，就能在 mac 下使用 tree 命令了 Home-brew 安装 （官网 http://brew.sh/index_zh-cn.html）/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 安装 node（ 官网 https://nodejs.org/en/）brew install node 重新启动 Mac 的命令sudo shutdown -r now 获取 ip 地址ipconfig getifaddr en0 修改主机名称sudo scutil --set HostName MacBookPro 修改共享名称sudo scutil --set ComputerName MacBookPro 解压 rar 文件brew install unrarunrar x 文件名.rar 查看文件占用的磁盘空间du -sh ~/.cocoapods profile 文件的路径~/Library/MobileDevice/Provisioning\\ Profiles/","categories":[],"tags":[]},{"title":" Markdown基本语法","slug":"Markdown基本语法","date":"2018-01-25T09:27:31.000Z","updated":"2018-07-25T12:24:19.763Z","comments":true,"path":"2018/01/25/Markdown基本语法/","link":"","permalink":"https://github.com/caozhenwei/2018/01/25/Markdown基本语法/","excerpt":"插入数学公式 &lt;script type=&quot;text/javascript&quot; src=&quot;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default&quot;&gt;&lt;/script&gt; $$x=\\frac{-b\\pm\\sqrt{b^2-4ac}}{2a}$$","text":"插入数学公式 &lt;script type=&quot;text/javascript&quot; src=&quot;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default&quot;&gt;&lt;/script&gt; $$x=\\frac{-b\\pm\\sqrt{b^2-4ac}}{2a}$$ $$x=\\frac{-b\\pm\\sqrt{b^2-4ac}}{2a}$$ 代码高亮 ```bash 代码 ``` 表格 选项 说明 -p 按补丁格式显示每个更新之间的差异 –stat 显示每次更新的文件修改统计信息 –shortstat 只显示 –stat 中最后的行数修改添加移除统计 加粗字体 将需要设置为斜体的文字两端使用2个“*”或者“_”夹起来 我是被加粗的哦","categories":[],"tags":[]},{"title":"iOS 中 native 和 JavaScript 的交互原理","slug":"iOS-中-native-和-JavaScript-的交互原理","date":"2017-12-02T06:17:45.000Z","updated":"2018-06-29T07:25:34.503Z","comments":true,"path":"2017/12/02/iOS-中-native-和-JavaScript-的交互原理/","link":"","permalink":"https://github.com/caozhenwei/2017/12/02/iOS-中-native-和-JavaScript-的交互原理/","excerpt":"前言在 iOS 开发中经常要用到 UIWebView ( iOS8 中可以用 WKWebView，本文章以 UIWebView 为例 ) 来展示一些东西，其中就难免要和网页进行交互。服务端提供 H5 供多个平台使用，我们就不用在 native 中开发了，是不是很棒。Hybrid App 的优势很明显，这就要求我们必须具备 native 和网页交互的技能。学点儿 JavaScript 的知识能帮我们更好的理解交互的原理。本文主要来介绍 UIWebView 和 JavaScript 的交互原理以及 WebViewJavascriptBridge (github 地址) 源码分析。","text":"前言在 iOS 开发中经常要用到 UIWebView ( iOS8 中可以用 WKWebView，本文章以 UIWebView 为例 ) 来展示一些东西，其中就难免要和网页进行交互。服务端提供 H5 供多个平台使用，我们就不用在 native 中开发了，是不是很棒。Hybrid App 的优势很明显，这就要求我们必须具备 native 和网页交互的技能。学点儿 JavaScript 的知识能帮我们更好的理解交互的原理。本文主要来介绍 UIWebView 和 JavaScript 的交互原理以及 WebViewJavascriptBridge (github 地址) 源码分析。 UIWebView 和 JavaScript 的交互原理理解这个原理之前必须先明确以下两点： 1.JavaScript 能直接调用 native 方法吗？不可以。 2.native 能直接调用 JavaScript 代码吗？可以，可以通过以下方式来调用：[webView stringByEvaluatingJavaScriptFromString:javascriptCommand]; JavaScript 不能直接调用 native 的方法，但是可以间接的通过一些方法来实现。可以利用 UIWebView 的 webView: shouldStartLoadWithRequest: navigationType: 代理方法来做。 WKWebView 中可以通过 webView: decidePolicyForNavigationAction: decisionHandler: 代理方法来做（本文以 UIWebView 为例，WKWebView 与 JavaScript 交互的原理同 UIWebView 一样，后面不会赘述。以下用 webView 来代指 UIWebView 和 WKWebView ）。webView 发起的网络请求都会走上面的代理方法，那么就可以在代理里拦截，如果返回的是我们自己定义的 URL ，就不在加载网页，而是来处理一些我们想让它做的事情，从而实现 native 和 JavaScript 的交互。 WebViewJavascriptBridge 源码分析WebViewJavascriptBridge 是封装好的 native 和 JavaScript 交互的组件。下面主要是对它源码的一些分析，以及一些简单的 JavaScript 知识（对只会 Objective-C 程序猿理解 WebViewJavascriptBridge 很有帮助哦）。上面分析的原理是利用 webView 的代理来拦截 URL 从而实现交互。那么 webView 的代理方法 webView: shouldStartLoadWithRequest: navigationType 什么时候会被调用呢？给出的回答是这样的： Sent before a web view begins loading a frame 。如果代理方法只调用一次的话，没办法对其中的 URL 拦截判断（这里指的是我们自定义的 URL），所以就必须想办法在 H5 里做处理来触发 webView 的代理事件。有很多办法能解决这个问题，比如以下两种： 创建 iframe 标签，WebViewJavascriptBridge 中就是用的这种方法。 设置 window 的 location，例如 window.location = “/www/phpStudy/JS/helloJS.html”; 本文以尽可能按照代码的执行顺序来分析 WebViewJavascriptBridge 源代码。那现在正式开始，native 创建好 webView 后，来 load ExampleApp.html。先来看看 ExampleApp.html，其中主要的是 script 标签里面的代码，代码如下： &lt;script&gt; window.onerror = function(err) &#123; log('window.onerror: ' + err) &#125; function setupWebViewJavascriptBridge(callback) &#123; if (window.WebViewJavascriptBridge) &#123; //alert(\"0\"); return callback(WebViewJavascriptBridge); &#125; if (window.WVJBCallbacks) &#123; //alert(\"1\"); return window.WVJBCallbacks.push(callback); &#125; window.WVJBCallbacks = [callback]; var WVJBIframe = document.createElement('iframe'); WVJBIframe.style.display = 'none'; WVJBIframe.src = 'wvjbscheme://__BRIDGE_LOADED__'; document.documentElement.appendChild(WVJBIframe); setTimeout(function()&#123; document.documentElement.removeChild(WVJBIframe) &#125;, 0) &#125; setupWebViewJavascriptBridge(function(bridge) &#123; var uniqueId = 1 function log(message, data) &#123; var log = document.getElementById('log') var el = document.createElement('div') el.className = 'logLine' el.innerHTML = uniqueId++ + '. ' + message + ':&lt;br/&gt;' + JSON.stringify(data) if (log.children.length) &#123; log.insertBefore(el, log.children[0]) &#125; else &#123; log.appendChild(el) &#125; &#125; //alert(\"在exampleApp setupWebViewJavascriptBridge 中\"); bridge.registerHandler('testJavascriptHandler', function(data, responseCallback) &#123; log('ObjC called testJavascriptHandler with', data) var responseData = &#123; 'oc调用js后，js给oc的回调':'hello' &#125; log('JS responding with', responseData) responseCallback(responseData) &#125;) document.body.appendChild(document.createElement('br')) var callbackButton = document.getElementById('buttons').appendChild(document.createElement('button')) callbackButton.innerHTML = '测试 JS 调用 OC 函数' callbackButton.onclick = function(e) &#123; e.preventDefault() log('JS calling handler \"testObjcCallback\"') bridge.callHandler('testObjcCallback', &#123;'foo': 'bar'&#125;, function(response) &#123; log('JS 得到的回应数据：', response) &#125;) &#125; &#125;)&lt;/script&gt; 对 Objective-C 程序猿来说猛的一眼看不懂这是什么，其实就是一个简单的 JavaScript 函数调用，只不过是把另一个函数当做参数传给了 setupWebViewJavascriptBridge 函数。简化后如下： function setupWebViewJavascriptBridge(callback) {} setupWebViewJavascriptBridge(function(bridge) {}) 上面的 setupWebViewJavascriptBridge 函数中对 window.WebViewJavascriptBridge 和 window.WVJBCallbacks 做判断，第一次请求 H5 这两个属性都为空，根本就不回执行 if 里面的语句，可以像上面代码中注释的那样，用 alert 来证实。callback 被加到了 WVJBCallbacks 数组里，这里先记住，后面会用，这里提个醒留个印象。接着函数中还创建了一个隐藏的 iframe 标签，并设置它的 src 属性为 wvjbscheme://__BRIDGE_LOADED__。这样我们才能在 webView 的代理方法中对 URL 做判断，并做进一步的处理。 来看一下 wevView 的代理方法： - (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType &#123; if (webView != _webView) &#123; return YES; &#125; NSURL *url = [request URL]; __strong WVJB_WEBVIEW_DELEGATE_TYPE* strongDelegate = _webViewDelegate; if ([_base isCorrectProcotocolScheme:url]) &#123; if ([_base isBridgeLoadedURL:url]) &#123; //拦截到 wvjbscheme://__BRIDGE_LOADED__ [_base injectJavascriptFile]; &#125; else if ([_base isQueueMessageURL:url]) &#123; //拦截到 wvjbscheme://__WVJB_QUEUE_MESSAGE__ NSString *messageQueueString = [self _evaluateJavascript:[_base webViewJavascriptFetchQueyCommand]]; [_base flushMessageQueue:messageQueueString]; &#125; else &#123; [_base logUnkownMessage:url]; &#125; return NO; &#125; else if (strongDelegate &amp;&amp; [strongDelegate respondsToSelector:@selector(webView:shouldStartLoadWithRequest:navigationType:)]) &#123; return [strongDelegate webView:webView shouldStartLoadWithRequest:request navigationType:navigationType]; &#125; else &#123; return YES; &#125;&#125; 在这里面拦截到是我们定义的 wvjbscheme 后就调用相应的逻辑处理，否则的话就不处理。在这里拦截到 wvjbscheme://__BRIDGE_LOADED__，执行了 WebViewJavascriptBridge_js 里的 JavaScript 代码。来看看 WebViewJavascriptBridge_js 里的代码都干了点儿什么，先挑出现在能用上的，具体的用的时候再说。看看下面的代码片段： messagingIframe = document.createElement('iframe');messagingIframe.style.display = 'none';messagingIframe.src = CUSTOM_PROTOCOL_SCHEME + '://' + QUEUE_HAS_MESSAGE;document.documentElement.appendChild(messagingIframe); setTimeout(_callWVJBCallbacks, 0);function _callWVJBCallbacks() &#123; var callbacks = window.WVJBCallbacks; delete window.WVJBCallbacks; for (var i=0; i&lt;callbacks.length; i++) &#123; callbacks[i](WebViewJavascriptBridge); &#125;&#125; 一眼就能看到其中又创建了个 iframe 标签，把 src 设置成了 wvjbscheme://__WVJB_QUEUE_MESSAGE__，这样的话就能在 webView 的代理方法中拦截了。来说一下 setTimeout 的作用：setTimeout() 方法用于在指定的毫秒数后调用函数或计算表达式（setTimeout 函数介绍）。接着调用了 _callWVJBCallbacks 函数，在这个函数里面取出了上面让暂时记住的 window.WVJBCallbacks (在 ExampleApp.html 里把 callback 放入进 WVJBCallbacks 里)，取出里面所有的方法（其实现在就一个 callback 方法）并且执行。让我们来跳到 ExampleApp.html 里面，看看 callback （就是setupWebViewJavascriptBridge 调用处传进来的匿名函数）里都做了什么。log 方法用来打印信息。接着调用了 bridge 的 registerHandler 方法（这个主要是供 native 端来调用的）。创建了一个 callbackButton 并绑定它的 onclick 事件。先来看看 registerHandler 方法都干了什么，跳到 WebViewJavascriptBridge_JS.m 里找到的 registerHandler 如下： function registerHandler(handlerName, handler) &#123; messageHandlers[handlerName] = handler;&#125; 这里是把 registerHandler 里传过来的参数放到了 messageHandlers 数组里，以后 native 调用 JavaScript 方法的时候就会来这里取。 Objective-C 程序猿的加油站：JavaScript 拥有动态类型 我们申明 messageHandlers 时是这样申明的 var messageHandlers = {}; 可是在用的时候就把它当数组用了，对 Objective-C 程序猿来说是很奇怪的。其实JavaScript 拥有动态类型。这意味着相同的变量可用作不同的类型。 native 调用 JavaScript 方法native 调用 JavaScript 方法是这样的： [_bridge callHandler:@\"testJavascriptHandler\" data:data responseCallback:^(id response) &#123; NSLog(@\"testJavascriptHandler responded: %@\", response);&#125;] 通过上面的函数，一路跟下去，发现是把调用的 JavaScript 的方法名，参数和回调拼装好后在本地执行了 _handleMessageFromObjC 方法，其中 _handleMessageFromObjC 的参数是上面拼装好的字典。来看看 _handleMessageFromObjC 里做了什么。 function _handleMessageFromObjC(messageJSON) &#123; _dispatchMessageFromObjC(messageJSON);&#125; function _dispatchMessageFromObjC(messageJSON) &#123; //messageJSON 里面包含 data callbackId handlerName setTimeout(function _timeoutDispatchMessageFromObjC() &#123; //使用 JSON.parse 将 JSON 字符串转换为对象 var message = JSON.parse(messageJSON); var messageHandler; var responseCallback; if (message.responseId) &#123; responseCallback = responseCallbacks[message.responseId]; if (!responseCallback) &#123; return; &#125; responseCallback(message.responseData); delete responseCallbacks[message.responseId]; &#125; else &#123; if (message.callbackId) &#123; var callbackResponseId = message.callbackId; responseCallback = function(responseData) &#123; _doSend(&#123; responseId:callbackResponseId, responseData:responseData &#125;); &#125;; &#125; var handler = messageHandlers[message.handlerName]; try &#123; handler(message.data, responseCallback); &#125; catch(exception) &#123; console.log(\"WebViewJavascriptBridge: WARNING: javascript handler threw.\", message, exception); &#125; if (!handler) &#123; console.log(\"WebViewJavascriptBridge: WARNING: no handler for message from ObjC:\", message); &#125; &#125; &#125;);&#125; 在 _handleMessageFromObjC 里面又调用了 _dispatchMessageFromObjC。在这里面又发现了 setTimeout，和上面提到的一样，它会执行 _timeoutDispatchMessageFromObjC 方法。该函数里首先对 message.responseId 做了判断，我们知道它肯定是空的，因为传过来的参数只有 data ,callbackId 和 handlerName。在 else 里面取出来 callbackId 赋值给了 callbackResponseId。从 messageHandlers 中取出 handlerName 给了 handler，这里的 handler 就是 JavaScript 注册到这里的方法。执行 handler 并把回调给 native。执行回调的过程中 使用了 _doSend 函数，我们来看一下： function _doSend(message, responseCallback) &#123; //mesage 包含responseId,responseData //responseCallback为空 if (responseCallback) &#123; var callbackId = 'cb_'+(uniqueId++)+'_'+new Date().getTime(); responseCallbacks[callbackId] = responseCallback; message['callbackId'] = callbackId; &#125; sendMessageQueue.push(message); messagingIframe.src = CUSTOM_PROTOCOL_SCHEME + '://' + QUEUE_HAS_MESSAGE;&#125; 此时的 responseCallback 为空，不进 if 里面。然后把 message 放到了 sendMessageQueue 数组里，并把 messagingIframe.src 的设置成了 wvjbscheme://__WVJB_QUEUE_MESSAGE__，就又会执行 webView 的代理方法，在代理方法里判断 URL 为 wvjbscheme://__WVJB_QUEUE_MESSAGE__ 的话就会去 通过 _fetchQueue 来取 sendMessageQueue 的数据，并且回调 native 方法。至此，native 调用 JavaScript 注册的方法结束。 Objective-C 程序猿的加油站：stringify() 在上面的 _fetchQueue 中用到了 stringify()，下面说说 stringify() 是干什么用的stringify()用于从一个对象解析出字符串，例如：var a = {a:1,b:2}；执行JSON.stringify(a)后的结果为：“{“a”:1,”b”:2}” JavaScript 调用 native 方法native 调用的 JavaScript 的方法是在 JavaScript 里提前注册好的。同理，JavaScript 想调用 native 的方法，native 必须也要先注册。 在 ExampleUIWebViewController.m 中[_bridge registerHandler:@\"testObjcCallback\" handler:^(id data, WVJBResponseCallback responseCallback) &#123; NSLog(@\"testObjcCallback called: %@\", data); responseCallback(@&#123; @\"name\":@\"OC回调给js的参数\" &#125;); &#125;];//在 WebViewJavascriptBridge.m 中- (void)registerHandler:(NSString *)handlerName handler:(WVJBHandler)handler &#123; _base.messageHandlers[handlerName] = [handler copy];&#125; 在代码层面来看，native 的注册其实就是把 native 中需要被调用的名字和回调放到了 messageHandlers 的字典中。那我们来看看调用 native 方法的具体流程。在点击 webView 上的按钮（在 ExampleApp.html 里面创建的 callbackButton）后，调用了 callHandler 方法，传递的参数为要调用的 native 的方法名，参数和回调。来看看 callHandler 里有什么。 function callHandler(handlerName, data, responseCallback) &#123; if (arguments.length == 2 &amp;&amp; typeof data == 'function') &#123; responseCallback = data; data = null; &#125; _doSend(&#123; handlerName:handlerName, data:data &#125;, responseCallback);&#125; 这里做了容错判断（在下面的 Objective-C 程序猿加油站中有说明）后，和 native 调用 JavaScript 一样，都是调用了 _doSend 方法。在里面为 responseCallback 生成了 唯一的 callbackId 并放到 message 里，接下来的流程和 native 调用 JavaScript 大同小异，这里不再赘述。 Objective-C 程序猿的 js 加油站：arguments 在 JavaScript 中 arguments 对象是比较特别的一个对象，实际上是当前函数的一个内置属性，它的长度是由实参个数而不是形参个数决定的。那么就很容易理解了，上面的是一个冗错处理，也就是说在调用 callHandler 的时候可以不传调用 native 方法中的参数，只传递调用 nativie 方法中的方法名字和回调方法即可。 参考文章或链接setTimeout 函数介绍 JSON 教程 WebViewJavascript github 地址","categories":[],"tags":[]}]}