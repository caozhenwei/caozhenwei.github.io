{"meta":{"title":"caozhenwei","subtitle":null,"description":"caozhenwei 在 Github 上的个人博客","author":"caozhenwei","url":"https://github.com/caozhenwei"},"pages":[{"title":"Tags","date":"2018-03-21T11:44:58.000Z","updated":"2018-03-22T03:36:37.824Z","comments":true,"path":"Tags/index.html","permalink":"https://github.com/caozhenwei/Tags/index.html","excerpt":"","text":"123333"},{"title":"about","date":"2018-03-22T02:33:25.000Z","updated":"2018-03-22T03:43:01.345Z","comments":true,"path":"about/index.html","permalink":"https://github.com/caozhenwei/about/index.html","excerpt":"","text":""}],"posts":[{"title":"mac下常用命令和快捷键","slug":"mac下常用命令","date":"2018-06-19T06:24:47.000Z","updated":"2018-06-19T07:28:37.716Z","comments":true,"path":"2018/06/19/mac下常用命令/","link":"","permalink":"https://github.com/caozhenwei/2018/06/19/mac下常用命令/","excerpt":"","text":"前言使用命令行或者使用快捷键会大大的提高工作效率，本问会总结一些经常用到的快捷键和命令。统统列出来肯定是列不全的，只能边用边总结，文章持续更新中。。。 mac下常用快捷键打开实用工具cmd + shift + U 去往任意路径的文件夹cmd + shift + U mac终端下常用命令查看系统支持的 shell 列表cat /etc/shells 删除所有系统日志sudo rm -rf /private/var/log/* 获得一个文件的 md5 值openssl md5 /Users/caozhenwei/Desktop/12345/html.dek 查看内核版本uname -a mac 下添加类似于 linux 的 tree 命令 find . -print | sed -e &#39;s;[^/]*/;|____;g;s;____|; |;g&#39;在 .bash_profile 中加入上面面这条，就能在 mac 下使用 tree 命令了 Home-brew 安装 （官网 http://brew.sh/index_zh-cn.html）/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 安装 node（ 官网 https://nodejs.org/en/）brew install node 重新启动 Mac 的命令sudo shutdown -r now 获取 ip 地址ipconfig getifaddr en0 修改主机名称sudo scutil --set HostName MacBookPro 修改共享名称sudo scutil --set ComputerName MacBookPro 解压 rar 文件brew install unrarunrar x 文件名.rar 查看文件占用的磁盘空间du -sh ~/.cocoapods profile 文件的路径~/Library/MobileDevice/Provisioning\\ Profiles/","categories":[],"tags":[]},{"title":"CSS之Flex布局","slug":"CSS之Flex布局","date":"2018-06-19T02:22:18.000Z","updated":"2018-06-19T03:58:20.799Z","comments":true,"path":"2018/06/19/CSS之Flex布局/","link":"","permalink":"https://github.com/caozhenwei/2018/06/19/CSS之Flex布局/","excerpt":"Flex布局是什么？Flex 是 Flexible Box 的缩写，意为”弹性盒子”，用来为盒状模型提供最大的灵活性。布局的传统解决方案是基于盒状模型，依赖 display 属性 + position 属性 + float 属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。学习 Flex 布局要先了弹性容器和项目。给容器添加 display: flex 就表示它要用弹性布局，弹性盒子里面的子元素称为项目。","text":"Flex布局是什么？Flex 是 Flexible Box 的缩写，意为”弹性盒子”，用来为盒状模型提供最大的灵活性。布局的传统解决方案是基于盒状模型，依赖 display 属性 + position 属性 + float 属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。学习 Flex 布局要先了弹性容器和项目。给容器添加 display: flex 就表示它要用弹性布局，弹性盒子里面的子元素称为项目。 弹性盒子模型弹性盒子的模型如下所示。 弹性盒子有两条轴，默认的水平主轴和竖直轴。主轴的开始位置（与边框的交叉点）叫做 main start，结束位置叫做 main end；交叉轴的开始位置叫做 cross start，结束位置叫做cross end。项目默认沿主轴排列。单个项目占据的主轴空间叫做 main size，占据的交叉轴空间叫做 cross size 。 上面的这段对于没接触过 CSS 的同学估计会稍微难理解点。一时看不懂很正常，接着往下看就会明白了。先说两条轴，说到这里我们思考一下，为什么要有两条轴呢？想象一大堆元素在盒子里等着我们来摆放它们的位置，怎么来摆放呢，肯定要确定一个放置的方向啊，那就对了，可以在水平方向上从左到右、从右到左，当然也可以在垂直方向上从上到下或者从下到上，这种方向就是上面说的那两条轴。 使用弹性布局注意事项使用弹性布局后要注意下面几点： 容器添加弹性布局后，仅仅是容器内容采用弹性布局，而容器本身在文档流中的定位方式依然遵循常规文档流 display:flex; 容器添加弹性布局后，显示为块级元素； display:inline-flex; 容器添加弹性布局后，显示为行级元素； 设为 Flex 布局后，子元素的 float、clear 和 vertical-align 属性将失效。但是position 属性，依然生效。 弹性容器常用属性 flex-direction flex-wrap flex-flow justify-content align-items align-content flex-directionflex-direction 属性决定主轴的方向（即项目的排列方向）。 .box &#123; flex-direction: row | row-reverse | column | column-reverse;&#125; row：从左上角开始，由左到右排列。row-reverse：从右上角开始，由右向左排列。column：从左上角开始，由上往下排列。column-reverse：从左下角开始，由下向上排列。 flex-wrapflex-wrap 属性定义，规定如果一条轴线排不下，如何换行。 .box&#123; flex-wrap: nowrap | wrap | wrap-reverse;&#125; nowrap（默认）：不换行。wrap：换行，第一行在上方。wrap-reverse：换行，第一行在下方。 flex-flowflex-flow 属性是 flex-direction 属性和 flex-wrap 属性的简写形式，默认值为 row nowrap。 .box &#123; flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;&#125; justify-contentjustify-content 属性定义了项目在主轴上的对齐方式。 .box &#123; justify-content: flex-start | flex-end | center | space-between | space-around;&#125; flex-start（默认值）：左对齐flex-end：右对齐center： 居中space-between：两端对齐，项目之间的间隔都相等。space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 align-itemsalign-items 属性定义项目在交叉轴上如何对齐。 .box &#123; align-items: flex-start | flex-end | center | baseline | stretch;&#125; flex-start：交叉轴的起点对齐。flex-end：交叉轴的终点对齐。center：交叉轴的中点对齐。baseline: 项目的第一行文字的基线对齐。stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 align-contentalign-content 属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 .box &#123; align-content: flex-start | flex-end | center | space-between | space-around | stretch;&#125; flex-start：与交叉轴的起点对齐。flex-end：与交叉轴的终点对齐。center：与交叉轴的中点对齐。space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。stretch（默认值）：轴线占满整个交叉轴。 项目常用属性 order flex-grow flex-shrink flex-basis flex align-self order 属性定义项目的排列顺序。数值越小，排列越靠前，默认为 0 。 flex-grow 属性定义项目的放大比例，默认为 0 ，即如果存在剩余空间，也不放大。 flex-shrink 属性定义了项目的缩小比例，默认为 1，即如果空间不足，该项目将缩小。 flex-basis 属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为 auto ，即项目的本来大小。 flex 属性是 flex-grow, flex-shrink 和 flex-basis 的简写，默认值为 0 1 auto。后两个属性可选。 align-self 属性允许单个项目有与其他项目不一样的对齐方式，可覆盖 align-items 属性。默认值为 auto，表示继承父元素的 align-items 属性，如果没有父元素，则等同于 stretch。 参考链接 https://scotch.io/tutorials/a-visual-guide-to-css3-flexbox-properties#basics https://css-tricks.com/snippets/css/a-guide-to-flexbox https://www.processon.com","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://github.com/caozhenwei/tags/CSS/"}]},{"title":"css 学习","slug":"css-学习","date":"2018-06-11T08:38:20.000Z","updated":"2018-06-19T03:48:03.054Z","comments":true,"path":"2018/06/11/css-学习/","link":"","permalink":"https://github.com/caozhenwei/2018/06/11/css-学习/","excerpt":"CSS 指的是层叠样式表 (Cascading Style Sheets)，说白了就是来定义 HTML 元素的样式的。要设置 HTML 元素的样式，首先我们要选中 HTML 元素。常用的选中方式有 id 选择器和类选择器。 id 选择器以 # 来定义，类选择器以 . 来定义。","text":"CSS 指的是层叠样式表 (Cascading Style Sheets)，说白了就是来定义 HTML 元素的样式的。要设置 HTML 元素的样式，首先我们要选中 HTML 元素。常用的选中方式有 id 选择器和类选择器。 id 选择器以 # 来定义，类选择器以 . 来定义。 CSS 的语法如下：例子如下： &lt;html&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /&gt;&lt;title&gt;选择器&lt;/title&gt;&lt;head&gt;&lt;style type=\"text/css\"&gt; #p &#123; background-color: yellow; &#125; .div1 &#123; background-color: red; width: 100px; height: 100px; &#125; .pos_abs2 &#123;&lt;/style&gt;&lt;/head&gt;&lt;body id=\"body\"&gt; &lt;div class=\"div1\"&gt; &lt;p&gt;div1&lt;/p&gt; &lt;/div&gt; &lt;p id=\"p\"&gt;这里要用id选择器来选中&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 这里我们用类选择器选中 div 标签并把它的背景设置为红色，宽高分别为 100px ，用 id 选择器选中 p 标签元算并把它的背景设置为黄色。效果如下： 通过上面的介绍我们知道了正如上面的例子所示，为什么我写 p 标签元素的时候它给我换行了呢，并且还自动的有了边距，这是什么鬼？这就涉及到了行内元素和块级元素。所谓的行内元素指的是书写完成后不会自动换行，并且元素没有宽和高，块级元素写完后会自动换行，有宽高可以修改。例如上例中的 div 和 p 都是块级元素，这就是写完 div 后，p 为什么会另起一行的原因。那么自动加上的边距又是什么情况呢？这里介绍下盒子模型。用 Firefox 打开上面的例子后查看元素，如下所示 我们可以看到浏览器默认给 body 元素加了 8px 的外边距。盒模型是有两种标准的，一个是标准模型，一个是 IE 模型。 这两种模型相似之处是从里到外都是 content ,padding ,border ,margin 。不同之处是标准模型的宽高只是内容（content）的宽高，而在 IE 模型中盒模型的宽高是内容(content)+填充(padding)+边框(border)的总宽高。 position 属性position 属性指定一个元素的定位方法的类型，分别是 static、fixed、relative、absolute。 static 定位是 HTML 元素的默认值，即没有定位，元素出现在正常的流中。 relative 是以自身在正常文档流的位置进行相应的偏移。 absolute 如果某个元素的 position 为 absolute ，那么这个元素就会按照其祖先元素中设置了 position 属性的元素来定位（从 padding 开始的地方），如果不存在这样设置了 position 的祖先元素，则会以 body 为定位对象。这个元素在文档流中溢出后，其文档流中的下一个元素将获得其位置。 fixed 是特殊的 absolute，即 fixed 总是以浏览器的可视窗口进行定位。下面来看几个简单的例子。 &lt;html&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /&gt;&lt;title&gt;postion相关属性&lt;/title&gt;&lt;head&gt;&lt;style type=\"text/css\"&gt; #body &#123; background-color: #ccc; &#125; .pos_sta &#123; background-color: red; width: 100px; height: 100px; position: static; left: 200px; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body id=\"body\"&gt; &lt;div class=\"pos_sta\"&gt; &lt;p&gt;div1&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 从上的例子中可以看出，static 这种定位不会受到 top ，bottom ,left ,right 的影响。 定位为 relative 时 &lt;html&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /&gt;&lt;title&gt;postion相关属性&lt;/title&gt;&lt;head&gt;&lt;style type=\"text/css\"&gt; #body &#123; background-color: #ccc; &#125; .pos_relative1 &#123; background-color: red; width: 100px; height: 100px; &#125; .pos_relative2 &#123; background-color: green; width: 100px; height: 100px; position: relative; left: 150px; &#125; .pos_relative3 &#123; background-color: blue; width: 100px; height: 100px; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body id=\"body\"&gt; &lt;div class=\"pos_relative1\"&gt; &lt;p&gt;div1&lt;/p&gt; &lt;/div&gt; &lt;div class=\"pos_relative2\"&gt; &lt;p&gt;div2&lt;/p&gt; &lt;/div&gt; &lt;div class=\"pos_relative3\"&gt; &lt;p&gt;div3&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 从上述代码可以看出，当对 div2 设置 position 为 relative 时，只是在它原来的基础上进行偏移，并没有影响下面的元素 定位为 absolute 时, &lt;html&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /&gt;&lt;title&gt;postion相关属性&lt;/title&gt;&lt;head&gt;&lt;style type=\"text/css\"&gt; #body &#123; background-color: #ccc; &#125; .pos_abs1 &#123; background-color: red; width: 100px; height: 100px; &#125; .pos_abs2_parent &#123; background-color: Pink; width: 100px; height: 100px; position: absolute; left: 50px; top: 50px; &#125; .pos_abs2 &#123; background-color: green; width: 100px; height: 100px; position: absolute; left: 50px; top: 50px; &#125; .pos_abs3 &#123; background-color: blue; width: 100px; height: 100px; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body id=\"body\"&gt; &lt;div class=\"pos_abs1\"&gt; &lt;p&gt;div1&lt;/p&gt; &lt;/div&gt; &lt;div class=\"pos_abs2_parent\"&gt; &lt;div class=\"pos_abs2\"&gt; &lt;p&gt;div2&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"pos_abs3\"&gt; &lt;p&gt;div3&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 从上述代码可以看出，当对 div2 设置 position 为 absolute 时,它就从正常的文档流中脱离出来了，如果 pos_abs2 有祖先元素设置了 position 属性，则以其设置了 position 属性的元素为祖先元素来定位。 &lt;html&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /&gt; &lt;title&gt;postion相关属性&lt;/title&gt; &lt;head&gt; &lt;style type=\"text/css\"&gt; #body { background-color: #ccc; } .pos_abs1 { background-color: red; width: 100px; height: 100px; } .pos_abs2_parent { background-color: Pink; width: 100px; height: 100px; position: absolute; left: 150px; top: 150px; } .pos_abs2 { background-color: green; width: 100px; height: 100px; position: fixed; left: 50px; top: 50px; } .pos_abs3 { background-color: blue; width: 100px; height: 100px; } &lt;/style&gt; &lt;/head&gt; &lt;body id=\"body\"&gt; &lt;div class=\"pos_abs1\"&gt; &lt;p&gt;div1&lt;/p&gt; &lt;/div&gt; &lt;div class=\"pos_abs2_parent\"&gt; &lt;div class=\"pos_abs2\"&gt; &lt;p&gt;div2&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"pos_abs3\"&gt; &lt;p&gt;div3&lt;/p&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 从上述代码可以看出，当对 div2 设置 position 为 fixed 时,总是以浏览器的可视窗口进行定位。 http://www.w3school.com.cn","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://github.com/caozhenwei/tags/CSS/"}]},{"title":"Cycript 简单使用","slug":"Cycript-简单使用","date":"2018-05-28T08:56:29.000Z","updated":"2018-06-07T06:17:50.487Z","comments":true,"path":"2018/05/28/Cycript-简单使用/","link":"","permalink":"https://github.com/caozhenwei/2018/05/28/Cycript-简单使用/","excerpt":"","text":"cycript 官方文档 http://www.cycript.org/manual/ Cycript 允许开发人员在 iOS 或 Mac OS X 上使用 objective - c++ 和 JavaScript 语法的混合工具来探索和修改运行的应用程序，通过一个具有语法高亮和标签完成功能的交互式控制台。(它还能在 Android 和 Linux 上独立运行，并提供对 Java 的访问，但没有注入。) Cycript allows developers to explore and modify running applications on either iOS or Mac OS X using a hybrid of Objective-C++ and JavaScript syntax through an interactive console that features syntax highlighting and tab completion. (It also runs standalone on Android and Linux and provides access to Java, but without injection.) ssh 到手机后，启动 app 并且确保它在前台运行，然后执行 cycript -p WeChat 出现 cy# 提示符号表示成功。 常用操作 显示 alertalertView = [[UIAlertView alloc] initWithTitle:@”test” message:@”Cycript” delegate:nil cancelButtonTitle:@”OK” otherButtonTitles:nil];[alertView show]; 查看当前控制器UIApp.keyWindow.rootViewController.visibleViewController 获取 bundle info[[NSBundle mainBundle] infoDictionary].toString() 显示 Controller 的层次结构_printHierarchy 是 UIViewController 的一个私有方法，你可以用它将 view controller 层次打印到控制台。[[[UIWindow keyWindow] rootViewController] _printHierarchy].toString() 修改某个 label 的文字#0x1530cd5f0.text = @&quot;111&quot; 修改某个 view 的 backgroundColor#0x1409777b0.backgroundColor = [UIColor redColor] 打印 view 层级[[UIApp keyWindow] recursiveDescription].toString() 打印层级树[[UIApp keyWindow] _autolayoutTrace].toString() _ivarDescription 获取某个类的属性[choose(FixTitleColorButton)[0] _ivarDescription].toString() _methodDescription[choose(FixTitleColorButton)[0] _methodDescription].toString() 打印视图的响应者 [#0x12e5629f0 nextResponder]","categories":[],"tags":[]},{"title":"iOS 逆向之砸壳","slug":"iOS-逆向之砸壳","date":"2018-05-28T01:45:17.000Z","updated":"2018-06-15T07:56:18.592Z","comments":true,"path":"2018/05/28/iOS-逆向之砸壳/","link":"","permalink":"https://github.com/caozhenwei/2018/05/28/iOS-逆向之砸壳/","excerpt":"","text":"前言从 AppStore 下载的 App 是被苹果使用 FairPlay 技术加密过的， 可执行文件被套上了一层保护壳， 而 class-dump Hopper 等工具无法作用于加密过的 App。 在这种情况下， 想要获取头文件， 需要先解密 App 的可执行文件， 俗称“砸壳”。 砸壳的工具有好多种，其核心原理就是将内存中已解密的镜像 “dump” 出来，再生成新的镜像文件，从而达到解密的效果。可执行程序要想运行起来，必须由操作系统把可执行文件加载进内存，iOS 中用的是 DYLD。 dumpdecrypteddumpdecrypted 就是由越狱社区的知名人士 Stefan Esser（ @i0n1c） 出品的一款砸壳工具， 被越狱社区广泛运用在 iOS 逆向工程研究中。下面介绍怎么用 dumpdecrypted 给 app 砸壳。下载 dumpdecrypted 地址为 https://github.com/stefanesser/dumpdecrypted/下载完成后直接 make （如果安装了不同的 iOS SDK，可以调整 Makefile 文件），一切顺利的话会生成名为 dumpdecrypted.dylib 的动态库，先暂时放在这里留着备用。 SSH 连接越狱 iDivice为了书写和描述，我们把 iPhone、iPad、iPod 等 统称为 iDivice 。iDivice 越狱后有 root 和 mobile 两个账户，默认密码为 alpine ，建议马上修改这个默认的密码，防止其他人通过这个默认密码登录 iDivice 。修改命令如下： $ su root$ passwdChanging password for root.New password:Retype new password: 越狱 iDivice 使用 Cydia 搜索 openSSH ，安装即可。连接方式有两种 2.1 WiFi 连接首先确保 iDivice 和 电脑在统一局域网，连接操作如下 $ ssh root@x.x.x.x 其中 x.x.x.x 为 iDivice 的 ip 地址。 2.2 USB连接2.2.1 安装 usbmuxd$ brew install usbmuxd 2.2.2 端口映射$ iproxy 2345 22 相当于把 iDivice 的 22 端口映射到电脑的 2345 端口 2.2.3 连接新开一个终端窗口，并且保持 2.2 中的终端窗口没有被关闭 $ ssh -p 2345 root@127.0.0.1 获取两个路径查看 app 进程，这里以 WeChat 为例 ，这里要保证 WeChat 在前台运行 $ ps -ef | grep /var/mobile/ 501 506 1 0 0:00.00 ?? 1:19.23 /var/mobile/Containers/Bundle/Application/F14174A6-AEC8-4AD4-A09A-9049FDCBB55E/WeChat.app/WeChat 0 1529 1482 0 0:00.00 ttys001 0:00.01 grep /var/mobile/ 先记下这个路径备用 查看 app Document 路径这个需要用到 cycript 这个工具。cycript 是混合了 oc 与 js 语法的一个工具, 让开发者在命令行下和应用交互，在运行时查看和修改应用，挂钩相关的进程后，我们就可以用 oc 的方法来查看 app Document 路径了。挂钩进程 $ cycript -p WeChatcy# [[NSFileManager defaultManager] URLsForDirectory:NSDocumentDirectory inDomains:NSUserDomainMask]@[#\"file:///var/mobile/Containers/Data/Application/6475E209-3EF7-4264-ADC5-FBE0264516BF/Documents/\"]cy# 退出 cy# 模式的快捷键为 ctl + d，把上面输出的路径也记下来备用。 把第一步中生成的 dumpdecripted.dylib 动态库拷贝到该 app 的 Document 目录下该操作要用到 scp 命令。scp 是 secure copy 的缩写, 基于 ssh 登陆进行安全的远程文件拷贝命令。例子：两台机器IP分别为：A 192.168.11.10，B 192.168.11.11，如果想把 A 根目录上的 a.jpg 文件拷到 B 上，命令如下：在A服务器上操作 命令为： $ scp /a.jpg root@192.168.11.11:/ 所以此时把生成的 dumpdecripted.dylib 动态库拷贝到该 app 的 Document 目录，命令如下：在 mac的终端上操作 $ scp dumpdecrypted.dylib root@x.x.x.x:/var/mobile/Containers/Data/Application/6475E209-3EF7-4264-ADC5-FBE0264516BF/Documents/ 开始砸壳进入 Document 目录$ cd /var/mobile/Containers/Data/Application/6475E209-3EF7-4264-ADC5-FBE0264516BF/Documents/ 砸壳 $ DYLD_INSERT_LIBRARIES=dumpdecrypted.dylib /var/mobile/Containers/Bundle/Application/F14174A6-AEC8-4AD4-A09A-9049FDCBB55E/WeChat.app/WeChatmach-o decryption dumperDISCLAIMER: This tool is only meant for security research purposes, not for application crackers.[+] detected 64bit ARM binary in memory.[+] offset to cryptid found: @0x1000fcca8(from 0x1000fc000) = ca8[+] Found encrypted data at address 00004000 of length 58818560 bytes - type 1.[+] Opening /private/var/mobile/Containers/Bundle/Application/F14174A6-AEC8-4AD4-A09A-9049FDCBB55E/WeChat.app/WeChat for reading.[+] Reading header[+] Detecting header type[+] Executable is a plain MACH-O image[+] Opening WeChat.decrypted for writing.[+] Copying the not encrypted start of the file[+] Dumping the decrypted data into the file[+] Copying the not encrypted remainder of the file[+] Setting the LC_ENCRYPTION_INFO-&gt;cryptid to 0 at offset ca8[+] Closing original file[+] Closing dump file$ ls00000000000000000000000000000000 MMResourceMgr OpenImResource db.globalconfigCrashReport MMappedKV SafeMode.dat dumpdecrypted.dylibLocalInfo.lst MemoryStat WeChat.decrypted heavy_user_id_mapping.dat 此时就可以在当前目录下看到被砸壳后的 WeChat.decrypted。 获取可执行文件的所有头文件从 iDvice 上把解密后的文件拷到电脑的桌面上，在电脑终端上操作 $ scp root@x.x.x.x:/var/mobile/Containers/Data/Application/6475E209-3EF7-4264-ADC5-FBE0264516BF/Documents/WeChat.decrypted ~/Desktop/``` 获取 .h 文件需要用到 class-dump 工具，下载地址为 http://stevenygard.com/projects/class-dump/。把砸壳后的可执行文件的所有 .h 文件输出到 wechat_test_h 文件夹下``` bashclass-dump -H WeChat.decrypted -o wechat_test_h 这时候就能看到所有 WeChat 的头文件了。 相关链接FairPlay https://en.wikipedia.org/wiki/FairPlaydumpdecrypted https://github.com/stefanesser/dumpdecrypted/class-dump http://stevenygard.com/projects/class-dump/","categories":[],"tags":[]},{"title":"Logos 语法","slug":"Logos-语法","date":"2018-05-24T06:30:55.000Z","updated":"2018-05-28T08:36:10.330Z","comments":true,"path":"2018/05/24/Logos-语法/","link":"","permalink":"https://github.com/caozhenwei/2018/05/24/Logos-语法/","excerpt":"","text":"前言这篇文章翻译自 http://iphonedevwiki.net/index.php/Logos，主要是 logos 语法。Logos 是 Theos 开发套件的一个组成部分，它允许使用一组特殊的预处理器指令，轻松地、清晰地编写方法来 hook 代码。 综述","categories":[],"tags":[]},{"title":"Mach-O 学习","slug":"Mach-O-学习","date":"2018-05-22T07:10:31.000Z","updated":"2018-05-22T12:08:50.522Z","comments":true,"path":"2018/05/22/Mach-O-学习/","link":"","permalink":"https://github.com/caozhenwei/2018/05/22/Mach-O-学习/","excerpt":"Mach-O，是 Mach object 文件格式的缩写，同样也是 OS X 和 iOS 系统中可执行文件格式。类似于 Linux 下的 elf。除了可执行文件外，动态链接库、静态链接库等都是这种格式的。了解 Mach-O ，也助于我们更好的学习 iOS 逆向工程。","text":"Mach-O，是 Mach object 文件格式的缩写，同样也是 OS X 和 iOS 系统中可执行文件格式。类似于 Linux 下的 elf。除了可执行文件外，动态链接库、静态链接库等都是这种格式的。了解 Mach-O ，也助于我们更好的学习 iOS 逆向工程。 Mach-O 结构简单介绍Mach-O 主要由三部分组成：Header、Load commands、Raw segment data，如下图所示： Header保存了 Mach-O 的一些基本信息，包括了平台、文件类型、LoadCommands 的个数等等。 LoadCommands这些指令非常清晰地指示加载器如何设置并且加载二进制数据，这一段紧跟 Header，加载 Mach-O 文件时会使用这里的数据来确定内存的分布。 Data 每一个 segment 的具体数据都保存在这里，这里包含了具体的代码、数据等等。 Mach-O 三部分结构详细介绍Header我们可以用 otool 先来看看 iOS 中一个可执行文件的头信息，这里拿微信来看看，otool -h WeChat: $ otool -h WeChat Mach header magic cputype cpusubtype caps filetype ncmds sizeofcmds flags 0xfeedface 12 9 0x00 2 86 8192 0x00218085Mach header magic cputype cpusubtype caps filetype ncmds sizeofcmds flags 0xfeedfacf 16777228 0 0x00 2 86 8984 0x00218085 下面详细介绍下这都代表什么意思。 头信息的结构可以在 /usr/include/mach-o/loader.h 中查看 /* * The 32-bit mach header appears at the very beginning of the object file for * 32-bit architectures. */struct mach_header &#123; uint32_t magic; /* mach magic number identifier */ cpu_type_t cputype; /* cpu specifier */ cpu_subtype_t cpusubtype; /* machine specifier */ uint32_t filetype; /* type of file */ uint32_t ncmds; /* number of load commands */ uint32_t sizeofcmds; /* the size of all the load commands */ uint32_t flags; /* flags */&#125;;/* Constant for the magic field of the mach_header (32-bit architectures) */#define MH_MAGIC 0xfeedface /* the mach magic number */#define MH_CIGAM 0xcefaedfe /* NXSwapInt(MH_MAGIC) *//* * The 64-bit mach header appears at the very beginning of object files for * 64-bit architectures. */struct mach_header_64 &#123; uint32_t magic; /* mach magic number identifier */ cpu_type_t cputype; /* cpu specifier */ cpu_subtype_t cpusubtype; /* machine specifier */ uint32_t filetype; /* type of file */ uint32_t ncmds; /* number of load commands */ uint32_t sizeofcmds; /* the size of all the load commands */ uint32_t flags; /* flags */ uint32_t reserved; /* reserved */&#125;;/* Constant for the magic field of the mach_header_64 (64-bit architectures) */#define MH_MAGIC_64 0xfeedfacf /* the 64-bit mach magic number */#define MH_CIGAM_64 0xcffaedfe /* NXSwapInt(MH_MAGIC_64) */ magic : 魔数从上面的宏定义可以看出 0xfeedface 代表的是 32 位，0xfeedfacf 代表 64 位cputype : cpu 的类型在 /usr/include/mach/machine.h 中可以看到相关的定义 /* * Machine types known by all. */ #define CPU_TYPE_ANY ((cpu_type_t) -1)#define CPU_TYPE_VAX ((cpu_type_t) 1)/* skip ((cpu_type_t) 2) *//* skip ((cpu_type_t) 3) *//* skip ((cpu_type_t) 4) *//* skip ((cpu_type_t) 5) */#define CPU_TYPE_MC680x0 ((cpu_type_t) 6)#define CPU_TYPE_X86 ((cpu_type_t) 7)#define CPU_TYPE_I386 CPU_TYPE_X86 /* compatibility */#define CPU_TYPE_X86_64 (CPU_TYPE_X86 | CPU_ARCH_ABI64)/* skip CPU_TYPE_MIPS ((cpu_type_t) 8) *//* skip ((cpu_type_t) 9) */#define CPU_TYPE_MC98000 ((cpu_type_t) 10)#define CPU_TYPE_HPPA ((cpu_type_t) 11)#define CPU_TYPE_ARM ((cpu_type_t) 12)#define CPU_TYPE_ARM64 (CPU_TYPE_ARM | CPU_ARCH_ABI64)#define CPU_TYPE_MC88000 ((cpu_type_t) 13)#define CPU_TYPE_SPARC ((cpu_type_t) 14)#define CPU_TYPE_I860 ((cpu_type_t) 15)/* skip CPU_TYPE_ALPHA ((cpu_type_t) 16) *//* skip ((cpu_type_t) 17) */#define CPU_TYPE_POWERPC ((cpu_type_t) 18)#define CPU_TYPE_POWERPC64 (CPU_TYPE_POWERPC | CPU_ARCH_ABI64) cupsubtype cpu 的子类型和 cputype 一样，也可以在 /usr/include/mach/machine.h 中可以看到相关的定义，其中有关于 PowerPC 的，Mips 的等等，这里列一下关于 ARM 的: ........./* * ARM subtypes */#define CPU_SUBTYPE_ARM_ALL ((cpu_subtype_t) 0)#define CPU_SUBTYPE_ARM_V4T ((cpu_subtype_t) 5)#define CPU_SUBTYPE_ARM_V6 ((cpu_subtype_t) 6)#define CPU_SUBTYPE_ARM_V5TEJ ((cpu_subtype_t) 7)#define CPU_SUBTYPE_ARM_XSCALE ((cpu_subtype_t) 8)#define CPU_SUBTYPE_ARM_V7 ((cpu_subtype_t) 9)#define CPU_SUBTYPE_ARM_V7F ((cpu_subtype_t) 10) /* Cortex A9 */#define CPU_SUBTYPE_ARM_V7S ((cpu_subtype_t) 11) /* Swift */#define CPU_SUBTYPE_ARM_V7K ((cpu_subtype_t) 12)#define CPU_SUBTYPE_ARM_V6M ((cpu_subtype_t) 14) /* Not meant to be run under xnu */#define CPU_SUBTYPE_ARM_V7M ((cpu_subtype_t) 15) /* Not meant to be run under xnu */#define CPU_SUBTYPE_ARM_V7EM ((cpu_subtype_t) 16) /* Not meant to be run under xnu */......... filetype 文件的类型相关定义在 /usr/include/mach-o/loader.h 中 #define MH_OBJECT 0x1 /* relocatable object file */#define MH_EXECUTE 0x2 /* demand paged executable file */#define MH_FVMLIB 0x3 /* fixed VM shared library file */#define MH_CORE 0x4 /* core file */#define MH_PRELOAD 0x5 /* preloaded executable file */#define MH_DYLIB 0x6 /* dynamically bound shared library */#define MH_DYLINKER 0x7 /* dynamic link editor */#define MH_BUNDLE 0x8 /* dynamically bound bundle file */#define MH_DYLIB_STUB 0x9 /* shared library stub for static */......... 常用的如下： MH_OBJECT 编译过程中产生的 *.obj 文件 MH_EXECUTABLE 可执行二进制文件 MH_DYLIB 动态库 ncmds 指的是加载命令 (load commands) 的数量sizeofcmds 表示 load commands 的总字节大小flags 一个包含一组位标志的整数，它显示了 Mach-O 文件格式的某些可选特性的状态。 加载命令这些加载命令在 Mach-O 文件加载解析时，被内核加载器或者动态链接器调用，指导如何设置加载对应的二进制数据段，加载命令的种类有很多种，在 /usr/include/mach-o/loader.h 头文件有简单的注释 struct load_command &#123; uint32_t cmd; /* type of load command */ uint32_t cmdsize; /* total size of command in bytes */&#125;;/* * After MacOS X 10.1 when a new load command is added that is required to be * understood by the dynamic linker for the image to execute properly the * LC_REQ_DYLD bit will be or'ed into the load command constant. If the dynamic * linker sees such a load command it it does not understand will issue a * \"unknown load command required for execution\" error and refuse to use the * image. Other load commands without this bit that are not understood will * simply be ignored. */#define LC_REQ_DYLD 0x80000000/* Constants for the cmd field of all load commands, the type */#define LC_SEGMENT 0x1 /* segment of this file to be mapped */#define LC_SYMTAB 0x2 /* link-edit stab symbol table info */#define LC_SYMSEG 0x3 /* link-edit gdb symbol table info (obsolete) */#define LC_THREAD 0x4 /* thread */#define LC_UNIXTHREAD 0x5 /* unix thread (includes a stack) */#define LC_LOADFVMLIB 0x6 /* load a specified fixed VM shared library */#define LC_IDFVMLIB 0x7 /* fixed VM shared library identification */#define LC_IDENT 0x8 /* object identification info (obsolete) */#define LC_FVMFILE 0x9 /* fixed VM file inclusion (internal use) */#define LC_PREPAGE 0xa /* prepage command (internal use) */#define LC_DYSYMTAB 0xb /* dynamic link-edit symbol table info */#define LC_LOAD_DYLIB 0xc /* load a dynamically linked shared library */......... LC_SYMTAB 符号表地址 LC_DYSYMTAB 动态符号表地址 LC_LOAD_DYLINKER 使用何种动态加载库 LC_UUID 文件的唯一标识 LC_VERSION_MIN_MACOSX 二进制文件要求的最低操作系统版本 LC_SOURCE_VERSION 构建该二进制文件使用的源代码版本 LC_MAIN 设置程序主线程的入口地址和栈大小 通过 otool -lv 来查看一下 WeChat $ otool -lv WeChat WeChat (architecture armv7):Mach header magic cputype cpusubtype caps filetype ncmds sizeofcmds flags MH_MAGIC ARM V7 0x00 EXECUTE 89 8292 NOUNDEFS DYLDLINK TWOLEVEL WEAK_DEFINES BINDS_TO_WEAK PIELoad command 0 cmd LC_SEGMENT cmdsize 56 segname __PAGEZERO vmaddr 0x00000000 vmsize 0x00004000 fileoff 0 filesize 0 maxprot --- initprot --- nsects 0 flags (none)Load command 1 cmd LC_SEGMENT cmdsize 736 segname __TEXT vmaddr 0x00004000 vmsize 0x034dc000 fileoff 0 filesize 55427072 maxprot r-x initprot r-x nsects 10 flags (none)Section sectname __text segname __TEXT addr 0x0000aff0 size 0x02d4bac4 offset 28656 align 2^4 (16) reloff 0 nreloc 0 type S_REGULARattributes PURE_INSTRUCTIONS SOME_INSTRUCTIONS reserved1 0 reserved2 0......... 其中每个 load command 的结构如下： struct segment_command &#123; /* for 32-bit architectures */ uint32_t cmd; /* LC_SEGMENT */ uint32_t cmdsize; /* includes sizeof section structs */ char segname[16]; /* segment name */ uint32_t vmaddr; /* memory address of this segment */ uint32_t vmsize; /* memory size of this segment */ uint32_t fileoff; /* file offset of this segment */ uint32_t filesize; /* amount to map from the file */ vm_prot_t maxprot; /* maximum VM protection */ vm_prot_t initprot; /* initial VM protection */ uint32_t nsects; /* number of sections in segment */ uint32_t flags; /* flags */&#125;;/* * The 64-bit segment load command indicates that a part of this file is to be * mapped into a 64-bit task's address space. If the 64-bit segment has * sections then section_64 structures directly follow the 64-bit segment * command and their size is reflected in cmdsize. */struct segment_command_64 &#123; /* for 64-bit architectures */ uint32_t cmd; /* LC_SEGMENT_64 */ uint32_t cmdsize; /* includes sizeof section_64 structs */ char segname[16]; /* segment name */ uint64_t vmaddr; /* memory address of this segment */ uint64_t vmsize; /* memory size of this segment */ uint64_t fileoff; /* file offset of this segment */ uint64_t filesize; /* amount to map from the file */ vm_prot_t maxprot; /* maximum VM protection */ vm_prot_t initprot; /* initial VM protection */ uint32_t nsects; /* number of sections in segment */ uint32_t flags; /* flags */&#125;; cmd 是 load command 的类型cmdsize 代表 load command 的大小segname 段名字vmaddr 段的虚拟内存起始地址vmsize 段的虚拟内存大小fileoff 段在文件中的偏移量filesize 段在文件中的大小maxprot 段页面所需要的最高内存保护initprot 段页面初始的内存保护nsects 段中包含 section 的数量flags 其他杂项标志位 Datasection 的机构如下： struct section &#123; /* for 32-bit architectures */ char sectname[16]; /* name of this section */ char segname[16]; /* segment this section goes in */ uint32_t addr; /* memory address of this section */ uint32_t size; /* size in bytes of this section */ uint32_t offset; /* file offset of this section */ uint32_t align; /* section alignment (power of 2) */ uint32_t reloff; /* file offset of relocation entries */ uint32_t nreloc; /* number of relocation entries */ uint32_t flags; /* flags (section type and attributes)*/ uint32_t reserved1; /* reserved (for offset or index) */ uint32_t reserved2; /* reserved (for count or sizeof) */&#125;;struct section_64 &#123; /* for 64-bit architectures */ char sectname[16]; /* name of this section */ char segname[16]; /* segment this section goes in */ uint64_t addr; /* memory address of this section */ uint64_t size; /* size in bytes of this section */ uint32_t offset; /* file offset of this section */ uint32_t align; /* section alignment (power of 2) */ uint32_t reloff; /* file offset of relocation entries */ uint32_t nreloc; /* number of relocation entries */ uint32_t flags; /* flags (section type and attributes)*/ uint32_t reserved1; /* reserved (for offset or index) */ uint32_t reserved2; /* reserved (for count or sizeof) */ uint32_t reserved3; /* reserved */&#125;; sectname section 名segname 该 section 所属的 segment 名addr 该 section 在内存的启始位置size 该 section 的大小offset 该 section 的文件偏移align 字节大小对齐reloff 重定位入口的文件偏移nreloc 需要重定位的入口数量flags 包含 section 的 type 和 attributes 可以通过 otool –s 查看某 segment 的某个 section： $ otool -s __TEXT __text WeChatWeChat (architecture armv7):Contents of (__TEXT,__text) section0000aff0 af03b5f0 8d04f84d f6444606 f2c070fe 0000b000 f644304d 447871fc 314df2c0 46904479 0000b010 68096800 680c6800 8000f846 b9955935 0000b020 70e8f644 304df2c0 68004478 58306800......... MachOView除了用 otool 查看 Mach-O 外，还可以通过 MachOView 可视化工具来查看MachOView下载地址：http://sourceforge.net/projects/machoview/MachOView源码地址：https://github.com/gdbinit/MachOView效果如下： 相关资料Mach-O-File-Format","categories":[],"tags":[]},{"title":"常用 git 命令总结","slug":"常用-git-命令总结","date":"2018-03-19T12:17:59.000Z","updated":"2018-06-15T07:41:41.247Z","comments":true,"path":"2018/03/19/常用-git-命令总结/","link":"","permalink":"https://github.com/caozhenwei/2018/03/19/常用-git-命令总结/","excerpt":"","text":"前言git 是什么它是一个版本控制工具。 版本控制是一种记录一个或若干个文件内容变化，以便将来查阅特定版本修订情况的系统。 想想当年写毕业论文的情况，写了一个最终版，发现不行，在原来的基础上又修改下重新存为“最终版1”、“最终版2”、“打死也不改版1”、“打死也不改版2”…。如果自己知道有 git 这种强大的版本控制工具呢，肯定不会存好多版本，打开好多版本，来来回回的复制粘贴，简直蠢的要死。git 是在商业公司 BitKeeper 停止与 Linux 开源社区合作后，由 Linux 开源社区开发的版本控制工具。 git 基础操作配置 git/etc/gitconfig 文件：系统中对所有用户都普遍适用的配置。若使用 git config 时用 --system 选项，读写的就是这个文件。 ~/.gitconfig 文件：用户目录下的配置文件只适用于该用户。若使用 git config 时用 --global 选项，读写的就是这个文件。 当前项目的 git 目录中的配置文件（也就是工作目录中的 .git/config 文件）：这里的配置仅仅针对当前项目有效。每一个级别的配置都会覆盖上层的相同配置，所以 .git/config 里的配置会覆盖 /etc/gitconfig 中的同名变量。 配置用户信息 $ git config --global user.name “你的名字\"$ git config --global user.email “你的邮箱” 检查配置信息 $ git config --list$ git config user.name //检查 git 的某一项配置，例如名字 gitignore 里配置需要忽略的文件。养成初始化就配置 gitignore 文件的习惯，要不每回 git status 的时候会看到一大堆没必要提交的文件，Xcode 里可以做如下配置： # Xcode## gitignore contributors: remember to update Global/Xcode.gitignore, Objective-C.gitignore &amp; Swift.gitignore## Build generatedbuild/DerivedData/## Various settings*.pbxuser!default.pbxuser*.mode1v3!default.mode1v3*.mode2v3!default.mode2v3*.perspectivev3!default.perspectivev3xcuserdata/## Other*.moved-aside*.xccheckout*.xcscmblueprint## Obj-C/Swift specific*.hmap*.ipa*.dSYM.zip*.dSYM# CocoaPods## We recommend against adding the Pods directory to your .gitignore. However# you should judge for yourself, the pros and cons are mentioned at:# https://guides.cocoapods.org/using/using-cocoapods.html#should-i-check-the-pods-directory-into-source-control## Pods/# Carthage## Add this line if you want to avoid checking in source code from Carthage dependencies.# Carthage/CheckoutsCarthage/Build# fastlane## It is recommended to not store the screenshots in the git repo. Instead, use fastlane to re-generate the# screenshots whenever they are needed.# For more information about the recommended setup visit:# https://docs.fastlane.tools/best-practices/source-control/#source-controlfastlane/report.xmlfastlane/Preview.htmlfastlane/screenshotsfastlane/test_output# Code Injection## After new code Injection tools there's a generated folder /iOSInjectionProject# https://github.com/johnno1962/injectionforxcodeiOSInjectionProject/ 更多的配置可以参考 这里。 获取 git 仓库在现有目录中初始化仓库$ git init 克隆现有的仓库$ git clone &lt;url&gt; 克隆一个带子模块的项目$ git clone &lt;url&gt;$ git submodule init$ git submodule update 基础命令用 git 管理文件后，对于任何一个文件，在 git 内都只有三种状态：已提交（committed），已修改（modified）和已暂存（staged）。 已提交:表示该文件已经被安全地保存在本地数据库中了； 已修改:表示修改了某个文件，但还没有提交保存； 已暂存:表示把已修改的文件放在下次提交时要保存的清单中。 文件流转的三个工作区域：git 的工作目录，暂存区域，以及本地仓库。从项目中取出某个版本的所有文件和目录，用以开始后续工作的叫做工作目录。这些文件实际上都是从 git 目录中的压缩对象数据库中提取出来的，接下来就可以在工作目录中对这些文件进行编辑。 所谓的暂存区域只不过是个简单的文件，一般都放在 git 目录中。有时候人们会把这个文件叫做索引文件，不过标准说法还是叫暂存区域。基本的 git 工作流程如下： 在工作目录中修改某些文件。 对修改后的文件进行快照，然后保存到暂存区域。 提交更新，将保存在暂存区域的文件快照永久转储到 Git 目录中。 $ git status //检查当前文件状态$ git add . //添加文件到暂存区$ git commit -m \"message\" //提交更新 其实 git add 的潜台词就是把目标文件快照放入暂存区域，也就是 add file into staged area，同时未曾跟踪过的文件标记为需要跟踪。这样就好理解后续 add 操作的实际意义了。它是一个多功能命令，可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等。 移除文件 $ git rm 文件 删除文件但是让文件留在磁盘上 $ git rm --cached README 查看提交历史 $ git log 用 oneline 将每个提交放在一行显示 $ git log --pretty=oneline 用 ASCII 字符串表示的简单图形，形象地展示了每个提交所在的分支及其分化衍合情况 git log --pretty=format:\"%h %s\" --graph format 常用的格式占位符写法及其代表的意义 选项 说明 %H 提交对象（commit）的完整哈希字串 %h 提交对象的简短哈希字串 %T 树对象（tree）的完整哈希字串 %t 树对象的简短哈希字串 %P 父对象（parent）的完整哈希字串 %p 父对象的简短哈希字串 %an 作者（author）的名字 %ae 作者的电子邮件地址 %ad 作者修订日期（可以用 -date= 选项定制格式） %ar 作者修订日期，按多久以前的方式显示 %cn 提交者(committer)的名字 %ce 提交者的电子邮件地址 %cd 提交日期 %cr 提交日期，按多久以前的方式显示 %s 提交说明 例如，列出所有最近两周内的提交：$ git log --since=2.weeks git log 支持的选项 选项 说明 -p 按补丁格式显示每个更新之间的差异 –stat 显示每次更新的文件修改统计信息 –shortstat 只显示 –stat 中最后的行数修改添加移除统计 –name-only 仅在提交信息后显示已修改的文件清单 –name-status 显示新增、修改、删除的文件清单 –abbrev-commit 仅显示 SHA-1 的前几个字符，而非所有的 40 个字符 –relative-date 使用较短的相对时间显示（比如，“2 weeks ago”） –graph 显示 ASCII 图形表示的分支合并历史 –pretty 使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format（后跟指定格式）。 撤消对文件的修改$ git checkout -- [file] 撤消对所有文件的修改$ git checkout -- . 或者 $ git checkout . 显示还没有暂存起来的改动，不是这次工作和上次提交之间的差异$ git diff 已经暂存起来的文件和上次提交时的快照之间的差异$ git diff --cached //git 1.6.1 及更高版本还允许使用 git diff --staged，效果是相同的 git 别名$ git config --global alias.st status 这意味着，当要输入 git status 时，只需要输入 git st。查看别名的位置可以使用上面提到的 git config -—list 命令。如果想要执行外部命令，可以在命令前面加入 ! 符号，操作如下：git config --global alias.ls '!ls' git 分支分支基础分支是 git 最大的亮点，也是它的杀手锏。git 的分支分为远程分支，远程跟踪分支和跟踪分支。 远程分支就是在远程仓库上的普通分支。 远程跟踪分支是在本地的只读的记录远程分支状态的分支，其指向用户无法移动，当你做任何网络通信操作时，它们会自动移动。 跟踪分支是从远程跟踪分支上生成的本地分支。 分支常用命令查看分支 $ git branch 分支创建 $ git branch 分支名 分支切换 $ git checkout 分支名 查看每一个分支的最后一次提交 $ git branch -v 查看哪些分支已经合并到当前分支 $ git branch —merged 查看所有包含未合并工作的分支$ git branch --no-merged 分支合并，如把 test 分支合并到 master 分支 $ git checkout master$ git merge test 查看分支历史 $ git log --oneline --graph 新建一个分支并同时切换到该分支上 $ git checkout -b 分支名 删除分支 $ git branch -d 分支名 查看当前配置有哪些远程仓库 $ git remote 显示对应的克隆地址 $ git remote -v 添加远程仓库 $ git remote add [shortname] [url] 推送数据到远程仓库 $ git push origin master 远程仓库的重命名 $ git remote rename a b 远程仓库的删除 $ git remote rm xxx 查看远端仓库的详细信息 $ git remote show origin 某个远程仓库在本地的简短名称，比如想把 pb 改成 paul $ git remote rename pb paul git tag打标签是我们经常用到的命令，通常是在发布新版本或者切换到以前的特定版本修改 bug 的时候用。git 使用两种主要类型的标签：轻量标签（lightweight）与附注标签（annotated）。轻量标签很像一个不会改变的分支，它只是一个特定提交的引用。附注标签是存储在 git 数据库中的一个完整对象。创建附注标签 $ git tag -a v1.4 -m 'my version 1.4’ 创建轻量标签 $ git tag v1.4-lw 后期打标签 $ git tag -a v1.2 9fceb02 （需要在命令的末尾指定提交的校验和或部分校验和） 列出标签 $ git tag 把标签推送到远程仓库服务器上 $ git push origin [tagname] 检出标签（也就是在特定的标签上创建一个新分支） $ git checkout -b version2 v2.0.0 参考链接https://git-scm.com/book/zh/v2","categories":[],"tags":[{"name":"开发","slug":"开发","permalink":"https://github.com/caozhenwei/tags/开发/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-03-19T00:57:22.000Z","updated":"2018-04-09T12:39:50.373Z","comments":true,"path":"2018/03/19/hello-world/","link":"","permalink":"https://github.com/caozhenwei/2018/03/19/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment /frac{7x+5}","categories":[],"tags":[{"name":"开发","slug":"开发","permalink":"https://github.com/caozhenwei/tags/开发/"}]},{"title":"春天里的故事","slug":"春天里的故事","date":"2018-03-19T00:57:22.000Z","updated":"2018-06-15T07:31:50.088Z","comments":true,"path":"2018/03/19/春天里的故事/","link":"","permalink":"https://github.com/caozhenwei/2018/03/19/春天里的故事/","excerpt":"","text":"春天的颜色真是五彩缤纷，太阳是红灿灿的，天空是湛蓝的，树梢是嫩绿的，迎春花是娇黄的……难怪诗人爱吟咏春天，画家爱描绘春天，因为春天是世界一切美的融合，一切色彩的总会。 我的小情人喔！ 调皮的小宝宝 我也来逛逛吧 春天的水，平平的，静静的。春天的水，没有风的时候就像一面平滑的玻璃镜子一样。有风时，春天的水，在阳光的照耀下，泛起水波，闪闪发光，就像春姑娘佩戴的闪亮亮的头饰一样。春天的水，流过庄稼、田地，悄悄地给足充分的营养。春天的水活了，便孕育了一批批新的生命——鱼儿欢快地在水中游来游去。 可和宝妈 我现在最爱的玩具就它了！ 我很奇怪，这五彩缤纷的色彩为什么会不约而同地选择春天来到大地?每个人都有春天。无论是你，或者是我，每个人在春天里都可以有欢笑，有爱情，有陶醉。 小狗狗回头","categories":[],"tags":[{"name":"生活","slug":"生活","permalink":"https://github.com/caozhenwei/tags/生活/"}]},{"title":"使用 hexo 搭建 blog","slug":"使用-hexo-搭建-blog","date":"2018-03-17T06:13:28.000Z","updated":"2018-06-19T08:44:56.294Z","comments":true,"path":"2018/03/17/使用-hexo-搭建-blog/","link":"","permalink":"https://github.com/caozhenwei/2018/03/17/使用-hexo-搭建-blog/","excerpt":"","text":"背景上篇文章刚介绍用了 Octopress 搭建 blog，这边又用 hexo 来搭建 blog，到底是几个意思？你过来，我保证不打死你！问起原因，只能说 Octopress 构建的时候有些慢并且我不喜欢它的主题（虽然它的主题很多，不喜欢就不喜欢呗，还找这么多理由干什么）。下面开始介绍怎么用 hexo 搭建 blog。 本机相关环境macOS High Sierra 10.13.3 node v8.10.0 npm 5.6.0 git version 2.14.3 (Apple Git-98) 安装 Hexo什么是 Hexo？Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 需要的环境Node.js 和 Git 安装 Hexo$ npm install -g hexo-cli 初始化 $ hexo init &lt;folder&gt; 进入初始化的文件夹 $ cd &lt;folder&gt; 安装相关模块 $ npm install 在 _config.yml 中配置相关的信息 写文章$ hexo new [layout] &lt;title&gt;$ hexo generate$ hexo server 2018.6.15添加可以用草稿的方式暂时不发布那些还没有写完的文章，具体的操作是指定 layout 为 draft，这种布局在建立时会被保存到 source/_drafts 文件夹，可通过 publish 命令将草稿移动到 source/_posts 文件夹，该命令的使用方式与 new 十分类似，您也可在命令中指定 layout 来指定布局。如果你希望强行预览草稿，更改配置文件render_drafts: true 或者用如下方式启动 server ：hexo server --drafts 。 然后就能在 http://localhost:4000 看到效果了 部署到 github 上创建相关的仓库到 github 上创建一个 username.github.io 的 rep $ hexo-deployer-git.$ npm install hexo-deployer-git --save$ hexo deploy 美化主题1.clonegit clone https://github.com/Haojen/hexo-theme-Anisina.git themes/Anisina 2.配置修改 _config.yml 中的 themes 为 Anisina 即可。 评论注册来必力，在 _config.yml 中增加相应的 id 。 图片地址在配置中经常要用到某一张图片的 url ，这是我们可以把图片传到 github 的仓库中，然后在仓库中查看图像即可获得相应的图片的 url 。 社交平台的配置github 只需要用户名就行。微博的可以在设置中配置个性域名，然后把个性域名配置到 _config.yml 中。 番外Node.js 是什么？ Node.js 就是运行在服务端的 JavaScript。Node.js 是一个基于 Chrome JavaScript 运行时建立的一个平台。Node.js 是一个事件驱动 I/O 服务端JavaScript 环境，基于 Google 的 V8 引擎，V8 引擎执行 Javascript 的速度非常快，性能非常好。 用 Homebrew 装 Node.js 安装 Homebrew/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" 安装 Node.jsbrew install node 参考链接hexo 官网、来必力评论模块、Anisina 主题","categories":[],"tags":[]},{"title":"用 Octopress 搭建属于自己的 github 博客 ","slug":"用-Octopress-搭建属于自己的-github-博客","date":"2018-03-16T08:02:58.000Z","updated":"2018-06-15T07:17:18.334Z","comments":true,"path":"2018/03/16/用-Octopress-搭建属于自己的-github-博客/","link":"","permalink":"https://github.com/caozhenwei/2018/03/16/用-Octopress-搭建属于自己的-github-博客/","excerpt":"本文章介绍了自己用 Octopress 搭建 blog 的过程，其中查了好多资料，看了好多文章，也走了不少弯路。现在记录下来，方便后人学习，自己也做个备忘。废话不多说，开工！","text":"本文章介绍了自己用 Octopress 搭建 blog 的过程，其中查了好多资料，看了好多文章，也走了不少弯路。现在记录下来，方便后人学习，自己也做个备忘。废话不多说，开工！ 搭建 blog 时的本机环境macOS High Sierra (10.13.3) ruby 2.3.1p112 gem 2.5.1 bundle 1.16.1 git version 2.14.3 (Apple Git-98) 安装 Octopress什么是 Octopress ？ Octopress 是一个基于 Ruby 的开源 Blogging Framework，从写 blog，到发布，你完全可以用 Shell 里面的命令搞定。这样，写起 Blog 来，会让技术控们觉得很有成就感。。。 安装 Octopress $ git clone git://github.com/imathis/octopress.git octopress$ cd octopress 因为墙的原因，所以要修改 gem 的 source $ gem sources --add https://ruby.taobao.org/ --remove https://rubygems.org/$ gem sources -l 请确保只有 ruby.taobao.org 安装依赖 $ gem install bundler$ bundle install 安装默认的 Octopress 主题$ rake install 在 github 上创建仓库到 github 上创建仓库到 github 上创建一个 username.github.io 的 repo，比如我的github 名字为 caozhenwei ，我就创建了一个名字为 caozhenwei.github.io 的仓库。 完成 github 和 Octopress 的关联执行下面的命令并依照提示完成 github 和 Octopress 的关联 $ rake setup_github_pages(For example, 'git@github.com:your_username/your_username.github.io.git) or 'https://github.com/your_username/your_username.github.io')//比如我的我就输入如下： git@github.com: caozhenwei/caozhenwei.github.io.git 创建配置生成博客 $ rake generate$ rake deploy 生成后 push 到 github 上，在这之前需要配置下 SSH Key。在终端下输入 $ ssh-keygen -t rsa -C \"邮箱地址\" 按三次回车即可，成功后就可以在用户目录下找到 .ssh 目录，里面有 id_rsa 和 id_rsa.pub 两个文件，把 id_rsa.pub 放到 github 的 SSH keys 即可。 git 用户账户信息的配置： $ git config --global user.name \"你的github用户名\"$ git config --global user.email \"你的github邮箱地址\" 然后再提交： $ git add .$ git commit -m 'create blog'$ git push origin source 完成后等待几秒就能访问 http://username.github.io 看到自己的博客了。 当然，你也可以在 push 到 github 上之前先在本地预览一下，命令如下$ rake preview 你可以在本地的浏览器里打开 localhost:4000 来预览生成的 blog 。 安装第三方主题如果你喜欢上面的默认的主题，这里的步骤就没必要执行了。我比较 abacus 主题，下面是安装步骤：$ cd octopress$ git clone https://github.com/bhrigu123/abacus.themes/abacus$ rake install['abacus']$ rake generate 到这一步，你的 blog 已经基本搭建完了，终于能写了。blog 是用 Markdown 语言来写的。Markdown 是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。在 mac 下可以使用 MacDown 软件来写。想下载 MacDown 点我。需要更多的主题点我。 开始写 blog：$ rake new_post['title'] ＃title 是你要写的 blog 的标题 执行完上面的命令后会在 source/_posts 下面生成 xxx.markdown 文件，我们的 blog 就在 xxx.markdown 中编写。编写完后执行： $ rake generate$ rake preview //在浏览器输入： localhost:4000 在本地先预览效果，满意后在 push 到 github 上。$ git add .$ git commit -m \"comment\" $ git push origin source$ rake deploy 折腾后的收获在执行 gem install bundler的时候，一会儿切换源，一会说 ruby 版本不对。看来是对 gem 不熟悉。那什么是RubyGems？RubyGems 是一个方便而强大的 Ruby 程序包管理器，Ruby 的第三方插件是用 gem 方式来管理，非常容易发布和共享，一个简单的命令就可以安装上第三方的扩展库。特点：能远程安装包，包之间依赖关系的管理，简单可靠的卸载，查询机制，能查询本地和远程服务器的包信息，能保持一个包的不同版本，基于 Web 的查看接口，能查看你安装的 gem 的信息。Ruby1.9.1 以后的版本自带 RubyGems。要切换 ruby 版本用什么好呢？笔者刚开始用了 rvm, 后来又用了 rbenv。安装的时候又用到了 homebrew。本着 生命不息，折腾不止的精神，重新的学习了以上各命令的用法。常用方法如下： rvm 常用命令 rvm remove ruby-1.8.7 --docs —gems ＃删除某个版本的ruby，并且把文档和gems都删除rvm use ruby-1.8.7 --default ＃选择版本rvm info ＃查询当前版本rvm list ＃列出版本rvm implode ＃删除rvm命令 rbenv 常用命令 rbenv install --list ＃列出所有可以安装的Ruby版本rbenv install version ＃version是具体要安装的版本，在上面列出的可以安装的目录中选择一个rbenv versions ＃查看本地安装的ruby版本rbenv global version #设置全局使用的ruby版本rbenv shell version ＃设置在当前shell中使用的ruby版本，生成了一个RBENV_VERSION的变量rbenv local version ＃设置在当前目录中的ruby版本，会在当前目录下生成.rbenv-version文件。rbenv uninstall 2.00 #卸载指定ruby版本rbenv rehash #每当安装新的 Ruby 版本，或 gem 都要运行一下，不然有可能会出现新安装的不起作用的现象 Homebrew 常用命令 brew uninstall rbenv ＃卸载rbenvbrew list ＃列出已安装的软件brew update ＃更新brewbrew home ＃用浏览器打开 brew 的官方网站brew info ＃显示软件信息brew deps ＃ 显示包依赖 参考链接Octopress 的配置、Octopress 主题、RubyGems 镜像、homebrew、homebrew 官网、rbenv、rvm","categories":[],"tags":[{"name":"开发","slug":"开发","permalink":"https://github.com/caozhenwei/tags/开发/"}]}]}