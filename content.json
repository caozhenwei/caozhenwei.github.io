{"meta":{"title":"caozhenwei","subtitle":null,"description":"caozhenwei 在 Github 上的个人博客","author":"caozhenwei","url":"https://github.com/caozhenwei"},"pages":[{"title":"Tags","date":"2018-03-21T11:44:58.000Z","updated":"2018-03-22T03:36:37.824Z","comments":true,"path":"Tags/index.html","permalink":"https://github.com/caozhenwei/Tags/index.html","excerpt":"","text":"123333"},{"title":"about","date":"2018-03-22T02:33:25.000Z","updated":"2018-03-22T03:43:01.345Z","comments":true,"path":"about/index.html","permalink":"https://github.com/caozhenwei/about/index.html","excerpt":"","text":""}],"posts":[{"title":"汇编--中断（10）","slug":"汇编-中断（10）","date":"2018-12-10T02:55:47.000Z","updated":"2018-12-10T02:56:11.775Z","comments":true,"path":"2018/12/10/汇编-中断（10）/","link":"","permalink":"https://github.com/caozhenwei/2018/12/10/汇编-中断（10）/","excerpt":"任何一个通用的 CPU ，比如 8086 都具备这样一种能力，检测从 CPU 内部或者外部发过来的一种信息，并且可以立即对收到的信息进行处理。这种信息就是我们常说的中断信息。从 CPU 内存产生的这种信息称为内中断，从 CPU 外部产生的这种信息称为外中断。","text":"任何一个通用的 CPU ，比如 8086 都具备这样一种能力，检测从 CPU 内部或者外部发过来的一种信息，并且可以立即对收到的信息进行处理。这种信息就是我们常说的中断信息。从 CPU 内存产生的这种信息称为内中断，从 CPU 外部产生的这种信息称为外中断。 对于 8086CPU，内部有下面的情况发生后，将产生相应的中断信息： 除法错误 单步执行 执行 int0 指令 执行 int 指令 我们将产生中断信息的事件，即中断信息的来源称为中断源。中断信息中包含识别来源的编码，这个编码为一个字节型数据，可以表示 256 种中断源。上述 4 种中断源，在 8086 中的中断类型码如下： 除法错误：0 单步执行：1 执行 int0：4 执行 int 指令，该指令的格式为 int n ，指令中的 n 为字节型立即数，是提供给 CPU 的中断类型码 CPU 收到中断信息后，需要对中断信息进行处理，这个可以由我们编写代码来确定。用来处理中断的程序被称为中断处理程序。可以设置 CS：IP 的值来执行我们编写的中断处理程序。问题在于中断信息中只有一个中断类型码，怎么来设置 CS：IP 呢？CPU 用 8 位的中断类型码可以从中断向量表中找到对应的 CS 和 IP。中断向量就是中断处理程序的入口，即 CS 和 IP 的值，中断向量表就是中断处理程序入口的列表。可见 CPU 只要知道了中断类型码，就可以通过查找中断向量表找出对应的中断处理程序入口。 中断可能随时发生，要想在发生中断时去执行中断处理程序，那么在发生中断前中断处理程序就应该放在某个地方等待执行。对于 8086PC 机，中断向量表指定放在内存地址 0 处，从内存 0000:0000 ~ 0000:03e8 的 1000 个单元中。 中断过程下面描述的 8086CPU 的中断过程 取得中断类型码 标志寄存器入栈 设置标志寄存器的 TF 和 IF（在进入中断处理程序后禁止其它可屏蔽中断） 为 0 CS 的内容入栈 IP 的内容入栈 从中断向量表中找到入口设置 CS 和 IP int 指令格式为 int n，功能为引发中断过程。 BIOS 和 DOS 中断安装过程 CPU 一加电，初始化 CS：IP 为 0FFFFH：0，自动从 FFFF：0 这个单元执行程序。 FFFF：0 处有一条跳转指令，转去执行 BIOS 中的硬件系统检测和初始化程序。 初始化程序建立 BIOS 中断向量表，它是固化在 ROM 中的程序，一直存在内存中。 硬件系统检测和初始化完成后，调用 19h 进行操作系统的引导。 DOS 启动后，除完成其它工作外，还将它提供的中断向量表装入内存。 端口在 PC 机系统中，和 CPU 通过总线相连的芯片除各种寄存器外，还有以下 3 种芯片 各种接口卡（网卡、显卡）上的接口芯片，它们控制接口卡进行工作 主板上的接口芯片，CPU 通过它们对部分外设进行访问 其它芯片，用来存储相关系统信息 在上述的这些芯片中，都有一组可以由 CPU 读写的寄存器。CPU 对它们进行读或写的时候都通过控制线向它们所在的芯片发出端口读写命令。 端口的读写只有两条指令 in 和 out ，分别表示从端口读数据和写数据。 外中断外中段分为以下两种： 可屏蔽中断 不可屏蔽中断 可屏蔽中断是当中断到来时，CPU 可以不处理中断。CPU 是否响应可屏蔽中断，要看标志寄存器 IF 位的设置。如果 IF = 1，则 CPU 执行完当前指令后响应中断，如果 IF = 0，则不响应可屏蔽中断。 不可屏蔽中断的中断类型码固定为 2 。","categories":[],"tags":[]},{"title":"汇编--标志寄存器（9）","slug":"汇编-标志寄存器（9）","date":"2018-12-07T09:24:08.000Z","updated":"2018-12-08T06:29:39.068Z","comments":true,"path":"2018/12/07/汇编-标志寄存器（9）/","link":"","permalink":"https://github.com/caozhenwei/2018/12/07/汇编-标志寄存器（9）/","excerpt":"8086 CPU 内部有 14 个 16 位寄存器，前面已经已经学习了 AX、BX、CX、DX、CS、DS、SS、ES、SI、DI、IP、SP、BP 这 13 个寄存器，还差一个，这就是本篇要介绍的标志寄存器，简称 flag。","text":"8086 CPU 内部有 14 个 16 位寄存器，前面已经已经学习了 AX、BX、CX、DX、CS、DS、SS、ES、SI、DI、IP、SP、BP 这 13 个寄存器，还差一个，这就是本篇要介绍的标志寄存器，简称 flag。 flag 寄存器是一个特殊的寄存器，它是按位起作用的，它具有 3 种作用： 用来存储相关指令的某些执行结果 用来为 CPU 执行相关指令提供行为依据 用来控制 CPU 的相关工作方式 8086CPU 的 flag 寄存器结果如下所示： 下图是各个标志位的简介（图片来自百度百科）： CF进位标志，在无符号数进行运算的时候，它记录了运算结果的的最高位进位或借位的情况。 adc 是带进位加法指令，利用了 CF 上的进位值 指令格式： adc 操作对象1，操作对象2 功能：操作对象1 = 操作对象1 + 操作对象2 + CF 利用这个我们可以实现任意位数的数相加。 sbb 是带借位减法指令，利用了 CF 上记录的借位值，利用这个指令可以计算任意两个数的减法。 通过学习 adc 和 sbb 指令能使我们更好的认识 CF 标志位。 PF奇偶标志位，它记录了相关指令执行后，其结果的所有二进制位中 1 的个数是否为偶数，如果 1 的个数为偶数，PF = 1，如果为奇数，PF = 0。 AF算数操作结果的第三位（从0开始计数）如果产生了进位或者借位则将其置为1，否则置为0，常在BCD(binary-codedecimal)算术运算中被使用。 ZF零标志位，它记录了相关指令执行后，其结果是否为 0 ，结果为 0 则 ZF = 1，结果不为 1 则 ZF = 0。 SF符号标志位，它记录了相关指令执行后，其结果是否为负。当我们将数据当做有符号数来计算的时候，它记录结果的正负，如果为负则 SF = 1，不为负则 SF = 0。如果把数据当做无符号数来计算，则 SF 标志无意义。 TF当TF被设置为1时，CPU进入单步模式，所谓单步模式就是CPU在每执行一步指令后都产生一个单步中断。主要用于程序的调试。8086/8088中没有专门用来置位和清零TF的命令，需要用其他办法。 IF决定CPU是否响应外部可屏蔽中断请求。IF为1时，CPU允许响应外部的可屏蔽中断请求。 DF方向标志位，在串处理指令中，控制每次操作后 si 和 di 的增减 DF = 0，每次操作后 si 和 di 递增 DF = 1，每次操作后 si 和 di 递减 串传送指令 movsb ，执行后相当于如下操作 把 DS：[si] 中的一个字节送入 ES：[di] 中 如果 DF = 0，si 和 di 的值递增 1 串传送指令 movsw ，它的功能和 movsb 差不多，只不过它每次传送一个字，具体功能为将 DS：[si] 指向内存的字单元送入 ES:[di] 中，根据 DF 的值将 si 和 di 递增或者递减 2。 OF溢出标志位，记录了有符号数运算结果是否发生了溢出。如果发生溢出，OF = 1，没有的话则 OF = 0 。 类似于高级语言中的逻辑判断在高级语言中我们可以使用 if 和 else 来进行逻辑判断，那么汇编能实现类似的功能吗？必须的可以啊，在讲解之前先来学习下 cmp 指令和一系列检测比较结果的条件转移指令。 cmp 指令是比较指令，相当于减法指令，只是不保存结果，将对标志寄存器产生影响。例如下面的指令： mov ax,8mov bx,3cmp ax,bx 执行后 ax 中的值仍为 8，ZF=0（执行后结果不为0）,PF=1（执行后结果为5，即101中1的个数为偶数），CF=0（没有发生进位或借位），OF=0（没有发生溢出）。 检测比较结果的条件指令如下所示 指令 含义 检测的相关标志位 je 等于则转移 ZF=1 jne 不等于则转移 ZF=0 jb 低于则转移 CF=1（发生借位） jnb 不低于则转移 CF=0（没有发生借位） ja 高于则转移 CF=0且ZF=0（没有借位且结果不为0） jna 不高于则转移 CF=1或ZF=1（有借位或执行结果为0） 上面的指令很好记，根据英文意思便可知道要表达的意思 e：equal ne：not equal b：blow nb：not blow a：above na：not above 可以用 cmp 指令和一系列检测比较结果的条件转移指令来实现类似于高级语言中的逻辑判断，例子：实现如下功能 if (ah == bh) &#123; ah = ah + ah&#125; else &#123; ah = ah + bh&#125; 核心汇编代码如下： cmp ah,bh je s add ah,bh jmp short s1s: add ah,ahs1: ... pushf 和 popfpushf 是将标志寄存器的值压栈 popf 是将标志寄存器的值出栈 有了这两个指令就能和上篇中执行子程序前将标志寄存器的内容压栈，等待子程序执行完后再将栈中的数据恢复到标志寄存器中。 debug 中标志寄存器的表示方法标志寄存器在 debug 中的表示不像其它寄存器那么直观，它是按位展示的，在 9 个标志位中 TF 没有表示出来，其它 8 个位的表示如下所示：","categories":[],"tags":[]},{"title":"汇编--ret和call指令（8）","slug":"汇编-ret和call指令（8）","date":"2018-12-07T08:25:42.000Z","updated":"2018-12-07T08:32:39.763Z","comments":true,"path":"2018/12/07/汇编-ret和call指令（8）/","link":"","permalink":"https://github.com/caozhenwei/2018/12/07/汇编-ret和call指令（8）/","excerpt":"ret 和 call 指令都是转移指令，它们都修改 IP，或同时修改 CS 和 IP，经常用它们来共同完成子程序的设计","text":"ret 和 call 指令都是转移指令，它们都修改 IP，或同时修改 CS 和 IP，经常用它们来共同完成子程序的设计 ret 和 retf 指令ret 指令用栈中的内容来修改 IP，实现近转移。 retf 指令用栈中的数据来修改 CS 和 IP 内容来实现远转移。 CPU 执行 ret 指令时相当于 pop ip CPU 执行 retf 指令时相当于 pop ip pop cs 下面的程序 ret 指令执行后，CS：IP 执行代码段的第一条指令 assume cs:codesg,ss:stackstack segment db 16 dup (0)stack endscodesg segment mov ax,4c00h int 21h start: mov ax,stack mov ss,ax mov sp,16 mov ax,0 push ax mov bx,0 ret codesg endsend start 在 debug 中可以清楚的看到当执行完 ret 指令后，CS：IP 指向了程序的第一条指令。 下面的程序 retf 指令执行后，CS：IP 执行代码段的第一条指令 assume cs:codesg,ss:stackstack segment db 16 dup (0)stack endscodesg segment mov ax,4c00h int 21h start: mov ax,stack mov ss,ax mov sp,16 mov ax,0 push cs push ax mov bx,0 retf codesg endsend start 在 debug 中可以清楚的看到当执行完 retf 指令后，CS：IP 指向了程序的第一条指令。 call 指令执行 call 指令时，进行两步操作： 将当前的 IP 或 CS 和 IP 压入栈中 转移 call 指令不能实现短转移。 依据位移进行转移的 call 指令call 标号（将当前的 IP 压入栈后再跳到标号处执行） 执行 “call 标号” 相当于一下两步操作 push IP jmp near ptr 标号 转移的目的地址在指令中的 call 指令指令 “call far ptr 标号” 实现的段间转移，CPU 在执行时相当于以下 3 步操作： push CS push IP jmp far ptr 标号 转移地址在寄存器中的 call 指令指令 “call 16位寄存器” 被 CPU 执行时，相当于以下 2 步操作： push IP jmp 16位寄存器 转移地址在内存中的 call 指令转移地址在内存中的 call 指令有两种格式 call word ptr 内存单元地址 CPU 在执行上述指令的时候相当于以下 2 步： push IP jmp word ptr 内存单元地址 比如下面的代码： assume cs:codesgcodesg segment mov sp,10H mov ax,0123H mov ds:[0],ax call word ptr ds:[0] mov ax,4c00h int 21hcodesg endsend 在执行完 “call word ptr 内存单元” 后相当于执行了 “push ip” 和 “jmp word ptr 内存单元地址” 两条指令，push 后栈顶要向上移动 2 个单元，即 sp 中的值减 2（10H - 2 = 0EH）。“jmp word ptr 内存单元地址” 相当于用内存单元中的值去修改 IP，执行后 IP 为 0123H（“jmp word ptr 内存单元地址” 忘了的话返回前面的文章复习一下）。在 debug 中可以清楚的看到结果。 call dword ptr 内存单元地址 CPU 在执行上述指令的时候相当于以下 2 步操作： push cs push ip jmp dword ptr 内存单元地址 例如下面的代码 assume cs:codesgcodesg segment mov sp,10H mov ax,0123H mov ds:[0],ax mov word ptr ds:[2],0 call dword ptr ds:[0] mov ax,4c00H int 21Hcodesg endsend 执行 “call dword ptr ds:[0]” 后，cs 的值为 0 ，ip 为 0123H，sp 为 0ch，在 debug 中显示如下： call 和 ret 的配合使用我们知道使用 call 指令的时候会先进行入栈操作，然后再跳到标号处去执行程序，ret 是用栈中的数据去修改 IP 或 CS 和 IP 来达到控制 CPU 执行指令的目的，这样就可以用 call 和 ret 指令来实现调用子程序的目的。例如下面的程序是调用子程序来实现 2 的 3 次方并将结果存放到 bx 中： assume cs:codesgcodesg segment mov ax,1 mov cx,3 call s mov bx,ax mov ax,4c00h int 21Hs: add ax,ax loop s retcodesg endsend 执行完后，我们看到 bx 中内容为 8 ，是我们希望得到的结果，在 debug 中显示如下： 一些思考上面的程序中我们没有向子程序中传递参数，那怎么实现向子程序传递参数呢？我们可以用一个寄存器来传递，即调用者将要传递的参数放到某个合法的寄存器中，子程序执行的时候来修改这个寄存器，这样就实现了传递参数并返回的功能。那么要传递一堆参数给子程序该怎么办呢？其实可以把这堆参数放到内存里，寄存器只保留这个内存的首部地址即可。要是调用者和子程序都使用了相同的寄存器，这岂不是混乱了？一般的做法是在调用子程序的时候把寄存器的值都入栈，等到子程序返回时再把出栈来恢复主程序寄存器的值。","categories":[],"tags":[]},{"title":"汇编--转移指令（7）","slug":"汇编-转移指令（7）","date":"2018-12-07T06:30:18.000Z","updated":"2018-12-07T06:30:46.655Z","comments":true,"path":"2018/12/07/汇编-转移指令（7）/","link":"","permalink":"https://github.com/caozhenwei/2018/12/07/汇编-转移指令（7）/","excerpt":"本篇主要介绍 8086CPU 的转移指令。","text":"本篇主要介绍 8086CPU 的转移指令。 转移指令修改 IP 或 同时修改 CS 和 IP 的指令称为转移指令。也就是说转移指令是能控制 CPU 执行内存中某处代码的指令。 8086CPU 转移行为分类： 只修改 IP ，称为段内转移，例如：jmp ax 根据转移指令对 IP 修改范围，段内转移又可以分为： 短转移：修改范围为 -128 ~ 127，2^7 = 128 近转移：修改范围为 -32768 ~ 32767，2^15 = 32768 同时修改 CS 和 IP ，称为段间转移，例如：jmp 1000:0 依据位移进行转移的 jmp 指令jmp short 标号（转到标号处执行指令） 8 位位移 = “标号”处的地址 - jmp 指令后的第一个字节的地址 short 指明此处的位移为 8 位位移 8 位位移的范围为 -128 ～ 127 ，用补码表示 8 位位移由编译程序在编译时算出 jmp near ptr 标号 16 位位移 例如下面的程序: assume cs:codesgcodesg segment start: mov ax,0 ;长度为3 jmp short s ;长度为2 add ax,1 ;长度为3 s: inc ax ;长度为1 mov ax,4c00h int 21H codesg endsend start 当程序执行完后 ax 中的内容为 1 ，因为执行 jmp short s 后跳过了 add ax，1。从 debug （下图所示）中可以清楚的看到 jmp short s 直接由编译器编译成了 jmp 0008。来验证一下上面的计算方法 “8 位位移 = “标号”处的地址 - jmp 指令后的第一个字节的地址”，标号处的偏移地址为 8（3+2+3） ，jmp 指令后的第一个字节的地址为 5（3+2），即 8 位位移为 3，也就是下图中 jmp 处对应的机器码 EB03 中的 03。 我们在上面的 jmp 指令前后各加一条指令再来验证下，代码如下： assume cs:codesgcodesg segment start: mov ax,0 ;长度为3 mov bx,0 ;长度为3 jmp short s ;长度为2 add ax,1 ;长度为3 add ax,1 ;长度为3 s: inc ax ;长度为1 mov ax,4c00h int 21H codesg endsend start 标号处的偏移地址为 14，jmp 指令后的第一个字节的地址为 8，则 8 位位移为 6。如下图所示。 “jmp near ptr 标号” 和 “jmp short 标号” 的功能相近，实现的段内近转移，它的功能为： 16 位位移 = “标号”处的地址 - jmp 指令后的第一个字节的地址 near ptr 指明此处的位移为 16 位位移 16 位位移的范围为 -32768 ～ 32767 ，用补码表示 16 位位移由编译程序在编译时算出 转移的目的地址在指令中的 jmp 指令“jmp far ptr 标号” 实现的是段间转移，也称为远转移，功能如下： （CS）= 标号处所在段的段地址 （IP）= 标号在段中的偏移地址 far ptr 表明了指令用标号段的段地址和偏移地址来同时修改 CS 和 IP。代码如下所示： assume cs:codesgcodesg segment start: mov ax,0 mov bx,0 jmp far ptr s db 256 dup (0) s: add ax,1 inc ax mov ax,4c00h int 21H codesg endsend start 在 debug 中能够清楚的看到 jmp far ptr s 要跳转的段地址和偏移地址 转移地址在内存中的 jmp 指令转移地址在内存中的 jmp 指令有两种方式： jmp word ptr 内存单元地址（段内转移） jmp dword ptr 内存单元地址（段间转移） “jmp word ptr 内存单元地址” 的功能是从内存单元地址开始处存放着一个字，是转移的偏移地址。 “jmp dword ptr 内存单元地址” 的功能是从内存单元地址开始处存放着两个字节，高地址处的字是转移的目的段地址，低地址处是转移的目的偏移地址。 jcxz 指令jcxz 是条件转移指令，指令格式为：jcxz 标号（如果 cx 的值为 0，跳到标号处执行），所有的条件转移指令都是短转移。 loop 指令loop 指令为循环指令，指令格式为：loop 标号 （如果 cx 的值为不为 0 ，跳到标号处执行），所有的循环指令都是短转移。","categories":[],"tags":[]},{"title":"汇编--div、dup、offset（6）","slug":"汇编-div、dup、offset（6）","date":"2018-12-07T06:26:32.000Z","updated":"2018-12-07T06:27:02.688Z","comments":true,"path":"2018/12/07/汇编-div、dup、offset（6）/","link":"","permalink":"https://github.com/caozhenwei/2018/12/07/汇编-div、dup、offset（6）/","excerpt":"本次介绍指令要处理的数据长度，div 指定，dup 和 offset 操作符等相关知识。","text":"本次介绍指令要处理的数据长度，div 指定，dup 和 offset 操作符等相关知识。 指令要处理的数据长度指令要处理的数据有多长呢？汇编语言通过以下方法来处理： 1.通过寄存器名称 例如下面的指令表明是字操作 mov ax，1mov bx，[0] 而下面的指令则表明是字节操作 mov al，1mov al，[0] 2.在没有寄存器名称存在的情况下，用操作符 X ptr 指明内存单元的长度，X 可以是 word 或 byte。 例如下面的指令表明的是字操作 mov word ptr ds:[0]，1add word ptr [bx]，2 而下面的指令表明的是字节操作 mov byte ptr ds:[0]，1add byte ptr [bx]，2 3.其它方法 例如 push 和 pop 指令只能进行字操作。 div 指令div 是除法指令，在使用 div 的时候： 被除数默认放在 ax 或 dx 和 ax 中，这个由除数决定。如果除数为 8 位，被除数则为 16 位，默认在 ax 中存放；如果除数为 16 位，则被除数为 32 位，在 dx 和 ax 中存放，dx 存储高 16 位，ax 存储低 16 位。 除数有 8 位和 16 位两种，存放在寄存器或内存中 商：如果除数为 8 位，则 al 存储商，ah 存储余数；如果除数为 16 位，则 ax 存储商，dx 存储余数 div 使用举例：计算 100001/100，100001 大于 65525，只能放在 dx 和 ax 中存储，dx 存放高 16 位，ax 存放低 16 位，100001 转换为 16 进制为 186a1H，则 dx 中存放高 16 位，即 dx 存放 1H，ax 存放低 16 ，即 86a1H，商存放在 ax 中，dx 存放 余数，通过口算可知商为 1000，表示成 16 进制为 03e8H，余数为 1， 代码如下： assume cs:codesgcodesg segmentmov dx,1mov ax,86a1Hmov bx,100div bxcodesg endsend 验证结果： dupdup 是一个操作符，和 db、dw、dd 配和使用用来定义重复的数据。例如 db 3 dup (0) 表示定义了 3 个字节，值都为 0，相当于 db 0,0,0 操作符 offsetoffset 是编译器要处理的符号，意义为取得标号处的偏移地址。例如下面的代码 assume cs:codesgcodesg segment start: mov ax,offset start s: mov ax,offset s mov ax,4c00h int 21H codesg endsend start mov ax,offset start 相当于 mov ax，0 mov ax,offset s 相当于 mov ax，3 在 debug 中可以得到验证： 如果没有 debug ，怎么能判判断处标号处的偏移地址呢，可知关键的是要知道指令的长度，指令的长度的判断有以下方法： 没有操作数的指令，指令长度为 1 字节。如：es ，ds，cbw，xlat 等 操作数只涉及寄存器的指令，指令长度为 2 字节。如：mov al,[si]、mov ax,[bx+si]、mov ds,ax 等 操作数涉及内存地址的指令，指令长度为 3 字节。如：mov al,[bx+1]、mov ax,[bx+si+3]、lea di,[1234]、mov [2345],ax 等 操作数涉及立即数的指令，指令长度为：寄存器类型 + 1。8 位寄存器，寄存器类型 = 1；16 位寄存器，寄存器类型 =2。如 ：mov al,8 ;指令长度为 2，mov ax,8 ;指令长度为 3 跳转指令，分3种情况，指令长度分别为 2、3、5 字节。 段内跳转，指令长度 =（目标地址-指令当前地址）+1。 目标地址 - 指令当前地址若能用 1 个字节表示，则占用 1 个字节，整体指令长度为2字节，如 0113 jmp 0185 ;0185h-0113h = 72h，72h 可用 1 个字节表示，整体指令长度为2字节; 目标地址 - 指令当前地址若能用 2 个字节表示，则占用 2 个字节，整体指令长度为 3 字节，如 0113 jmp 0845 ;0845h-0113h = 732h，732h 需用 2 个字节表示 段间跳转，指令长度为 5 字节。如:jmp 1234:5678","categories":[],"tags":[]},{"title":"汇编--多个段的使用和寻址方式（5）","slug":"汇编-多个段的使用和寻址方式（5）","date":"2018-12-07T02:42:38.000Z","updated":"2018-12-07T02:46:20.582Z","comments":true,"path":"2018/12/07/汇编-多个段的使用和寻址方式（5）/","link":"","permalink":"https://github.com/caozhenwei/2018/12/07/汇编-多个段的使用和寻址方式（5）/","excerpt":"本篇介绍在汇编中使用多个段编写代码以及更多的寻址方式。","text":"本篇介绍在汇编中使用多个段编写代码以及更多的寻址方式。 栈的使用利用栈将程序中定义的数据逆序存放，代码如下： assume cs:codesgcodesg segment dw 0001H,0002H,0003H,0004H,0005H,0006H,0007H,0008H dw 0,0,0,0,0,0,0,0 start: mov ax,cs mov ss,ax mov sp,32 mov bx,0 mov cx,8 s: push cs:[bx] add bx,2 loop s mov bx,0 mov cx,8 s0: pop cs:[bx] add bx,2 loop s0 mov ax,4c00h int 21H codesg endsend start 将数据、代码、栈放入不同的段上面的程序稍加修改，改为下面的，则可将数据、代码、栈放入不同的段，代码如下： assume cs:codesg,ds:data,ss:stackdata segment dw 0001H,0002H,0003H,0004H,0005H,0006H,0007H,0008Hdata endsstack segment dw 0,0,0,0,0,0,0,0stack endscodesg segment start: mov ax,stack mov ss,ax mov sp,16 mov ax,data mov ds,ax mov bx,0 mov cx,8 s: push [bx] add bx,2 loop s mov bx,0 mov cx,8 s0: pop [bx] add bx,2 loop s0 mov ax,4c00h int 21Hcodesg endsend start 从程序中看出，定义多个段和前面的定义代码一样，都是用 assume 的方法。 指令 mov ax，stack 的意义是将 stack 段的段地址放入 ax，然后 mov ss，ax 表示把 stack 段的段地址放入 ss 中，这样我们就正确的设置栈段的段地址。同理 mov ax，data 和 mov ds：ax 表示一样的意思，是将代码段的段地址放入 ds 中。 and 和 or 指令and 表示按位与指令，or 表示逻辑或指令，进行按位或运算。 例如指令mov al，01110000Band al，00010000B执行后 al 中的内容为 00010000B 再例如指令mov al，00000000B or al，11111110B执行后 al 中的内容为 11111110B 更灵活的寻址方式前面介绍过用 [idata] 的方式进行寻址，当然也可以用 [bx] 的方式寻址，同样也可以用 [bx + idata] 的方式寻址，它表示的意义为 [bx + idata] 表示一个内存单元，它的偏移地址为 bx 中的值加上 idata 的值，段地址在 ds 中。例如指令 mov ax，[bx + 200] ,它表示将一个内存单元中的内容送入 ax 中，这个内存单元的偏移地址为 bx 中的内容加上 200，段地址在 ds 中。该指令还可以用以下的形式表示： mov ax，[200 + bx] mov ax, 200[bx] mov ax, [bx].200 SI 和 DI 是 8086CPU 中和 bx 功能相近的寄存器，但是它们不能够用作两个 8 为寄存器来使用。当然也能够用 [bx + si] 或者 [bx + di] 的方式来寻址，同样的也可以用 [bx + si + idata] 或者 [bx + di + idata] 的方式来寻址。指令 mov ax，[bx + si + 200] 的含义为：它表示一个内存单元中的内容送入 ax 中，这个内存单元的偏移地址为 bx 加 si 加 200 ，段地址在 ds 中。该指令也可以用以下常用的形式表示： mov ax,[dx + 200 + si] mov ax,[200 + dx + si] mov ax,200[bx][si] mov ax,[bx].200[si] mov ax,[bx][si].200 目前为止，已经学到了很多种寻址的方法，总结如下： [idata] 用一个常量定位一个内存单元 [bx] 用一个变量定位一个内存单元 [bx + idata] 用一个变量和常量定位一个内存单元 [bx + si] 或 [bx + di] 用两个变量来定位一个内存单元 [bx + si + idata] 或 [bx + di + idata] 用两个变量和一个常量来定位一个内存单元 实战：用 si 和 di 实现将字符串 ‘welcome to masm！’ 复制到它后面的数据区中，代码如下 assume cs:codesg,ds:datasgdatasg segment db &apos;welcome to masm!&apos; db &apos;................&apos;datasg ends codesg segment start: mov ax,datasg mov ds,ax mov si,0 mov di,16 mov cx,8 s: mov ax,[si] mov [di],ax add si,2 add di,2 loop s mov ax,4c00h int 21Hcodesg endsend start 代码执行后，从下图可以看出复制成功了。 在 8086CPU 中只有 bx、si、di、bp 这四个寄存器能用 […] 的方式寻址。当然也可以是这组合形式，比如：bx 和 si，bx 和 di，bp 和 si，bp 和 di，而 bx 和 bp 或者 si 和 di 却是错误的。 寻址方式总结通过前面的学习，现将 8086CPU 的寻址方式做以下总结： 寻址方式 名称 [idata] 直接寻址 [bx],[bp],[si],[di] 寄存器间接寻址 [bx+idata],[bp+idata],[si+idata],[di+idata] 寄存器相对寻址 [bx+si],[bx+di],[bp+si],[bp+di] 基址变址寻址 [bx+si+idata],[bx+di+idata],[bp+si+idata],[bp+di+idata] 相对基址变址寻址 总结通过本次学习，我们知道了怎么在汇编中运用多个段来编写程序，了解了 and 指令和 or 指令的用法，总结了 8086CPU 的寻址方式，收获颇丰，继续努力！","categories":[],"tags":[]},{"title":"汇编--第一个程序（4）","slug":"汇编-第一个程序（4）","date":"2018-12-06T02:43:04.000Z","updated":"2018-12-06T02:48:14.399Z","comments":true,"path":"2018/12/06/汇编-第一个程序（4）/","link":"","permalink":"https://github.com/caozhenwei/2018/12/06/汇编-第一个程序（4）/","excerpt":"前面学习了 8086 CPU 通过从 CS：IP 指向的内存取指令并执行，内存中数据的方法为 DS：[xxx]，以及栈的相关知识。从这里开始，我们正式开始编写汇编代码，来体验下真正和 CPU 寄存器打交道的乐趣。","text":"前面学习了 8086 CPU 通过从 CS：IP 指向的内存取指令并执行，内存中数据的方法为 DS：[xxx]，以及栈的相关知识。从这里开始，我们正式开始编写汇编代码，来体验下真正和 CPU 寄存器打交道的乐趣。 第一个程序程序如下： assume cs:codesgcodesg segmentstart: mov ax,0123H mov bx,0456H add ax,bx mov ax,4c00h int 21Hcodesg endsend 汇编语言中包含汇编指令和伪指令，汇编指令是最终要编译成机器码的，而伪指令没有对应的机器码，是由编译器执行的指令，编译器根据伪指令来进行相关的编译工作。 上面的程序中出现了三种伪指令分别是: assume cs:codesg xxx segment …… xxx ends end assume 伪指令的含义是假设，可以将有特定用途的段和相关寄存器关联起来 segment 和 ends 是成对使用的伪指令，segment说明一个段的开始 end 是汇编程序结束标志 mov ax,4c00h 和 int 21H 是程序的返回，就像高级语言中的 return。 计算 2 的 3 次方，代码如下： assume cs:abcabc segment mov ax,2 add ax,ax add ax,ax mov ax,4c00h int 21Habc endsend [bx]mov ax [bx] 命令的含义为将一个内存单元的内容送入 ax 中，这个内存单元的长度为 2 字节，存放一个字，偏移地址在 bx 中，段地址在 ds 中。 looploop 指令的格式是：loop 标号，其中需要循环的次数通常放在 cx 中，CPU 在执行 loop 指令的分为 2 步： （cx）= （cx）- 1 判断 cx 中的值，不为零则跳转到标号处执行程序，如果为零则向下执行 用 loop 指令计算 2 * 3，代码如下 assume cs:codesgcodesg segment mov ax,0 mov cx,3s: add ax,2 loop s mov ax,4c00h int 21H codesg endsend 在汇编程序中，数据不能以字母开头。例如 1234H 在汇编源程序中可以直接写 1234H，而 A000H 在汇编源程序中要写成 0A000H。 [bx] 和 loop 综合应用计算 ffff:0 ~ ffff:b 单元中的数据的和，代码如下： assume cs:code code segment mov ax,0ffffh mov ds,ax mov bx,0 mov dx,0 mov cx,12s: mov al,[bx] mov ah,0 add dx,ax inc bx loop s mov ax,4c00h int 21Hcode endsend 其中 inc bx 表示 bx 中的内容加 1 。 段前缀及其应用我们知道 mov ax，[bx] 表示把一个内存单元的数据的放入 ax 中，偏移地址由 bx 给出，段地址默认在 ds 中。也可以显示的给出段地址，例如：mov ax，ds：[bx]。8086 有 4 个 16 位段寄存器，分别为 CS、DS、SS、ES，那么很显然 mov ax，[bx] 默认的 ds 段地址也可以由 CS 或 SS 或 ES 显示的给出，如以下所示的都是合法的： mov ax，cs:[bx] mov ax，ss:[bx] mov ax，es:[bx] 段前缀应用举例：将内存 ffff:0 ~ ffff:b 中的内容复制到 0020:0 ~ 0020:b 中，代码如下： ;将内存 ffff:0 ~ ffff:b 中的内容复制到 0020:0 ~ 0020:b 中assume cs:code code segment mov ax,0ffffh mov ds,ax mov ax,0020h mov es,ax mov bx,0 mov cx,12s: mov dl,[bx] mov es:[bx],dl inc bx loop s mov ax,4c00h int 21Hcode endsend 编译执行完成后用 debug 查看内存情况，发现程序正确执行，把 ffff:0 ~ ffff:b 中的内容复制到了 0020:0 ~ 0020:b 中。 在程序中使用数据之前的列子我们用到的数据都是在寄存器或者在内存中，比如计算 2 的 3 次方，数据直接放在寄存器中，把某段内存中的数值累加等。比如要计算已知的 n 个数的和该怎么做呢？当然可以把这个 n 个数放到内存中，累加计算其和，但是把这 n 个数放在内存中的什么地方呢？随便拿一块内存来存放数据操作系统允许你这样干吗？其实我们有两种方法取得一块合理的内存来使用，一是在操作系统装载程序的时候为程序分配内存，另一种方法是在程序中向操作系统申请内存。这里我们只讨论在操作系统装载程序为程序分配内存的情况。就像高级语言定义变量一样，汇编也可以定义一个段来存储数据。我们可以使用 db、dw、dd 来定义，它们的具体意义如下： db 定义字节类型变量，一个字节数据占1个字节单元，读完一个，偏移量加 1 dw 定义字类型变量，一个字数据占2个字节单元，读完一个，偏移量加 2 dd 定义双字类型变量，一个双字数据占4个字节单元，读完一个，偏移量加 4 例如我们要计算 0123H,0456H,0789H,0abcH,0defH,0001H,0002H,0003H 这 8 个数据的和，结果存在 ax 中，代码可如下所示： assume cs:codecode segment dw 0001H,0002H,0003H,0004H,0005H,0006H,0007H,0008H mov bx,0 mov ax,0 mov cx,8s: add ax,cs:[bx] add bx,2 loop s mov ax,4c00h int 21Hcode endsend 上面的代码编译链接后用 debug 查看，显示如下： 发现第一条指令并不是我们真正需要 CPU 执行的指令，真的指令从第 17 个字节开始，前面的 16 个字节其实是我们定义的 8 个数据。要想让 CPU 执行指令，在上面的代码中可以加入 start 标号，代码修改为下面的样子： assume cs:codecode segment dw 0001H,0002H,0003H,0004H,0005H,0006H,0007H,0008Hstart: mov bx,0 mov ax,0 mov cx,8 s: add ax,cs:[bx] add bx,2 loop s mov ax,4c00h int 21Hcode endsend start 这时候发现 IP 为 10H 才是我们希望 CPU 执行的指令 总结通过本次学习，我们编写了第一个汇编程序，知道了常用的伪指令：assume、segment ends、end，明白了 [bx] 和 loop 的用法，学习了段前缀及其用法，掌握了在程序中使用数据的方法，并且清楚了 start 标号的用途，收获颇丰，继续努力！","categories":[],"tags":[]},{"title":"汇编--内存访问（3）","slug":"汇编-内存访问（3）","date":"2018-12-05T02:49:00.000Z","updated":"2018-12-05T09:00:09.062Z","comments":true,"path":"2018/12/05/汇编-内存访问（3）/","link":"","permalink":"https://github.com/caozhenwei/2018/12/05/汇编-内存访问（3）/","excerpt":"内存中字的存储8086 的寄存器是 16 位的，怎么存储一个字呢？很简单，因为一个字为 2 个字节，那么高 8 位存放高位字节，低 8 位存储低位字节就行了。","text":"内存中字的存储8086 的寄存器是 16 位的，怎么存储一个字呢？很简单，因为一个字为 2 个字节，那么高 8 位存放高位字节，低 8 位存储低位字节就行了。 内存访问通过前面的学习，我们知道 mov 指令的基本操作，它可以有一下几种形式： mov 寄存器，数据 mov 寄存器，寄存器 我们怎么把内存中的数据转移到寄存器中呢？猜想应该是 mov 寄存器 内存单元。内存的表示方法为基址加偏移地址，可以用 [...] 表示偏移地址，那段地址在哪里呢？先来回顾下 8086 是怎么从内存单元中取指令并且执行的，方法为 CS：IP，CS 表示为段寄存器，IP 表示偏移，从中我们联想到要从内存中取数据，段地址应该默认放在某个寄存器中。对的，从内存中取数据的话，段地址默认放在 DS 中，偏移地址由 [...] 给出。知道了表示方法后就可以用 mov 寄存器 内存单元 来取数据了。格式如下： mov ax [0] 上面这条指令表示的意义为从内存单元 DS：[0] 中取数据放到 ax 寄存器中。DS：[0] 表示的意义为段地址在 DS 中，偏移为 0 。以后就用 DS：[0] 这种方法来表示一个内存单元。能从内存中取数据到寄存器中，当然就可以把寄存器中的数据放到内存中。表示方法如下： mov [0] ax 表示的意义为把 ax 中的数据放入内存单元 DS：[0] 中。 8086 不允许把数据直接放入段寄存器，要想把数据送入段寄存器，可以先把数据放入通用寄存器，在把通用寄存器的数据放入段寄存器，例子如下： mov ax，1000H mov ds，ax 在编写汇编代码时，可以根据需要将一组单元定义为一个段。比如我们用 123B0H ~ 123BAH 这段内存空间来存放数据，则可以认为 123B0H ~ 123BAH 这个段为数据段。其实内存并没被分段，只是人主观的把它视为一个数据段。现在想把 123B0H ~ 123BAH 这个数据段中内容累加，代码如下： mov ax，123B0H mov bx，ax mov al，0 add al，[0] add al，[2] add al，[3] 栈栈是一种先进后出的一种数据结构，在编写汇编代码的时候我们可以将一块内存当做栈来使用。说到栈自然想到栈的两种基本操作，即入栈和出栈。在汇编语言中 push 和 pop 分别表示入栈和出栈。如 push ax 表示把 ax 中的数据送入栈中，pop ax 表示把栈顶取出数据送入 ax 中。这里有一点需要注意：入栈和出栈的操作都是以字为单位的。入栈的时候把数据放入栈顶，出栈的时候从栈顶取出数据。那么 CPU 怎么知道哪段内存是我们定义的栈呢？怎么知道栈顶单元呢？再回想前面的知识，CPU 怎么知道当前要执行的质指令的位置呢？从 CS、IP 指向的段地址和偏移地址中取。那 CPU 怎么从内存单元中取数据呢？从 DS、[xxx] 指向的段地址和偏移地址。那 CPU 怎么知道栈顶单元呢？根据猜想它应该是根据寄存器中应该保存着这些信息。恭喜你又一次答对了，这种举一反三的能力很强，可以奖励自己一个鸡腿当晚餐。栈顶的段地址放在段寄存器 SS 中，偏移地址放在 SP 中。任意时刻，SS：SP 指向栈顶元素。 push 的执行分以下两步： SP = SP - 2，SS：SP 指向当前栈顶前面的单元，以当前栈顶前面的栈顶为新的单元 将 ax 的内容送入 SS：SP 指向的内存单元处，SS：SP 此时指向新栈顶 pop ax 由以下两步完成 将 SS：SP 指向的内存单元处的数据送入 ax SP = SP + 2，SS：SP 指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶 当栈满后再向里面 push 数据，或者栈空的时候再次 pop 数据，都将造成栈越界问题，所以写代码的时候要非常的小心保证栈不能越界。 我们可以一块内存当做栈来使用，称为栈段，那么栈段最大是多少呢？这个问题只需要考虑 SP 即可，因为 SP 的范围为 0 ~ FFFFH，所以栈段的最大容量为 64KB。 总结通过这次学习，知道了字是怎么存储的，即高 8 位存放高位字节，低 8 位存放低位字节；知道了用 DS：[xxx] 的方式访问内存中的数据；知道了栈的概念和它的基本操作 push 和 pop，SS：SP 指向栈顶元素。","categories":[],"tags":[]},{"title":"汇编--mac下搭建汇编编程环境（2）","slug":"汇编-mac下搭建汇编编程环境（2）","date":"2018-12-04T05:56:50.000Z","updated":"2018-12-06T08:42:02.985Z","comments":true,"path":"2018/12/04/汇编-mac下搭建汇编编程环境（2）/","link":"","permalink":"https://github.com/caozhenwei/2018/12/04/汇编-mac下搭建汇编编程环境（2）/","excerpt":"实践是检验真理的唯一标准，上篇通过学习后这里在通过实战能更好的巩固已经学到的知识。本文将介绍怎么在 mac 环境下搭建汇编编程环境和 debuge 的基本用法。","text":"实践是检验真理的唯一标准，上篇通过学习后这里在通过实战能更好的巩固已经学到的知识。本文将介绍怎么在 mac 环境下搭建汇编编程环境和 debuge 的基本用法。 环境搭建在 mac 上搭建汇编环境首先要用到两个软件 DOSBox 和 asm5 。这连个工具在这里可以下载。 运行 DOSBox 后挂载mount c ~/Dos/masm5 因为我的 masm5 文件夹在这里： ~/Dos/masm5 编写汇编程序，可以先不用知道具体汇编指令是什么意思，这里主要是想展示下汇编代码怎么通过编译链接成为最终的可执行问津。例如我的 hello.asm 内容如下： assume cs:codesgcodesg segmentstart: mov ax,0123H mov bx,0456H add ax,bx mov ax,4c00h int 21Hcodesg endsend 通过挂载后要进入 c 盘，命令如下 c： 编译：masm hello.asm 链接:link hell0.obj 运行：hello.exe 调试常用命令r 查看、改变 CPU 寄存器的内容，如下所示的为修改 ax 中的内容 d 命令查看内存中的内容 查看 10000H 处的内存命令如下所示 e 命令来修改内存中的内容，如下所示 用 e 命令向机器中写入机器码，并用 u 命令查看 用 t 命令执行机器指令，首页要把 CS：IP 设置下，如下所示 可以使用 g 命令让程序跑完。 用 a 命令以汇编的形式向内存中写入指令","categories":[],"tags":[]},{"title":"汇编--入门（1）","slug":"汇编-入门（1）","date":"2018-12-03T12:08:54.000Z","updated":"2018-12-13T06:43:10.441Z","comments":true,"path":"2018/12/03/汇编-入门（1）/","link":"","permalink":"https://github.com/caozhenwei/2018/12/03/汇编-入门（1）/","excerpt":"前言汇编语言是能直接操作 CPU 寄存器的语言，学好汇编语言能使我们更好的理解计算机的工作过程。上学那会儿学过计算机原理与接口技术这门课程，汇编多少接触过点儿，不过已经忘完了。现在好多开源代码的底层都是用汇编写的，没有点汇编基础还真的看不懂。那么问题来了，为什么底层的代码要用汇编编写呢？有人回答是汇编的效率更高。汇编和和高级语言最终都要被编译成机器语言，为什么说汇编的效率就更高呢？^_^","text":"前言汇编语言是能直接操作 CPU 寄存器的语言，学好汇编语言能使我们更好的理解计算机的工作过程。上学那会儿学过计算机原理与接口技术这门课程，汇编多少接触过点儿，不过已经忘完了。现在好多开源代码的底层都是用汇编写的，没有点汇编基础还真的看不懂。那么问题来了，为什么底层的代码要用汇编编写呢？有人回答是汇编的效率更高。汇编和和高级语言最终都要被编译成机器语言，为什么说汇编的效率就更高呢？^_^ 机器语言机器语言是机器指令的集合。例如机器指令 1000 1001 1101 1000 表示把寄存器 BX 的内存送到 AX 中，汇编指令则写成 mov ax，bx。机器语言难于辨别和记忆，于是汇编语言诞生了。汇编语言的出现极大的解放了生产力，相比直接编写机器语言效率上大概提升 3 到 5 倍。 汇编指令组成汇编语言由 3 种指令组成： 汇编指令：机器码的助记符号，有对应的机器码 伪指令：没有对应的机器码，由编译器执行，计算机并不执行 其它符号：如 + - * / 等，由编译器识别，没有对应的机器码 内存地址空间CPU 通过总线和内存、硬盘等设备连接，总线从逻辑上分为三类：地址总线、控制总线、数据总线。一个 CPU 有 N 根地址总线，则说这个 CPU 的地址总线宽度为 N，这 N 根线用 0 、1 表示的信息量为 2 的 N 次方，称其寻址能力为 2 的 N 次方。计算机的最小单位信息是 bit ，也就是一个二进制位，8 个 bit 组成一个 Byte，也就是一个字。换算关系如下所示： 1TB = 1024GB ，1GB = 1024MB，1MB = 1024KB，1KB = 1024B，1B = 8bit 微机存储器的容量是以字节为最小单位来计算的，8086 有 20 位地址总线，即 1MB 的寻址能力。 把主存储器地址空间、显卡地址空间、网卡地址空间、系统 BIOS 地址空间的总和看作一个由若干个存储单元组成的逻辑存储器，这个逻辑存储器就是内存地址空间。 8086 是 16 位的 CPU ，则在内部能够一次性处理、传输、暂时存放的数据为 16 位。8086 有 20 位地址总线，即 1MB 的寻址能力。8086 CPU 的寄存器是 16 位的，那怎么用 16 位的寄存器来表示 20 位的地址总线呢？其实 8086 CPU 在内部用两个 16 位地址（段地址和偏移地址）合成一个 20 位的物理地址，即 物理地址 = 段地址 * 16 + 偏移地址。段地址 * 16又被叫做基础地址。 8086 有 4 个段寄存器：CS、DS、SS、ES。 CS 为代码段寄存器，IP 为指令指针寄存器。任意时刻，设 CS 中的内容为 M ，IP 中的内容为 N ，则 8086 将从内存 M * 16 + N 单元开始，读取一条指令并执行。 8086 工作过程8086 工作过程简要描述： 1.从 CS：IP 指向的内存单元读取指令到指令缓存器 2.IP = IP + 所读指令的长度，从而指向下一条指令 3.执行指令并从第 1 步开始重复 知道了 8086 CPU 执行指令的过程，那么我们就可以修改 CS 或 IP 或同时修改 CS 和 IP 来控制 CPU 。 修改 CS、IP 的的指令，“jmp 段地址：偏移地址” jmp 2:3， 仅修改 IP 的内容，“jmp 某一合法寄存器” jmp ax， 执行前 ax = 1000H，CS = 2000H，IP = 0003H 执行后 ax = 1000H，CS = 2000H，IP = 1000H 8086 其它寄存器 从上图可以看出 8086 CPU 内部有 14 个寄存器，一下子也不用记住这么多，随着学习的深入，慢慢的就都认识了。 8086 的所有寄存器都是 16 位的，其中有 4 个通用寄存器，分别为 AX，BX，CX，DX。8086 上一代的 CPU 是 8 位的，为了保持兼容，这 4 个通用寄存器又可以分为两个独立的 8 位寄存器来使用： AX 分为 AH 和 AL BX 分为 BH 和 BL CX 分为 CH 和 CL DX 分为 DH 和 DL 其它的寄存器以后再慢慢介绍。 几个简单的汇编指令 汇编指令 控制 CPU 完成的操作 mov ax,1 将 1 送入寄存器 ax mov al,1 将 1 送入寄存器 ax 的低 8 位 add ax 8 将寄存器 ax 中的数值加 8 mov ax,bx 将 bx 中的数据送入 ax 总结通过本文章我们知道了 8086 CPU 的工作过程，即从 CS：IP 处取指令放到缓冲器，新 IP 值为原 IP + 指令长度，执行指令并从头开始；知道了修改 CS 或 IP 或 CS 和 IP 的 jum 方法；知道了 4 个通用寄存器，AX、BX、CX、DX 并且知道它们可以单独作为两个 8 位寄存器使用；了解了基本汇编指令 mov、add 的用法。下篇介绍下怎么在 mac 环境下搭建汇编编程环境。不积跬步无以至千里，继续加油。","categories":[],"tags":[]},{"title":"CSS之伪类和伪元素","slug":"CSS之伪类和伪元素","date":"2018-07-03T08:25:45.000Z","updated":"2018-07-12T05:33:59.756Z","comments":true,"path":"2018/07/03/CSS之伪类和伪元素/","link":"","permalink":"https://github.com/caozhenwei/2018/07/03/CSS之伪类和伪元素/","excerpt":"w3school 上的定义伪类用于向某些选择器添加特殊的效果。","text":"w3school 上的定义伪类用于向某些选择器添加特殊的效果。 伪类W3C 上的定义The pseudo-class concept is introduced to permit selection based on information that lies outside of the document tree or that cannot be expressed using the other simple selectors. A pseudo-class always consists of a “colon” (:) followed by the name of the pseudo-class and optionally by a value between parentheses. Pseudo-classes are allowed in all sequences of simple selectors contained in a selector. Pseudo-classes are allowed anywhere in sequences of simple selectors, after the leading type selector or universal selector (possibly omitted). Pseudo-class names are case-insensitive. Some pseudo-classes are mutually exclusive, while others can be applied simultaneously to the same element. Pseudo-classes may be dynamic, in the sense that an element may acquire or lose a pseudo-class while a user interacts with the document. 伪类存在的意义是为了通过选择器找到那些不存在 DOM 树中的信息以及不能被常规 CSS 选择器获取到的信息。伪类总是由“冒号”(:)和伪类的名称以及括号之间的值组成。在选择器中包含的所有简单选择器序列中都允许使用伪类。在引导类型选择器或通用选择器(可能省略了)之后，伪类可以在简单的选择器序列中任意位置进行。伪类的名称是不区分大小写的。有些伪类是互斥的，而另一些则可以同时应用于相同的元素。伪类可以是动态的，因为元素可以在用户与文档交互时获得或丢失伪类。 Selector Meaning CSS :active 选择正在被激活的元素 1 :hover 选择被鼠标悬浮着元素 1 :link 选择未被访问的元素 1 :visited 选择已被访问的元素 1 :first-child 选择满足是其父元素的第一个子元素的元素 2 :lang 选择带有指定 lang 属性的元素 2 :focus 选择拥有键盘输入焦点的元素 2 :enable 选择每个已启动的元素 3 :disable 选择每个已禁止的元素 3 :checked 选择每个被选中的元素 3 :target 选择当前的锚点元素 3 :first-of-type 选择满足是其父元素的第一个某类型子元素的元素 3 :last-of-type 选择满足是其父元素的最后一个某类型子元素的元素 3 :only-of-type 选择满足是其父元素的唯一一个某类型子元素的元素 3 :nth-of-type(n) 选择满足是其父元素的第n个某类型子元素的元素 3 :nth-last-of-type(n) 选择满足是其父元素的倒数第n个某类型的元素 3 :only-child 选择满足是其父元素的唯一一个子元素的元素 3 :last-child 选择满足是其父元素的最后一个元素的元素 3 :nth-child(n) 选择满足是其父元素的第n个子元素的元素 3 :nth-last-child(n) 选择满足是其父元素的倒数第n个子元素的元素 3 :empty 选择满足没有子元素的元素 3 :in-range 选择满足值在指定范围内的元素 3 :out-of-range 选择值不在指定范围内的元素 3 :invalid 选择满足值为无效值的元素 3 :valid 选择满足值为有效值的元素 3 :not(selector) 选择不满足selector的元素 3 :optional 选择为可选项的表单元素，即没有“required”属性 3 :read-only 选择有”readonly”的表单元素 3 :read-write 选择没有”readonly”的表单元素 3 :root 选择根元素 3 w3school 上的定义CSS 伪元素用于向某些选择器设置特殊效果。 W3C 上的定义Pseudo-elements create abstractions about the document tree beyond those specified by the document language. For instance, document languages do not offer mechanisms to access the first letter or first line of an element’s content. Pseudo-elements allow authors to refer to this otherwise inaccessible information. Pseudo-elements may also provide authors a way to refer to content that does not exist in the source document (e.g., the ::before and ::after pseudo-elements give access to generated content). A pseudo-element is made of two colons (::) followed by the name of the pseudo-element. This :: notation is introduced by the current document in order to establish a discrimination between pseudo-classes and pseudo-elements. For compatibility with existing style sheets, user agents must also accept the previous one-colon notation for pseudo-elements introduced in CSS levels 1 and 2 (namely, :first-line, :first-letter, :before and :after). This compatibility is not allowed for the new pseudo-elements introduced in this specification. Only one pseudo-element may appear per selector, and if present it must appear after the sequence of simple selectors that represents the subjects of the selector. Note: A future version of this specification may allow multiple pseudo-elements per selector. Selector Meaning CSS ::first-letter 选择指定元素的第一个单词 1 ::first-line 选择指定元素的第一行 1 ::after 在指定元素的内容前面插入内容 2 ::before 在指定元素的内容后面插入内容 2 ::selection 选择指定元素中被用户选中的内容 3 W3C 指万维网联盟（World Wide Web Consortium） 如何阅读W3C规范（高博翻译版）http://www.chinaw3c.org/how-to-read-spec-gb.html","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://github.com/caozhenwei/tags/CSS/"}]},{"title":"CSS选择器","slug":"CSS选择器","date":"2018-06-27T11:23:50.000Z","updated":"2018-07-09T09:28:26.167Z","comments":true,"path":"2018/06/27/CSS选择器/","link":"","permalink":"https://github.com/caozhenwei/2018/06/27/CSS选择器/","excerpt":"基本规则每个规则有两个基本部分：选择器和声名块（可以由一个或多个声名组成）。","text":"基本规则每个规则有两个基本部分：选择器和声名块（可以由一个或多个声名组成）。 元素选择器 h1 &#123;color: gray;&#125; 选择器分组 h2, p &#123;color: gray;&#125; 通配选择器 * &#123;color: gray;&#125; 声名分组 h1 &#123;color: gray; font: 18px;&#125; 结合选择器和声名分组 h2, p &#123;color: gray; font: 18px;&#125; h2&#123; /* 标签选择 */&#125;p,h1&#123; /* 使用逗号实现元素合集 */&#125;div h1,div h2&#123; /* 使用空格实现后代元素(子元素和子孙元素)查询，表示div的后代元素h1，h1和div的合集，在从合集中查找后代元素h2，最后查询到的为h2列表 */ background-color: #2b542c;&#125;p&gt;h1&#123; /* &gt;表示直接子元素 */&#125;p+h1&#123; /* +表示紧接在后面的同胞元素，选择h1元素 */&#125;html&gt;body table+ul&#123; /* 在html元素中查询直接子元素body，在body中查询后代元素table，在table元素后面查询同胞元素ul，即在最后选择的为ul列表 */&#125;body *&#123; /* *通配符选择器，匹配所有元素，表示匹配body的所有后代元素 */&#125;p.class1.class2&#123; /* .表示class类选择器，p为标签，连在一块写，表示多重筛选，一个元素可以有多个样式 */&#125;#id1&#123; /* #id选择器，一个元素只能有一个id，所有元素的id不能相同 */&#125; 类选择器&lt;p class=\"test\"&gt;aaa&lt;/p&gt; .p &#123;color: gray;&#125; 多类选择器 &lt;p class=\"test test1\"&gt;aaa&lt;/p&gt; .test &#123;color: gray;&#125; ID 选择器&lt;p id=\"test\"&gt;aaa&lt;/p&gt; #test &#123;color: gray;&#125; 属性选择器&lt;p class=\"test\"&gt;aaa&lt;/p&gt; p[class] &#123;color: gray;&#125; 根据多个属性选择，下面的例子将同时有 href 和 title 属性的 a 标签的文本设置为粗体 a[herf][title] &#123;font-weight: bold;&#125; 根据具体属性值选择 只选 moons 属性值为 1 的那些 planet 元素 planet[moons= \"1\"] &#123;font-weight: bold;&#125; 根据部分属性选择 &lt;p class=\"test test1\"&gt;aaa&lt;/p&gt; p[class~\"test\"] &#123;color: gray;&#125; 类型 描述 [p^=”test”] 选择 p 属性值以 test 开头的所有元素 [p$”test”] 选择 p 属性值以 test 结尾的所有元素 [p^=”test”] 选择 p 属性值中包含字符串 test 的所有元素 p[attribute1][attribute2]&#123; /* [] 属性选择器，表示具有某种属性的所有元素，多个参数表示同时具有多个属性，class也可以作为一个属性筛选 */&#125;a[href=\"http://www.123.com\"]&#123; /* =具有某个属性，且属性值等于指定值的所有元素 */&#125;div[class~=\"class1\"]&#123; /* ~=具有某个属性，且属性值包含指定值的所有元素 */&#125;input[title^=\"title1\"]&#123; /* ^=指定属性的值以指定字符串开头 */&#125;input[title$=\"title1\"]&#123; /* $=指定属性的值以指定字符串结尾 */&#125;input[title*=\"title1\"]&#123; /* *=指定属性的值包含指定字符串 */&#125;input[title|=\"title1\"]&#123; /* |=指定属性的值等于title1或者以title1-开头 */&#125; 后代选择器h1 p &#123;color: gray;&#125; 只选择 h1 子元素的 p 元素 h1 &gt; p &#123;color: gray;&#125; 选择相邻兄弟元素，例如下面的修改紧接着 h1 元素后出现的 p 元素颜色 h1 + p &#123;color: gray;&#125;","categories":[],"tags":[]},{"title":"CSS之float","slug":"CSS之float","date":"2018-06-25T11:48:47.000Z","updated":"2018-07-04T09:15:32.249Z","comments":true,"path":"2018/06/25/CSS之float/","link":"","permalink":"https://github.com/caozhenwei/2018/06/25/CSS之float/","excerpt":"设置了 float 属性的元素会根据属性值向左或向右浮动，我们称设置了 float 属性的元素为浮动元素。浮动元素会从普通文档流中脱离，但浮动元素影响的不仅是自己，它会影响周围的元素对齐进行环绕。如果被设置了浮动，那浮动元素会生成一个块级框。","text":"设置了 float 属性的元素会根据属性值向左或向右浮动，我们称设置了 float 属性的元素为浮动元素。浮动元素会从普通文档流中脱离，但浮动元素影响的不仅是自己，它会影响周围的元素对齐进行环绕。如果被设置了浮动，那浮动元素会生成一个块级框。 浮动元素的包含块就是离浮动元素最近的块级祖先元素。 浮动元素在浮动的时候，其 margin 不会超过包含块的 padding 。 如果有多个浮动元素，后面的浮动元素的 margin 不会超过前面浮动元素的 margin。 如果两个元素一个向左浮动，一个向右浮动，左浮动元素的 marginRight 不会和右浮动元素的 marginLeft 相邻。 浮动元素顶端不会超过包含块的内边界底端，如果有多个浮动元素，下一个浮动元素的顶端不会超过上一个浮动元素的底端。 如果有非浮动元素和浮动元素同时存在，并且非浮动元素在前，则浮动元素不会不会高于非浮动元素。 浮动元素会尽可能地向顶端对齐、向左或向右对齐。 clear 属性：确保当前元素的左右两侧不会有浮动元素。 如果浮动非替换元素，则要指定一个明确的宽度，否则，它们会尽可能地窄。 替换元素是浏览器根据其标签的元素与属性来判断显示具体的内容。img、input、textarea、select、object 等都是替换元素，这些元素都没有实际的内容。替换元素可以增加行框高度，但不增加 line-height。 非替换元素：大多数元素是不可替换元素，他们将内容直接告诉浏览器，将其显示出来。比如 p的内容、label的内容；浏览器将把这段内容直接显示出来。","categories":[],"tags":[]},{"title":"CSS之Flex布局","slug":"CSS之Flex布局","date":"2018-06-19T02:22:18.000Z","updated":"2018-06-19T03:58:20.799Z","comments":true,"path":"2018/06/19/CSS之Flex布局/","link":"","permalink":"https://github.com/caozhenwei/2018/06/19/CSS之Flex布局/","excerpt":"Flex布局是什么？Flex 是 Flexible Box 的缩写，意为”弹性盒子”，用来为盒状模型提供最大的灵活性。布局的传统解决方案是基于盒状模型，依赖 display 属性 + position 属性 + float 属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。学习 Flex 布局要先了弹性容器和项目。给容器添加 display: flex 就表示它要用弹性布局，弹性盒子里面的子元素称为项目。","text":"Flex布局是什么？Flex 是 Flexible Box 的缩写，意为”弹性盒子”，用来为盒状模型提供最大的灵活性。布局的传统解决方案是基于盒状模型，依赖 display 属性 + position 属性 + float 属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。学习 Flex 布局要先了弹性容器和项目。给容器添加 display: flex 就表示它要用弹性布局，弹性盒子里面的子元素称为项目。 弹性盒子模型弹性盒子的模型如下所示。 弹性盒子有两条轴，默认的水平主轴和竖直轴。主轴的开始位置（与边框的交叉点）叫做 main start，结束位置叫做 main end；交叉轴的开始位置叫做 cross start，结束位置叫做cross end。项目默认沿主轴排列。单个项目占据的主轴空间叫做 main size，占据的交叉轴空间叫做 cross size 。 上面的这段对于没接触过 CSS 的同学估计会稍微难理解点。一时看不懂很正常，接着往下看就会明白了。先说两条轴，说到这里我们思考一下，为什么要有两条轴呢？想象一大堆元素在盒子里等着我们来摆放它们的位置，怎么来摆放呢，肯定要确定一个放置的方向啊，那就对了，可以在水平方向上从左到右、从右到左，当然也可以在垂直方向上从上到下或者从下到上，这种方向就是上面说的那两条轴。 使用弹性布局注意事项使用弹性布局后要注意下面几点： 容器添加弹性布局后，仅仅是容器内容采用弹性布局，而容器本身在文档流中的定位方式依然遵循常规文档流 display:flex; 容器添加弹性布局后，显示为块级元素； display:inline-flex; 容器添加弹性布局后，显示为行级元素； 设为 Flex 布局后，子元素的 float、clear 和 vertical-align 属性将失效。但是position 属性，依然生效。 弹性容器常用属性 flex-direction flex-wrap flex-flow justify-content align-items align-content flex-directionflex-direction 属性决定主轴的方向（即项目的排列方向）。 .box &#123; flex-direction: row | row-reverse | column | column-reverse;&#125; row：从左上角开始，由左到右排列。row-reverse：从右上角开始，由右向左排列。column：从左上角开始，由上往下排列。column-reverse：从左下角开始，由下向上排列。 flex-wrapflex-wrap 属性定义，规定如果一条轴线排不下，如何换行。 .box&#123; flex-wrap: nowrap | wrap | wrap-reverse;&#125; nowrap（默认）：不换行。wrap：换行，第一行在上方。wrap-reverse：换行，第一行在下方。 flex-flowflex-flow 属性是 flex-direction 属性和 flex-wrap 属性的简写形式，默认值为 row nowrap。 .box &#123; flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;&#125; justify-contentjustify-content 属性定义了项目在主轴上的对齐方式。 .box &#123; justify-content: flex-start | flex-end | center | space-between | space-around;&#125; flex-start（默认值）：左对齐flex-end：右对齐center： 居中space-between：两端对齐，项目之间的间隔都相等。space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 align-itemsalign-items 属性定义项目在交叉轴上如何对齐。 .box &#123; align-items: flex-start | flex-end | center | baseline | stretch;&#125; flex-start：交叉轴的起点对齐。flex-end：交叉轴的终点对齐。center：交叉轴的中点对齐。baseline: 项目的第一行文字的基线对齐。stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 align-contentalign-content 属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 .box &#123; align-content: flex-start | flex-end | center | space-between | space-around | stretch;&#125; flex-start：与交叉轴的起点对齐。flex-end：与交叉轴的终点对齐。center：与交叉轴的中点对齐。space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。stretch（默认值）：轴线占满整个交叉轴。 项目常用属性 order flex-grow flex-shrink flex-basis flex align-self order 属性定义项目的排列顺序。数值越小，排列越靠前，默认为 0 。 flex-grow 属性定义项目的放大比例，默认为 0 ，即如果存在剩余空间，也不放大。 flex-shrink 属性定义了项目的缩小比例，默认为 1，即如果空间不足，该项目将缩小。 flex-basis 属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为 auto ，即项目的本来大小。 flex 属性是 flex-grow, flex-shrink 和 flex-basis 的简写，默认值为 0 1 auto。后两个属性可选。 align-self 属性允许单个项目有与其他项目不一样的对齐方式，可覆盖 align-items 属性。默认值为 auto，表示继承父元素的 align-items 属性，如果没有父元素，则等同于 stretch。 参考链接 https://scotch.io/tutorials/a-visual-guide-to-css3-flexbox-properties#basics https://css-tricks.com/snippets/css/a-guide-to-flexbox https://www.processon.com","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://github.com/caozhenwei/tags/CSS/"}]},{"title":"Cycript 简单使用","slug":"Cycript-简单使用","date":"2018-05-28T08:56:29.000Z","updated":"2018-07-04T09:16:18.147Z","comments":true,"path":"2018/05/28/Cycript-简单使用/","link":"","permalink":"https://github.com/caozhenwei/2018/05/28/Cycript-简单使用/","excerpt":"cycript 官方文档 http://www.cycript.org/manual/ Cycript 允许开发人员在 iOS 或 Mac OS X 上使用 objective - c++ 和 JavaScript 语法的混合工具来探索和修改运行的应用程序，通过一个具有语法高亮和标签完成功能的交互式控制台。(它还能在 Android 和 Linux 上独立运行，并提供对 Java 的访问，但没有注入。)","text":"cycript 官方文档 http://www.cycript.org/manual/ Cycript 允许开发人员在 iOS 或 Mac OS X 上使用 objective - c++ 和 JavaScript 语法的混合工具来探索和修改运行的应用程序，通过一个具有语法高亮和标签完成功能的交互式控制台。(它还能在 Android 和 Linux 上独立运行，并提供对 Java 的访问，但没有注入。) Cycript allows developers to explore and modify running applications on either iOS or Mac OS X using a hybrid of Objective-C++ and JavaScript syntax through an interactive console that features syntax highlighting and tab completion. (It also runs standalone on Android and Linux and provides access to Java, but without injection.) ssh 到手机后，启动 app 并且确保它在前台运行，然后执行 cycript -p WeChat 出现 cy# 提示符号表示成功。 常用操作 显示 alertalertView = [[UIAlertView alloc] initWithTitle:@”test” message:@”Cycript” delegate:nil cancelButtonTitle:@”OK” otherButtonTitles:nil];[alertView show]; 查看当前控制器UIApp.keyWindow.rootViewController.visibleViewController 获取 bundle info[[NSBundle mainBundle] infoDictionary].toString() 显示 Controller 的层次结构_printHierarchy 是 UIViewController 的一个私有方法，你可以用它将 view controller 层次打印到控制台。[[[UIWindow keyWindow] rootViewController] _printHierarchy].toString() 修改某个 label 的文字#0x1530cd5f0.text = @&quot;111&quot; 修改某个 view 的 backgroundColor#0x1409777b0.backgroundColor = [UIColor redColor] 打印 view 层级[[UIApp keyWindow] recursiveDescription].toString() 打印层级树[[UIApp keyWindow] _autolayoutTrace].toString() _ivarDescription 获取某个类的属性[choose(FixTitleColorButton)[0] _ivarDescription].toString() _methodDescription[choose(FixTitleColorButton)[0] _methodDescription].toString() 打印视图的响应者 [#0x12e5629f0 nextResponder]","categories":[],"tags":[]},{"title":"iOS 逆向之砸壳","slug":"iOS-逆向之砸壳","date":"2018-05-28T01:45:17.000Z","updated":"2018-12-03T12:32:43.686Z","comments":true,"path":"2018/05/28/iOS-逆向之砸壳/","link":"","permalink":"https://github.com/caozhenwei/2018/05/28/iOS-逆向之砸壳/","excerpt":"前言从 AppStore 下载的 App 是被苹果使用 FairPlay 技术加密过的， 可执行文件被套上了一层保护壳， 而 class-dump Hopper 等工具无法作用于加密过的 App。 在这种情况下， 想要获取头文件， 需要先解密 App 的可执行文件， 俗称“砸壳”。 砸壳的工具有好多种，其核心原理就是将内存中已解密的镜像 “dump” 出来，再生成新的镜像文件，从而达到解密的效果。可执行程序要想运行起来，必须由操作系统把可执行文件加载进内存，iOS 中用的是 DYLD。","text":"前言从 AppStore 下载的 App 是被苹果使用 FairPlay 技术加密过的， 可执行文件被套上了一层保护壳， 而 class-dump Hopper 等工具无法作用于加密过的 App。 在这种情况下， 想要获取头文件， 需要先解密 App 的可执行文件， 俗称“砸壳”。 砸壳的工具有好多种，其核心原理就是将内存中已解密的镜像 “dump” 出来，再生成新的镜像文件，从而达到解密的效果。可执行程序要想运行起来，必须由操作系统把可执行文件加载进内存，iOS 中用的是 DYLD。 dumpdecrypteddumpdecrypted 就是由越狱社区的知名人士 Stefan Esser（ @i0n1c） 出品的一款砸壳工具， 被越狱社区广泛运用在 iOS 逆向工程研究中。下面介绍怎么用 dumpdecrypted 给 app 砸壳。下载 dumpdecrypted 地址为 https://github.com/stefanesser/dumpdecrypted/下载完成后直接 make （如果安装了不同的 iOS SDK，可以调整 Makefile 文件），一切顺利的话会生成名为 dumpdecrypted.dylib 的动态库，先暂时放在这里留着备用。 SSH 连接越狱 iDivice为了书写和描述，我们把 iPhone、iPad、iPod 等统称为 iDivice 。iDivice 越狱后有 root 和 mobile 两个账户，默认密码为 alpine ，建议马上修改这个默认的密码，防止其他人通过这个默认密码登录 iDivice 。修改命令如下： $ su root$ passwdChanging password for root.New password:Retype new password: 越狱 iDivice 使用 Cydia 搜索 openSSH ，安装即可。连接方式有两种 2.1 WiFi 连接首先确保 iDivice 和 电脑在统一局域网，连接操作如下 $ ssh root@x.x.x.x 其中 x.x.x.x 为 iDivice 的 ip 地址。 2.2 USB连接2.2.1 安装 usbmuxd$ brew install usbmuxd 2.2.2 端口映射$ iproxy 2345 22 相当于把 iDivice 的 22 端口映射到电脑的 2345 端口 2.2.3 连接新开一个终端窗口，并且保持 2.2 中的终端窗口没有被关闭 $ ssh -p 2345 root@127.0.0.1 获取两个路径查看 app 进程，这里以 WeChat 为例 ，这里要保证 WeChat 在前台运行 $ ps -ef | grep /var/mobile/ 501 506 1 0 0:00.00 ?? 1:19.23 /var/mobile/Containers/Bundle/Application/F14174A6-AEC8-4AD4-A09A-9049FDCBB55E/WeChat.app/WeChat 0 1529 1482 0 0:00.00 ttys001 0:00.01 grep /var/mobile/ 先记下这个路径备用 查看 app Document 路径这个需要用到 cycript 这个工具。cycript 是混合了 oc 与 js 语法的一个工具, 让开发者在命令行下和应用交互，在运行时查看和修改应用，挂钩相关的进程后，我们就可以用 oc 的方法来查看 app Document 路径了。挂钩进程 $ cycript -p WeChatcy# [[NSFileManager defaultManager] URLsForDirectory:NSDocumentDirectory inDomains:NSUserDomainMask]@[#\"file:///var/mobile/Containers/Data/Application/6475E209-3EF7-4264-ADC5-FBE0264516BF/Documents/\"]cy# 退出 cy# 模式的快捷键为 ctl + d，把上面输出的路径也记下来备用。 把第一步中生成的 dumpdecripted.dylib 动态库拷贝到该 app 的 Document 目录下该操作要用到 scp 命令。scp 是 secure copy 的缩写, 基于 ssh 登陆进行安全的远程文件拷贝命令。例子：两台机器IP分别为：A 192.168.11.10，B 192.168.11.11，如果想把 A 根目录上的 a.jpg 文件拷到 B 上，命令如下：在A服务器上操作 命令为： $ scp /a.jpg root@192.168.11.11:/ 所以此时把生成的 dumpdecripted.dylib 动态库拷贝到该 app 的 Document 目录，命令如下：在 mac的终端上操作 $ scp dumpdecrypted.dylib root@x.x.x.x:/var/mobile/Containers/Data/Application/6475E209-3EF7-4264-ADC5-FBE0264516BF/Documents/ 开始砸壳进入 Document 目录$ cd /var/mobile/Containers/Data/Application/6475E209-3EF7-4264-ADC5-FBE0264516BF/Documents/ 砸壳 $ DYLD_INSERT_LIBRARIES=dumpdecrypted.dylib /var/mobile/Containers/Bundle/Application/F14174A6-AEC8-4AD4-A09A-9049FDCBB55E/WeChat.app/WeChatmach-o decryption dumperDISCLAIMER: This tool is only meant for security research purposes, not for application crackers.[+] detected 64bit ARM binary in memory.[+] offset to cryptid found: @0x1000fcca8(from 0x1000fc000) = ca8[+] Found encrypted data at address 00004000 of length 58818560 bytes - type 1.[+] Opening /private/var/mobile/Containers/Bundle/Application/F14174A6-AEC8-4AD4-A09A-9049FDCBB55E/WeChat.app/WeChat for reading.[+] Reading header[+] Detecting header type[+] Executable is a plain MACH-O image[+] Opening WeChat.decrypted for writing.[+] Copying the not encrypted start of the file[+] Dumping the decrypted data into the file[+] Copying the not encrypted remainder of the file[+] Setting the LC_ENCRYPTION_INFO-&gt;cryptid to 0 at offset ca8[+] Closing original file[+] Closing dump file$ ls00000000000000000000000000000000 MMResourceMgr OpenImResource db.globalconfigCrashReport MMappedKV SafeMode.dat dumpdecrypted.dylibLocalInfo.lst MemoryStat WeChat.decrypted heavy_user_id_mapping.dat 此时就可以在当前目录下看到被砸壳后的 WeChat.decrypted。 获取可执行文件的所有头文件从 iDvice 上把解密后的文件拷到电脑的桌面上，在电脑终端上操作 $ scp root@x.x.x.x:/var/mobile/Containers/Data/Application/6475E209-3EF7-4264-ADC5-FBE0264516BF/Documents/WeChat.decrypted ~/Desktop/``` 获取 .h 文件需要用到 class-dump 工具，下载地址为 http://stevenygard.com/projects/class-dump/。把砸壳后的可执行文件的所有 .h 文件输出到 wechat_test_h 文件夹下``` bashclass-dump -H WeChat.decrypted -o wechat_test_h 这时候就能看到所有 WeChat 的头文件了。 相关链接FairPlay https://en.wikipedia.org/wiki/FairPlaydumpdecrypted https://github.com/stefanesser/dumpdecrypted/class-dump http://stevenygard.com/projects/class-dump/","categories":[],"tags":[]},{"title":"Logos 语法","slug":"Logos-语法","date":"2018-05-24T06:30:55.000Z","updated":"2018-07-04T09:16:56.444Z","comments":true,"path":"2018/05/24/Logos-语法/","link":"","permalink":"https://github.com/caozhenwei/2018/05/24/Logos-语法/","excerpt":"前言这篇文章翻译自 http://iphonedevwiki.net/index.php/Logos，主要是 logos 语法。Logos 是 Theos 开发套件的一个组成部分，它允许使用一组特殊的预处理器指令，轻松地、清晰地编写方法来 hook 代码。","text":"前言这篇文章翻译自 http://iphonedevwiki.net/index.php/Logos，主要是 logos 语法。Logos 是 Theos 开发套件的一个组成部分，它允许使用一组特殊的预处理器指令，轻松地、清晰地编写方法来 hook 代码。 综述","categories":[],"tags":[]},{"title":"Mach-O 学习","slug":"Mach-O-学习","date":"2018-05-22T07:10:31.000Z","updated":"2018-06-26T09:59:28.473Z","comments":true,"path":"2018/05/22/Mach-O-学习/","link":"","permalink":"https://github.com/caozhenwei/2018/05/22/Mach-O-学习/","excerpt":"Mach-O，是 Mach object 文件格式的缩写，同样也是 OS X 和 iOS 系统中可执行文件格式。类似于 Linux 下的 elf。除了可执行文件外，动态链接库、静态链接库等都是这种格式的。了解 Mach-O ，也助于我们更好的学习 iOS 逆向工程。","text":"Mach-O，是 Mach object 文件格式的缩写，同样也是 OS X 和 iOS 系统中可执行文件格式。类似于 Linux 下的 elf。除了可执行文件外，动态链接库、静态链接库等都是这种格式的。了解 Mach-O ，也助于我们更好的学习 iOS 逆向工程。 Mach-O 结构简单介绍Mach-O 主要由三部分组成：Header、Load commands、Raw segment data，如下图所示： Header保存了 Mach-O 的一些基本信息，包括了平台、文件类型、LoadCommands 的个数等等。 LoadCommands这些指令非常清晰地指示加载器如何设置并且加载二进制数据，这一段紧跟 Header，加载 Mach-O 文件时会使用这里的数据来确定内存的分布。 Data 每一个 segment 的具体数据都保存在这里，这里包含了具体的代码、数据等等。 Mach-O 三部分结构详细介绍Header我们可以用 otool 先来看看 iOS 中一个可执行文件的头信息，这里拿微信来看看，otool -h WeChat: $ otool -h WeChat Mach header magic cputype cpusubtype caps filetype ncmds sizeofcmds flags 0xfeedface 12 9 0x00 2 86 8192 0x00218085Mach header magic cputype cpusubtype caps filetype ncmds sizeofcmds flags 0xfeedfacf 16777228 0 0x00 2 86 8984 0x00218085 下面详细介绍下这都代表什么意思。 头信息的结构可以在 /usr/include/mach-o/loader.h 中查看 /* * The 32-bit mach header appears at the very beginning of the object file for * 32-bit architectures. */struct mach_header &#123; uint32_t magic; /* mach magic number identifier */ cpu_type_t cputype; /* cpu specifier */ cpu_subtype_t cpusubtype; /* machine specifier */ uint32_t filetype; /* type of file */ uint32_t ncmds; /* number of load commands */ uint32_t sizeofcmds; /* the size of all the load commands */ uint32_t flags; /* flags */&#125;;/* Constant for the magic field of the mach_header (32-bit architectures) */#define MH_MAGIC 0xfeedface /* the mach magic number */#define MH_CIGAM 0xcefaedfe /* NXSwapInt(MH_MAGIC) *//* * The 64-bit mach header appears at the very beginning of object files for * 64-bit architectures. */struct mach_header_64 &#123; uint32_t magic; /* mach magic number identifier */ cpu_type_t cputype; /* cpu specifier */ cpu_subtype_t cpusubtype; /* machine specifier */ uint32_t filetype; /* type of file */ uint32_t ncmds; /* number of load commands */ uint32_t sizeofcmds; /* the size of all the load commands */ uint32_t flags; /* flags */ uint32_t reserved; /* reserved */&#125;;/* Constant for the magic field of the mach_header_64 (64-bit architectures) */#define MH_MAGIC_64 0xfeedfacf /* the 64-bit mach magic number */#define MH_CIGAM_64 0xcffaedfe /* NXSwapInt(MH_MAGIC_64) */ magic : 魔数从上面的宏定义可以看出 0xfeedface 代表的是 32 位，0xfeedfacf 代表 64 位cputype : cpu 的类型在 /usr/include/mach/machine.h 中可以看到相关的定义 /* * Machine types known by all. */ #define CPU_TYPE_ANY ((cpu_type_t) -1)#define CPU_TYPE_VAX ((cpu_type_t) 1)/* skip ((cpu_type_t) 2) *//* skip ((cpu_type_t) 3) *//* skip ((cpu_type_t) 4) *//* skip ((cpu_type_t) 5) */#define CPU_TYPE_MC680x0 ((cpu_type_t) 6)#define CPU_TYPE_X86 ((cpu_type_t) 7)#define CPU_TYPE_I386 CPU_TYPE_X86 /* compatibility */#define CPU_TYPE_X86_64 (CPU_TYPE_X86 | CPU_ARCH_ABI64)/* skip CPU_TYPE_MIPS ((cpu_type_t) 8) *//* skip ((cpu_type_t) 9) */#define CPU_TYPE_MC98000 ((cpu_type_t) 10)#define CPU_TYPE_HPPA ((cpu_type_t) 11)#define CPU_TYPE_ARM ((cpu_type_t) 12)#define CPU_TYPE_ARM64 (CPU_TYPE_ARM | CPU_ARCH_ABI64)#define CPU_TYPE_MC88000 ((cpu_type_t) 13)#define CPU_TYPE_SPARC ((cpu_type_t) 14)#define CPU_TYPE_I860 ((cpu_type_t) 15)/* skip CPU_TYPE_ALPHA ((cpu_type_t) 16) *//* skip ((cpu_type_t) 17) */#define CPU_TYPE_POWERPC ((cpu_type_t) 18)#define CPU_TYPE_POWERPC64 (CPU_TYPE_POWERPC | CPU_ARCH_ABI64) cupsubtype cpu 的子类型和 cputype 一样，也可以在 /usr/include/mach/machine.h 中可以看到相关的定义，其中有关于 PowerPC 的，Mips 的等等，这里列一下关于 ARM 的: ........./* * ARM subtypes */#define CPU_SUBTYPE_ARM_ALL ((cpu_subtype_t) 0)#define CPU_SUBTYPE_ARM_V4T ((cpu_subtype_t) 5)#define CPU_SUBTYPE_ARM_V6 ((cpu_subtype_t) 6)#define CPU_SUBTYPE_ARM_V5TEJ ((cpu_subtype_t) 7)#define CPU_SUBTYPE_ARM_XSCALE ((cpu_subtype_t) 8)#define CPU_SUBTYPE_ARM_V7 ((cpu_subtype_t) 9)#define CPU_SUBTYPE_ARM_V7F ((cpu_subtype_t) 10) /* Cortex A9 */#define CPU_SUBTYPE_ARM_V7S ((cpu_subtype_t) 11) /* Swift */#define CPU_SUBTYPE_ARM_V7K ((cpu_subtype_t) 12)#define CPU_SUBTYPE_ARM_V6M ((cpu_subtype_t) 14) /* Not meant to be run under xnu */#define CPU_SUBTYPE_ARM_V7M ((cpu_subtype_t) 15) /* Not meant to be run under xnu */#define CPU_SUBTYPE_ARM_V7EM ((cpu_subtype_t) 16) /* Not meant to be run under xnu */......... filetype 文件的类型相关定义在 /usr/include/mach-o/loader.h 中 #define MH_OBJECT 0x1 /* relocatable object file */#define MH_EXECUTE 0x2 /* demand paged executable file */#define MH_FVMLIB 0x3 /* fixed VM shared library file */#define MH_CORE 0x4 /* core file */#define MH_PRELOAD 0x5 /* preloaded executable file */#define MH_DYLIB 0x6 /* dynamically bound shared library */#define MH_DYLINKER 0x7 /* dynamic link editor */#define MH_BUNDLE 0x8 /* dynamically bound bundle file */#define MH_DYLIB_STUB 0x9 /* shared library stub for static */......... 常用的如下： MH_OBJECT 编译过程中产生的 *.obj 文件 MH_EXECUTABLE 可执行二进制文件 MH_DYLIB 动态库 ncmds 指的是加载命令 (load commands) 的数量sizeofcmds 表示 load commands 的总字节大小flags 一个包含一组位标志的整数，它显示了 Mach-O 文件格式的某些可选特性的状态。 加载命令这些加载命令在 Mach-O 文件加载解析时，被内核加载器或者动态链接器调用，指导如何设置加载对应的二进制数据段，加载命令的种类有很多种，在 /usr/include/mach-o/loader.h 头文件有简单的注释 struct load_command &#123; uint32_t cmd; /* type of load command */ uint32_t cmdsize; /* total size of command in bytes */&#125;;/* * After MacOS X 10.1 when a new load command is added that is required to be * understood by the dynamic linker for the image to execute properly the * LC_REQ_DYLD bit will be or'ed into the load command constant. If the dynamic * linker sees such a load command it it does not understand will issue a * \"unknown load command required for execution\" error and refuse to use the * image. Other load commands without this bit that are not understood will * simply be ignored. */#define LC_REQ_DYLD 0x80000000/* Constants for the cmd field of all load commands, the type */#define LC_SEGMENT 0x1 /* segment of this file to be mapped */#define LC_SYMTAB 0x2 /* link-edit stab symbol table info */#define LC_SYMSEG 0x3 /* link-edit gdb symbol table info (obsolete) */#define LC_THREAD 0x4 /* thread */#define LC_UNIXTHREAD 0x5 /* unix thread (includes a stack) */#define LC_LOADFVMLIB 0x6 /* load a specified fixed VM shared library */#define LC_IDFVMLIB 0x7 /* fixed VM shared library identification */#define LC_IDENT 0x8 /* object identification info (obsolete) */#define LC_FVMFILE 0x9 /* fixed VM file inclusion (internal use) */#define LC_PREPAGE 0xa /* prepage command (internal use) */#define LC_DYSYMTAB 0xb /* dynamic link-edit symbol table info */#define LC_LOAD_DYLIB 0xc /* load a dynamically linked shared library */......... LC_SYMTAB 符号表地址 LC_DYSYMTAB 动态符号表地址 LC_LOAD_DYLINKER 使用何种动态加载库 LC_UUID 文件的唯一标识 LC_VERSION_MIN_MACOSX 二进制文件要求的最低操作系统版本 LC_SOURCE_VERSION 构建该二进制文件使用的源代码版本 LC_MAIN 设置程序主线程的入口地址和栈大小 通过 otool -lv 来查看一下 WeChat $ otool -lv WeChat WeChat (architecture armv7):Mach header magic cputype cpusubtype caps filetype ncmds sizeofcmds flags MH_MAGIC ARM V7 0x00 EXECUTE 89 8292 NOUNDEFS DYLDLINK TWOLEVEL WEAK_DEFINES BINDS_TO_WEAK PIELoad command 0 cmd LC_SEGMENT cmdsize 56 segname __PAGEZERO vmaddr 0x00000000 vmsize 0x00004000 fileoff 0 filesize 0 maxprot --- initprot --- nsects 0 flags (none)Load command 1 cmd LC_SEGMENT cmdsize 736 segname __TEXT vmaddr 0x00004000 vmsize 0x034dc000 fileoff 0 filesize 55427072 maxprot r-x initprot r-x nsects 10 flags (none)Section sectname __text segname __TEXT addr 0x0000aff0 size 0x02d4bac4 offset 28656 align 2^4 (16) reloff 0 nreloc 0 type S_REGULARattributes PURE_INSTRUCTIONS SOME_INSTRUCTIONS reserved1 0 reserved2 0......... 其中每个 load command 的结构如下： struct segment_command &#123; /* for 32-bit architectures */ uint32_t cmd; /* LC_SEGMENT */ uint32_t cmdsize; /* includes sizeof section structs */ char segname[16]; /* segment name */ uint32_t vmaddr; /* memory address of this segment */ uint32_t vmsize; /* memory size of this segment */ uint32_t fileoff; /* file offset of this segment */ uint32_t filesize; /* amount to map from the file */ vm_prot_t maxprot; /* maximum VM protection */ vm_prot_t initprot; /* initial VM protection */ uint32_t nsects; /* number of sections in segment */ uint32_t flags; /* flags */&#125;;/* * The 64-bit segment load command indicates that a part of this file is to be * mapped into a 64-bit task's address space. If the 64-bit segment has * sections then section_64 structures directly follow the 64-bit segment * command and their size is reflected in cmdsize. */struct segment_command_64 &#123; /* for 64-bit architectures */ uint32_t cmd; /* LC_SEGMENT_64 */ uint32_t cmdsize; /* includes sizeof section_64 structs */ char segname[16]; /* segment name */ uint64_t vmaddr; /* memory address of this segment */ uint64_t vmsize; /* memory size of this segment */ uint64_t fileoff; /* file offset of this segment */ uint64_t filesize; /* amount to map from the file */ vm_prot_t maxprot; /* maximum VM protection */ vm_prot_t initprot; /* initial VM protection */ uint32_t nsects; /* number of sections in segment */ uint32_t flags; /* flags */&#125;; cmd 是 load command 的类型cmdsize 代表 load command 的大小segname 段名字vmaddr 段的虚拟内存起始地址vmsize 段的虚拟内存大小fileoff 段在文件中的偏移量filesize 段在文件中的大小maxprot 段页面所需要的最高内存保护initprot 段页面初始的内存保护nsects 段中包含 section 的数量flags 其他杂项标志位 Datasection 的机构如下： struct section &#123; /* for 32-bit architectures */ char sectname[16]; /* name of this section */ char segname[16]; /* segment this section goes in */ uint32_t addr; /* memory address of this section */ uint32_t size; /* size in bytes of this section */ uint32_t offset; /* file offset of this section */ uint32_t align; /* section alignment (power of 2) */ uint32_t reloff; /* file offset of relocation entries */ uint32_t nreloc; /* number of relocation entries */ uint32_t flags; /* flags (section type and attributes)*/ uint32_t reserved1; /* reserved (for offset or index) */ uint32_t reserved2; /* reserved (for count or sizeof) */&#125;;struct section_64 &#123; /* for 64-bit architectures */ char sectname[16]; /* name of this section */ char segname[16]; /* segment this section goes in */ uint64_t addr; /* memory address of this section */ uint64_t size; /* size in bytes of this section */ uint32_t offset; /* file offset of this section */ uint32_t align; /* section alignment (power of 2) */ uint32_t reloff; /* file offset of relocation entries */ uint32_t nreloc; /* number of relocation entries */ uint32_t flags; /* flags (section type and attributes)*/ uint32_t reserved1; /* reserved (for offset or index) */ uint32_t reserved2; /* reserved (for count or sizeof) */ uint32_t reserved3; /* reserved */&#125;; sectname section 名segname 该 section 所属的 segment 名addr 该 section 在内存的启始位置size 该 section 的大小offset 该 section 的文件偏移align 字节大小对齐reloff 重定位入口的文件偏移nreloc 需要重定位的入口数量flags 包含 section 的 type 和 attributes 可以通过 otool –s 查看某 segment 的某个 section： $ otool -s __TEXT __text WeChatWeChat (architecture armv7):Contents of (__TEXT,__text) section0000aff0 af03b5f0 8d04f84d f6444606 f2c070fe 0000b000 f644304d 447871fc 314df2c0 46904479 0000b010 68096800 680c6800 8000f846 b9955935 0000b020 70e8f644 304df2c0 68004478 58306800......... MachOView除了用 otool 查看 Mach-O 外，还可以通过 MachOView 可视化工具来查看MachOView下载地址：http://sourceforge.net/projects/machoview/MachOView源码地址：https://github.com/gdbinit/MachOView效果如下： 相关资料Mach-O-File-Format","categories":[],"tags":[]},{"title":"CSS学习之盒子模型","slug":"CSS学习之盒子模型","date":"2018-04-20T06:44:17.000Z","updated":"2018-07-04T09:16:03.002Z","comments":true,"path":"2018/04/20/CSS学习之盒子模型/","link":"","permalink":"https://github.com/caozhenwei/2018/04/20/CSS学习之盒子模型/","excerpt":"要设置 HTML 元素的样式，首先我们要选中 HTML 元素。常用的选中方式有 id 选择器和类选择器。 id 选择器以 # 来定义，类选择器以 . 来定义。","text":"要设置 HTML 元素的样式，首先我们要选中 HTML 元素。常用的选中方式有 id 选择器和类选择器。 id 选择器以 # 来定义，类选择器以 . 来定义。 CSS选择器CSS 的语法如下：例子如下： &lt;html&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /&gt;&lt;title&gt;选择器&lt;/title&gt;&lt;head&gt;&lt;style type=\"text/css\"&gt; #p &#123; background-color: yellow; &#125; .div1 &#123; background-color: red; width: 100px; height: 100px; &#125; .pos_abs2 &#123;&lt;/style&gt;&lt;/head&gt;&lt;body id=\"body\"&gt; &lt;div class=\"div1\"&gt; &lt;p&gt;div1&lt;/p&gt; &lt;/div&gt; &lt;p id=\"p\"&gt;这里要用id选择器来选中&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 这里我们用类选择器选中 div 标签并把它的背景设置为红色，宽高分别为 100px ，用 id 选择器选中 p 标签元算并把它的背景设置为黄色。效果如下： 盒子模型我们可以把 CSS 中的元素理解为一个盒子，整个页面就是一个盒子套一个盒子。盒子模型是有两种标准的，一个是标准模型，一个是 IE 模型。 这两种模型相似之处是从里到外都是 content ,padding ,border ,margin 。不同之处是标准模型的宽高只是内容（content）的宽高，而在 IE 模型中盒模型的宽高是内容(content)+填充(padding)+边框(border)的总宽高。 传统布局这里之所以说是传统布局是因为后面还要介绍 Flex 布局。传统布局主要是用 position、display、float 等属性来布局。下面会依次介绍这几个属性。 position 属性position 属性是指定一个元素的定位方法类型，分别是 static、fixed、relative、absolute。 static 定位是 HTML 元素的默认值，即没有定位，元素出现在正常的流中。 relative 是以自身在正常文档流的位置进行相应的偏移。 absolute 如果某个元素的 position 为 absolute ，那么这个元素就会按照其祖先元素中设置了 position 属性的元素来定位（从 padding 开始的地方），如果不存在这样设置了 position 的祖先元素，则会以 body 为定位对象。这个元素在文档流中溢出后，其文档流中的下一个元素将获得其位置。 fixed 是特殊的 absolute，即 fixed 总是以浏览器的可视窗口进行定位。 下面来看几个简单的例子。 &lt;html&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /&gt;&lt;title&gt;postion相关属性&lt;/title&gt;&lt;head&gt;&lt;style type=\"text/css\"&gt; #body &#123; background-color: #ccc; &#125; .pos_sta &#123; background-color: red; width: 100px; height: 100px; position: static; left: 200px; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body id=\"body\"&gt; &lt;div class=\"pos_sta\"&gt; &lt;p&gt;div1&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果如下 从上的例子中可以看出，static 这种定位不会受到 top ，bottom ,left ,right 的影响，这四个 CSS 属性样式用于定位对象盒子，必须定义 position 属性值为 absolute 或者 relative 此取值方可生效。一般 left 和 right 在一个样式是只能使用其一，不能 left 和 right 都设置。 定位为 relative 时 &lt;html&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /&gt;&lt;title&gt;postion相关属性&lt;/title&gt;&lt;head&gt;&lt;style type=\"text/css\"&gt; #body &#123; background-color: #ccc; &#125; .pos_relative1 &#123; background-color: red; width: 100px; height: 100px; &#125; .pos_relative2 &#123; background-color: green; width: 100px; height: 100px; position: relative; left: 150px; &#125; .pos_relative3 &#123; background-color: blue; width: 100px; height: 100px; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body id=\"body\"&gt; &lt;div class=\"pos_relative1\"&gt; &lt;p&gt;div1&lt;/p&gt; &lt;/div&gt; &lt;div class=\"pos_relative2\"&gt; &lt;p&gt;div2&lt;/p&gt; &lt;/div&gt; &lt;div class=\"pos_relative3\"&gt; &lt;p&gt;div3&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果如下 从上述代码可以看出，当对 div2 设置 position 为 relative 时，只是在它原来的基础上进行偏移，并没有影响下面的元素。 定位为 absolute 时, &lt;html&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /&gt;&lt;title&gt;postion相关属性&lt;/title&gt;&lt;head&gt;&lt;style type=\"text/css\"&gt; #body &#123; background-color: #ccc; &#125; .pos_abs1 &#123; background-color: red; width: 100px; height: 100px; &#125; .pos_abs2_parent &#123; background-color: Pink; width: 100px; height: 100px; position: absolute; left: 50px; top: 50px; &#125; .pos_abs2 &#123; background-color: green; width: 100px; height: 100px; position: absolute; left: 50px; top: 50px; &#125; .pos_abs3 &#123; background-color: blue; width: 100px; height: 100px; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body id=\"body\"&gt; &lt;div class=\"pos_abs1\"&gt; &lt;p&gt;div1&lt;/p&gt; &lt;/div&gt; &lt;div class=\"pos_abs2_parent\"&gt; &lt;div class=\"pos_abs2\"&gt; &lt;p&gt;div2&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"pos_abs3\"&gt; &lt;p&gt;div3&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果如下 从上述代码可以看出，当对 div2 设置 position 为 absolute 时,它就从正常的文档流中脱离出来了，如果 pos_abs2 有祖先元素设置了 position 属性，则以其设置了 position 属性的元素为祖先元素来定位。 定位为 fixed 时, &lt;html&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /&gt; &lt;title&gt;postion相关属性&lt;/title&gt; &lt;head&gt; &lt;style type=\"text/css\"&gt; #body { background-color: #ccc; } .pos_abs1 { background-color: red; width: 100px; height: 100px; } .pos_abs2_parent { background-color: Pink; width: 100px; height: 100px; position: absolute; left: 150px; top: 150px; } .pos_abs2 { background-color: green; width: 100px; height: 100px; position: fixed; left: 50px; top: 50px; } .pos_abs3 { background-color: blue; width: 100px; height: 100px; } &lt;/style&gt; &lt;/head&gt; &lt;body id=\"body\"&gt; &lt;div class=\"pos_abs1\"&gt; &lt;p&gt;div1&lt;/p&gt; &lt;/div&gt; &lt;div class=\"pos_abs2_parent\"&gt; &lt;div class=\"pos_abs2\"&gt; &lt;p&gt;div2&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"pos_abs3\"&gt; &lt;p&gt;div3&lt;/p&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 从上述代码可以看出，当对 div2 设置 position 为 fixed 时,总是以浏览器的可视窗口进行定位。 display 属性CSS 入门学习那篇里说过 CSS 将元素分为块级元素和行内元素，但是我们可以用 display 来规定元素应该生成的框的类型。其常用的值有 block、inline、inline-block、inherit、none 等。 block通过对一个行内元素设置 display:block;可以将行内元素设置为块级元素，进而设置它的宽高和上下左右的 padding 和 margin 。 inlinedisplay:inline 的作用即可以将一个块级元素转换成行内元素，那么这个块级元素将不能再设置宽和高以及上下方向的 margin 和 padding 。 inline-block设置了 inline-block 属性的元素既具有 block 元素可以设置 width 和 height 属性的特性，又保持了 inline 元素不换行的特性。 inheritinherit，表示子元素会继承父元素的 display 属性。 参考链接 w3school divcss5","categories":[],"tags":[]},{"title":"CSS入门学习","slug":"css-学习","date":"2018-04-11T08:38:20.000Z","updated":"2018-07-06T02:50:07.341Z","comments":true,"path":"2018/04/11/css-学习/","link":"","permalink":"https://github.com/caozhenwei/2018/04/11/css-学习/","excerpt":"CSS是什么CSS 指的是层叠样式表 (Cascading Style Sheets)，说白了就是来定义 HTML 元素的样式的。根据层叠样式表来理解下 CSS ，样式表好理解，就是有样式的“表”，那层叠指的是什么呢？层叠指的是一层一层叠加的效果，我们可以在多个地方来设置某个元素的样式，这个元素的最终显示结果是它们共同叠加的效果。叠加效果是有相关规则的，比如谁的优先级更高、谁会覆盖谁等，下面会有相关介绍。","text":"CSS是什么CSS 指的是层叠样式表 (Cascading Style Sheets)，说白了就是来定义 HTML 元素的样式的。根据层叠样式表来理解下 CSS ，样式表好理解，就是有样式的“表”，那层叠指的是什么呢？层叠指的是一层一层叠加的效果，我们可以在多个地方来设置某个元素的样式，这个元素的最终显示结果是它们共同叠加的效果。叠加效果是有相关规则的，比如谁的优先级更高、谁会覆盖谁等，下面会有相关介绍。 CSS 是用来写样式的，但是写几个元素放在浏览器里就有样式了，这是什么鬼？例子如下： &lt;html&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /&gt;&lt;head&gt;&lt;/head&gt;&lt;body id=\"body\"&gt; &lt;div&gt; &lt;H1&gt;aaa&lt;/H1&gt; &lt;H2&gt;bbb&lt;/H2&gt; &lt;p&gt;ccc&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 可以很明显的看到 aaa、bbb 被放大并且加粗了。这是因为浏览器有默认的样式，并且不同浏览器会有不同的样式。这就需要考虑不同浏览器的兼容问题了，这个问题先放在这里，下面有解决的办法。 CSS样式怎么来写怎么来写样式呢？主要有以下几种方法： 属性样式 内部样式 引用样式 属性样式属性样式，html 代码还是上个例子的代码，CSS 代码如下： &lt;H1 style='color: red'&gt;aaa&lt;/H1&gt;&lt;H2 style='color: green'&gt;bbb&lt;/H2&gt;&lt;p style='color: gray'&gt;ccc&lt;/p&gt; 效果如下： 内部样式内部样式&lt;style type=\"text/css\"&gt; H1 &#123; color: red; &#125; H2 &#123; color: green; &#125; p &#123; color: gray; &#125;&lt;/style&gt; 效果同上面的一样 引用样式引用样式default.html &lt;html&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /&gt;&lt;head&gt;&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"default.css\" /&gt; &lt;/head&gt;&lt;body id=\"body\"&gt; &lt;div&gt; &lt;H1&gt;aaa&lt;/H1&gt; &lt;H2&gt;bbb&lt;/H2&gt; &lt;p&gt;ccc&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; default.css H1 &#123; color: red;&#125;H2 &#123; color: green;&#125;p &#123; color: gray;&#125; 效果同上面的一样。 样式的优先级接着来说一下如果多个地方都设置了某一标签的样式该来怎么展示的问题。属性样式 &gt; 内部样式 &gt; 引用样式，层叠效果是各个设置效果的叠加，有相同的话是后面的覆盖前面的。举例：1.属性样式的优先级高于内部样式 例子中同时设置了 H1 标签的属性样式为 color:green、内部样式为 vred ，最终效果为 color:red。 &lt;html&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /&gt;&lt;head&gt;&lt;style type=\"text/css\"&gt; H1 &#123; color: red; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body id=\"body\"&gt; &lt;div&gt; &lt;H1 style='color:green'&gt;aaa&lt;/H1&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 2.样式的叠加，例子中设置了 p 标签的属性样式为 color:green、内部样式为 color:red;font-size: 50px;,最终效果为 color: green;font-size: 50px; 。 &lt;html&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /&gt;&lt;head&gt;&lt;style type=\"text/css\"&gt; p &#123; color: red; font-size: 50px; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body id=\"body\"&gt; &lt;div&gt; &lt;p style='color:green'&gt;ccc&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 浏览器的默认样式上文提到浏览器有默认的样式，其主要目地是为了让没有样式的页面显示起来不至于那么寒碜～～～。为了保持兼容性，一般会重置不同浏览器默认的样式，称为重置样式表。已经有很多别人写好的重置样式表，这里就不再造轮子，直接拿过来用。 CSS Reset strppd.css normalize.css CSS标准文档流文档流指的是元素排版布局过程中，元素会自动从左往右，从上往下的流式排列。CSS 中的元素分为两种：块级元素和行内元素。 块级元素霸占一行，不能与其它任何元素并列，能设置宽、高等属性，默认的宽度为父容器的宽度。 行内元素行内元素与其它元素并排，不能设置宽、高，默认的宽度就是文字的宽度。 HTML 中，标签分为两种：文本级和容器级，常见的文本级标签：p、span、a、等，常见的容器级标签：div、h、li等。容器级的标签，里面可以放置任何东西；文本级的标签里面，只能放置文字、图片、表单元素。 下面来看一下标准文档流中块级元素和行内元素展示样子。下面的例子中我们可以看到 div 独自占一行，而 sapn 是与其它元素并列展示。 HTML &lt;body id=\"body\"&gt; &lt;div&gt;1&lt;/div&gt; &lt;div&gt;2&lt;/div&gt; &lt;div&gt;3&lt;/div&gt; &lt;span&gt;aaa&lt;/span&gt; &lt;span&gt;bbb&lt;/span&gt; &lt;span&gt;ccc&lt;/span&gt; &lt;div&gt;4&lt;/div&gt; &lt;span&gt;ddd&lt;/span&gt;&lt;/body&gt; CSS #body &#123; background-color: #ccc; &#125;div &#123; background-color: green; width: 200px; height: 50px; margin-top: 10px;&#125;span &#123; background-color: red;&#125; 效果如下： 行内元素和块级元素是可以相互转换的，元素也可以脱离文档流，在后面的文章里会有介绍。 总结通过上面的学习我们知道了 CSS 是什么，并且知道了怎么在 HTML 中来写样式，了解了样式的优先级，明白了浏览器的默认样式和文档流。接下来会继续学习基于盒状模型并依赖 display 属性 + position 属性 + float 属性的传统布局。 参考链接 w3school","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://github.com/caozhenwei/tags/CSS/"}]},{"title":"常用 git 命令总结","slug":"常用-git-命令总结","date":"2018-03-19T12:17:59.000Z","updated":"2018-07-09T08:33:09.062Z","comments":true,"path":"2018/03/19/常用-git-命令总结/","link":"","permalink":"https://github.com/caozhenwei/2018/03/19/常用-git-命令总结/","excerpt":"前言git 是什么它是一个版本控制工具。 版本控制是一种记录一个或若干个文件内容变化，以便将来查阅特定版本修订情况的系统。 想想当年写毕业论文的情况，写了一个最终版，发现不行，在原来的基础上又修改下重新存为“最终版1”、“最终版2”、“打死也不改版1”、“打死也不改版2”…。如果自己知道有 git 这种强大的版本控制工具呢，肯定不会存好多版本，打开好多版本，来来回回的复制粘贴，简直蠢的要死。git 是在商业公司 BitKeeper 停止与 Linux 开源社区合作后，由 Linux 开源社区开发的版本控制工具。","text":"前言git 是什么它是一个版本控制工具。 版本控制是一种记录一个或若干个文件内容变化，以便将来查阅特定版本修订情况的系统。 想想当年写毕业论文的情况，写了一个最终版，发现不行，在原来的基础上又修改下重新存为“最终版1”、“最终版2”、“打死也不改版1”、“打死也不改版2”…。如果自己知道有 git 这种强大的版本控制工具呢，肯定不会存好多版本，打开好多版本，来来回回的复制粘贴，简直蠢的要死。git 是在商业公司 BitKeeper 停止与 Linux 开源社区合作后，由 Linux 开源社区开发的版本控制工具。 git 基础操作配置 git/etc/gitconfig 文件：系统中对所有用户都普遍适用的配置。若使用 git config 时用 --system 选项，读写的就是这个文件。 ~/.gitconfig 文件：用户目录下的配置文件只适用于该用户。若使用 git config 时用 --global 选项，读写的就是这个文件。 当前项目的 git 目录中的配置文件（也就是工作目录中的 .git/config 文件）：这里的配置仅仅针对当前项目有效。每一个级别的配置都会覆盖上层的相同配置，所以 .git/config 里的配置会覆盖 /etc/gitconfig 中的同名变量。 配置用户信息 $ git config --global user.name “你的名字\"$ git config --global user.email “你的邮箱” 检查配置信息 $ git config --list$ git config user.name //检查 git 的某一项配置，例如名字 gitignore 里配置需要忽略的文件。养成初始化就配置 gitignore 文件的习惯，要不每回 git status 的时候会看到一大堆没必要提交的文件，Xcode 里可以做如下配置： # Xcode## gitignore contributors: remember to update Global/Xcode.gitignore, Objective-C.gitignore &amp; Swift.gitignore## Build generatedbuild/DerivedData/## Various settings*.pbxuser!default.pbxuser*.mode1v3!default.mode1v3*.mode2v3!default.mode2v3*.perspectivev3!default.perspectivev3xcuserdata/## Other*.moved-aside*.xccheckout*.xcscmblueprint## Obj-C/Swift specific*.hmap*.ipa*.dSYM.zip*.dSYM# CocoaPods## We recommend against adding the Pods directory to your .gitignore. However# you should judge for yourself, the pros and cons are mentioned at:# https://guides.cocoapods.org/using/using-cocoapods.html#should-i-check-the-pods-directory-into-source-control## Pods/# Carthage## Add this line if you want to avoid checking in source code from Carthage dependencies.# Carthage/CheckoutsCarthage/Build# fastlane## It is recommended to not store the screenshots in the git repo. Instead, use fastlane to re-generate the# screenshots whenever they are needed.# For more information about the recommended setup visit:# https://docs.fastlane.tools/best-practices/source-control/#source-controlfastlane/report.xmlfastlane/Preview.htmlfastlane/screenshotsfastlane/test_output# Code Injection## After new code Injection tools there's a generated folder /iOSInjectionProject# https://github.com/johnno1962/injectionforxcodeiOSInjectionProject/ 更多的配置可以参考 这里。 获取 git 仓库在现有目录中初始化仓库$ git init 克隆现有的仓库$ git clone &lt;url&gt; 克隆一个带子模块的项目$ git clone &lt;url&gt;$ git submodule init$ git submodule update 基础命令用 git 管理文件后，对于任何一个文件，在 git 内都只有三种状态：已提交（committed），已修改（modified）和已暂存（staged）。 已提交:表示该文件已经被安全地保存在本地数据库中了； 已修改:表示修改了某个文件，但还没有提交保存； 已暂存:表示把已修改的文件放在下次提交时要保存的清单中。 文件流转的三个工作区域：git 的工作目录，暂存区域，以及本地仓库。从项目中取出某个版本的所有文件和目录，用以开始后续工作的叫做工作目录。这些文件实际上都是从 git 目录中的压缩对象数据库中提取出来的，接下来就可以在工作目录中对这些文件进行编辑。 所谓的暂存区域只不过是个简单的文件，一般都放在 git 目录中。有时候人们会把这个文件叫做索引文件，不过标准说法还是叫暂存区域。基本的 git 工作流程如下： 在工作目录中修改某些文件。 对修改后的文件进行快照，然后保存到暂存区域。 提交更新，将保存在暂存区域的文件快照永久转储到 Git 目录中。 $ git status //检查当前文件状态$ git add . //添加文件到暂存区$ git commit -m \"message\" //提交更新 其实 git add 的潜台词就是把目标文件快照放入暂存区域，也就是 add file into staged area，同时未曾跟踪过的文件标记为需要跟踪。这样就好理解后续 add 操作的实际意义了。它是一个多功能命令，可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等。 移除文件 $ git rm 文件 删除文件但是让文件留在磁盘上 $ git rm --cached README 查看提交历史 $ git log 用 oneline 将每个提交放在一行显示 $ git log --pretty=oneline 用 ASCII 字符串表示的简单图形，形象地展示了每个提交所在的分支及其分化衍合情况 git log --pretty=format:\"%h %s\" --graph format 常用的格式占位符写法及其代表的意义 选项 说明 %H 提交对象（commit）的完整哈希字串 %h 提交对象的简短哈希字串 %T 树对象（tree）的完整哈希字串 %t 树对象的简短哈希字串 %P 父对象（parent）的完整哈希字串 %p 父对象的简短哈希字串 %an 作者（author）的名字 %ae 作者的电子邮件地址 %ad 作者修订日期（可以用 -date= 选项定制格式） %ar 作者修订日期，按多久以前的方式显示 %cn 提交者(committer)的名字 %ce 提交者的电子邮件地址 %cd 提交日期 %cr 提交日期，按多久以前的方式显示 %s 提交说明 例如，列出所有最近两周内的提交：$ git log --since=2.weeks git log 支持的选项 选项 说明 -p 按补丁格式显示每个更新之间的差异 –stat 显示每次更新的文件修改统计信息 –shortstat 只显示 –stat 中最后的行数修改添加移除统计 –name-only 仅在提交信息后显示已修改的文件清单 –name-status 显示新增、修改、删除的文件清单 –abbrev-commit 仅显示 SHA-1 的前几个字符，而非所有的 40 个字符 –relative-date 使用较短的相对时间显示（比如，“2 weeks ago”） –graph 显示 ASCII 图形表示的分支合并历史 –pretty 使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format（后跟指定格式）。 撤消对文件的修改$ git checkout -- [file] 撤消对所有文件的修改$ git checkout -- . 或者 $ git checkout . 显示还没有暂存起来的改动，不是这次工作和上次提交之间的差异$ git diff 已经暂存起来的文件和上次提交时的快照之间的差异$ git diff --cached //git 1.6.1 及更高版本还允许使用 git diff --staged，效果是相同的 git 别名$ git config --global alias.st status 这意味着，当要输入 git status 时，只需要输入 git st。查看别名的位置可以使用上面提到的 git config -—list 命令。如果想要执行外部命令，可以在命令前面加入 ! 符号，操作如下：git config --global alias.ls '!ls' git 分支分支基础分支是 git 最大的亮点，也是它的杀手锏。git 的分支分为远程分支，远程跟踪分支和跟踪分支。 远程分支就是在远程仓库上的普通分支。 远程跟踪分支是在本地的只读的记录远程分支状态的分支，其指向用户无法移动，当你做任何网络通信操作时，它们会自动移动。 跟踪分支是从远程跟踪分支上生成的本地分支。 分支常用命令查看分支 $ git branch 分支创建 $ git branch 分支名 分支切换 $ git checkout 分支名 查看每一个分支的最后一次提交 $ git branch -v 查看哪些分支已经合并到当前分支 $ git branch —merged 查看所有包含未合并工作的分支$ git branch --no-merged 分支合并，如把 test 分支合并到 master 分支 $ git checkout master$ git merge test 查看分支历史 $ git log --oneline --graph 新建一个分支并同时切换到该分支上 $ git checkout -b 分支名 删除分支 $ git branch -d 分支名 查看当前配置有哪些远程仓库 $ git remote 显示对应的克隆地址 $ git remote -v 添加远程仓库 $ git remote add [shortname] [url] 推送数据到远程仓库 $ git push origin master 远程仓库的重命名 $ git remote rename a b 远程仓库的删除 $ git remote rm xxx 查看远端仓库的详细信息 $ git remote show origin 某个远程仓库在本地的简短名称，比如想把 pb 改成 paul $ git remote rename pb paul git tag打标签是我们经常用到的命令，通常是在发布新版本或者切换到以前的特定版本修改 bug 的时候用。git 使用两种主要类型的标签：轻量标签（lightweight）与附注标签（annotated）。轻量标签很像一个不会改变的分支，它只是一个特定提交的引用。附注标签是存储在 git 数据库中的一个完整对象。创建附注标签 $ git tag -a v1.4 -m 'my version 1.4’ 创建轻量标签 $ git tag v1.4-lw 后期打标签 $ git tag -a v1.2 9fceb02 （需要在命令的末尾指定提交的校验和或部分校验和） 列出标签 $ git tag 把标签推送到远程仓库服务器上 $ git push origin [tagname] 检出标签（也就是在特定的标签上创建一个新分支） $ git checkout -b version2 v2.0.0 参考链接https://git-scm.com/book/zh/v2","categories":[],"tags":[{"name":"开发","slug":"开发","permalink":"https://github.com/caozhenwei/tags/开发/"}]},{"title":"春天里的故事","slug":"春天里的故事","date":"2018-03-19T00:57:22.000Z","updated":"2018-07-04T09:17:43.837Z","comments":true,"path":"2018/03/19/春天里的故事/","link":"","permalink":"https://github.com/caozhenwei/2018/03/19/春天里的故事/","excerpt":"春天的颜色真是五彩缤纷，太阳是红灿灿的，天空是湛蓝的，树梢是嫩绿的，迎春花是娇黄的……难怪诗人爱吟咏春天，画家爱描绘春天，因为春天是世界一切美的融合，一切色彩的总会。","text":"春天的颜色真是五彩缤纷，太阳是红灿灿的，天空是湛蓝的，树梢是嫩绿的，迎春花是娇黄的……难怪诗人爱吟咏春天，画家爱描绘春天，因为春天是世界一切美的融合，一切色彩的总会。 我的小情人喔！ 调皮的小宝宝 我也来逛逛吧 春天的水，平平的，静静的。春天的水，没有风的时候就像一面平滑的玻璃镜子一样。有风时，春天的水，在阳光的照耀下，泛起水波，闪闪发光，就像春姑娘佩戴的闪亮亮的头饰一样。春天的水，流过庄稼、田地，悄悄地给足充分的营养。春天的水活了，便孕育了一批批新的生命——鱼儿欢快地在水中游来游去。 可和宝妈 我现在最爱的玩具就它了！ 我很奇怪，这五彩缤纷的色彩为什么会不约而同地选择春天来到大地?每个人都有春天。无论是你，或者是我，每个人在春天里都可以有欢笑，有爱情，有陶醉。 小狗狗回头","categories":[],"tags":[{"name":"生活","slug":"生活","permalink":"https://github.com/caozhenwei/tags/生活/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-03-19T00:57:22.000Z","updated":"2018-07-04T09:16:29.461Z","comments":true,"path":"2018/03/19/hello-world/","link":"","permalink":"https://github.com/caozhenwei/2018/03/19/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment /frac{7x+5}","categories":[],"tags":[{"name":"开发","slug":"开发","permalink":"https://github.com/caozhenwei/tags/开发/"}]},{"title":"使用 hexo 搭建 blog","slug":"使用-hexo-搭建-blog","date":"2018-03-17T06:13:28.000Z","updated":"2018-07-04T09:20:39.696Z","comments":true,"path":"2018/03/17/使用-hexo-搭建-blog/","link":"","permalink":"https://github.com/caozhenwei/2018/03/17/使用-hexo-搭建-blog/","excerpt":"背景上篇文章刚介绍用了 Octopress 搭建 blog，这边又用 hexo 来搭建 blog，到底是几个意思？你过来，我保证不打死你！问起原因，只能说 Octopress 构建的时候有些慢并且我不喜欢它的主题（虽然它的主题很多，不喜欢就不喜欢呗，还找这么多理由干什么）。下面开始介绍怎么用 hexo 搭建 blog。","text":"背景上篇文章刚介绍用了 Octopress 搭建 blog，这边又用 hexo 来搭建 blog，到底是几个意思？你过来，我保证不打死你！问起原因，只能说 Octopress 构建的时候有些慢并且我不喜欢它的主题（虽然它的主题很多，不喜欢就不喜欢呗，还找这么多理由干什么）。下面开始介绍怎么用 hexo 搭建 blog。 本机相关环境macOS High Sierra 10.13.3 node v8.10.0 npm 5.6.0 git version 2.14.3 (Apple Git-98) 安装 Hexo什么是 Hexo？Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 需要的环境Node.js 和 Git 安装 Hexo$ npm install -g hexo-cli 初始化 $ hexo init &lt;folder&gt; 进入初始化的文件夹 $ cd &lt;folder&gt; 安装相关模块 $ npm install 在 _config.yml 中配置相关的信息 写文章$ hexo new [layout] &lt;title&gt;$ hexo generate$ hexo server 2018.6.15添加可以用草稿的方式暂时不发布那些还没有写完的文章，具体的操作是指定 layout 为 draft，这种布局在建立时会被保存到 source/_drafts 文件夹，可通过 publish 命令将草稿移动到 source/_posts 文件夹，该命令的使用方式与 new 十分类似，您也可在命令中指定 layout 来指定布局。如果你希望强行预览草稿，更改配置文件render_drafts: true 或者用如下方式启动 server ：hexo server --drafts 。 然后就能在 http://localhost:4000 看到效果了 部署到 github 上创建相关的仓库到 github 上创建一个 username.github.io 的 rep $ hexo-deployer-git.$ npm install hexo-deployer-git --save$ hexo deploy 美化主题1.clonegit clone https://github.com/Haojen/hexo-theme-Anisina.git themes/Anisina 2.配置修改 _config.yml 中的 themes 为 Anisina 即可。 评论注册来必力，在 _config.yml 中增加相应的 id 。 图片地址在配置中经常要用到某一张图片的 url ，这是我们可以把图片传到 github 的仓库中，然后在仓库中查看图像即可获得相应的图片的 url 。 社交平台的配置github 只需要用户名就行。微博的可以在设置中配置个性域名，然后把个性域名配置到 _config.yml 中。 番外Node.js 是什么？ Node.js 就是运行在服务端的 JavaScript。Node.js 是一个基于 Chrome JavaScript 运行时建立的一个平台。Node.js 是一个事件驱动 I/O 服务端JavaScript 环境，基于 Google 的 V8 引擎，V8 引擎执行 Javascript 的速度非常快，性能非常好。 用 Homebrew 装 Node.js 安装 Homebrew/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" 安装 Node.jsbrew install node 参考链接hexo 官网、来必力评论模块、Anisina 主题","categories":[],"tags":[]},{"title":"用 Octopress 搭建属于自己的 github 博客 ","slug":"用-Octopress-搭建属于自己的-github-博客","date":"2018-03-16T08:02:58.000Z","updated":"2018-06-15T07:17:18.334Z","comments":true,"path":"2018/03/16/用-Octopress-搭建属于自己的-github-博客/","link":"","permalink":"https://github.com/caozhenwei/2018/03/16/用-Octopress-搭建属于自己的-github-博客/","excerpt":"本文章介绍了自己用 Octopress 搭建 blog 的过程，其中查了好多资料，看了好多文章，也走了不少弯路。现在记录下来，方便后人学习，自己也做个备忘。废话不多说，开工！","text":"本文章介绍了自己用 Octopress 搭建 blog 的过程，其中查了好多资料，看了好多文章，也走了不少弯路。现在记录下来，方便后人学习，自己也做个备忘。废话不多说，开工！ 搭建 blog 时的本机环境macOS High Sierra (10.13.3) ruby 2.3.1p112 gem 2.5.1 bundle 1.16.1 git version 2.14.3 (Apple Git-98) 安装 Octopress什么是 Octopress ？ Octopress 是一个基于 Ruby 的开源 Blogging Framework，从写 blog，到发布，你完全可以用 Shell 里面的命令搞定。这样，写起 Blog 来，会让技术控们觉得很有成就感。。。 安装 Octopress $ git clone git://github.com/imathis/octopress.git octopress$ cd octopress 因为墙的原因，所以要修改 gem 的 source $ gem sources --add https://ruby.taobao.org/ --remove https://rubygems.org/$ gem sources -l 请确保只有 ruby.taobao.org 安装依赖 $ gem install bundler$ bundle install 安装默认的 Octopress 主题$ rake install 在 github 上创建仓库到 github 上创建仓库到 github 上创建一个 username.github.io 的 repo，比如我的github 名字为 caozhenwei ，我就创建了一个名字为 caozhenwei.github.io 的仓库。 完成 github 和 Octopress 的关联执行下面的命令并依照提示完成 github 和 Octopress 的关联 $ rake setup_github_pages(For example, 'git@github.com:your_username/your_username.github.io.git) or 'https://github.com/your_username/your_username.github.io')//比如我的我就输入如下： git@github.com: caozhenwei/caozhenwei.github.io.git 创建配置生成博客 $ rake generate$ rake deploy 生成后 push 到 github 上，在这之前需要配置下 SSH Key。在终端下输入 $ ssh-keygen -t rsa -C \"邮箱地址\" 按三次回车即可，成功后就可以在用户目录下找到 .ssh 目录，里面有 id_rsa 和 id_rsa.pub 两个文件，把 id_rsa.pub 放到 github 的 SSH keys 即可。 git 用户账户信息的配置： $ git config --global user.name \"你的github用户名\"$ git config --global user.email \"你的github邮箱地址\" 然后再提交： $ git add .$ git commit -m 'create blog'$ git push origin source 完成后等待几秒就能访问 http://username.github.io 看到自己的博客了。 当然，你也可以在 push 到 github 上之前先在本地预览一下，命令如下$ rake preview 你可以在本地的浏览器里打开 localhost:4000 来预览生成的 blog 。 安装第三方主题如果你喜欢上面的默认的主题，这里的步骤就没必要执行了。我比较 abacus 主题，下面是安装步骤：$ cd octopress$ git clone https://github.com/bhrigu123/abacus.themes/abacus$ rake install['abacus']$ rake generate 到这一步，你的 blog 已经基本搭建完了，终于能写了。blog 是用 Markdown 语言来写的。Markdown 是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。在 mac 下可以使用 MacDown 软件来写。想下载 MacDown 点我。需要更多的主题点我。 开始写 blog：$ rake new_post['title'] ＃title 是你要写的 blog 的标题 执行完上面的命令后会在 source/_posts 下面生成 xxx.markdown 文件，我们的 blog 就在 xxx.markdown 中编写。编写完后执行： $ rake generate$ rake preview //在浏览器输入： localhost:4000 在本地先预览效果，满意后在 push 到 github 上。$ git add .$ git commit -m \"comment\" $ git push origin source$ rake deploy 折腾后的收获在执行 gem install bundler的时候，一会儿切换源，一会说 ruby 版本不对。看来是对 gem 不熟悉。那什么是RubyGems？RubyGems 是一个方便而强大的 Ruby 程序包管理器，Ruby 的第三方插件是用 gem 方式来管理，非常容易发布和共享，一个简单的命令就可以安装上第三方的扩展库。特点：能远程安装包，包之间依赖关系的管理，简单可靠的卸载，查询机制，能查询本地和远程服务器的包信息，能保持一个包的不同版本，基于 Web 的查看接口，能查看你安装的 gem 的信息。Ruby1.9.1 以后的版本自带 RubyGems。要切换 ruby 版本用什么好呢？笔者刚开始用了 rvm, 后来又用了 rbenv。安装的时候又用到了 homebrew。本着 生命不息，折腾不止的精神，重新的学习了以上各命令的用法。常用方法如下： rvm 常用命令 rvm remove ruby-1.8.7 --docs —gems ＃删除某个版本的ruby，并且把文档和gems都删除rvm use ruby-1.8.7 --default ＃选择版本rvm info ＃查询当前版本rvm list ＃列出版本rvm implode ＃删除rvm命令 rbenv 常用命令 rbenv install --list ＃列出所有可以安装的Ruby版本rbenv install version ＃version是具体要安装的版本，在上面列出的可以安装的目录中选择一个rbenv versions ＃查看本地安装的ruby版本rbenv global version #设置全局使用的ruby版本rbenv shell version ＃设置在当前shell中使用的ruby版本，生成了一个RBENV_VERSION的变量rbenv local version ＃设置在当前目录中的ruby版本，会在当前目录下生成.rbenv-version文件。rbenv uninstall 2.00 #卸载指定ruby版本rbenv rehash #每当安装新的 Ruby 版本，或 gem 都要运行一下，不然有可能会出现新安装的不起作用的现象 Homebrew 常用命令 brew uninstall rbenv ＃卸载rbenvbrew list ＃列出已安装的软件brew update ＃更新brewbrew home ＃用浏览器打开 brew 的官方网站brew info ＃显示软件信息brew deps ＃ 显示包依赖 参考链接Octopress 的配置、Octopress 主题、RubyGems 镜像、homebrew、homebrew 官网、rbenv、rvm","categories":[],"tags":[{"name":"开发","slug":"开发","permalink":"https://github.com/caozhenwei/tags/开发/"}]},{"title":"mac下常用命令和快捷键","slug":"mac下常用命令","date":"2018-02-19T06:24:47.000Z","updated":"2018-07-04T09:17:13.973Z","comments":true,"path":"2018/02/19/mac下常用命令/","link":"","permalink":"https://github.com/caozhenwei/2018/02/19/mac下常用命令/","excerpt":"前言使用命令行或者使用快捷键会大大的提高工作效率，本问会总结一些经常用到的快捷键和命令。统统列出来肯定是列不全的，只能边用边总结，文章持续更新中。。。","text":"前言使用命令行或者使用快捷键会大大的提高工作效率，本问会总结一些经常用到的快捷键和命令。统统列出来肯定是列不全的，只能边用边总结，文章持续更新中。。。 mac下常用快捷键打开实用工具cmd + shift + U 去往任意路径的文件夹cmd + shift + U 强制退出cmd + option + esc mac终端下常用命令查看系统支持的 shell 列表cat /etc/shells 删除所有系统日志sudo rm -rf /private/var/log/* 获得一个文件的 md5 值openssl md5 /Users/caozhenwei/Desktop/12345/html.dek 查看内核版本uname -a mac 下添加类似于 linux 的 tree 命令 find . -print | sed -e &#39;s;[^/]*/;|____;g;s;____|; |;g&#39;在 .bash_profile 中加入上面面这条，就能在 mac 下使用 tree 命令了 Home-brew 安装 （官网 http://brew.sh/index_zh-cn.html）/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 安装 node（ 官网 https://nodejs.org/en/）brew install node 重新启动 Mac 的命令sudo shutdown -r now 获取 ip 地址ipconfig getifaddr en0 修改主机名称sudo scutil --set HostName MacBookPro 修改共享名称sudo scutil --set ComputerName MacBookPro 解压 rar 文件brew install unrarunrar x 文件名.rar 查看文件占用的磁盘空间du -sh ~/.cocoapods profile 文件的路径~/Library/MobileDevice/Provisioning\\ Profiles/","categories":[],"tags":[]},{"title":" Markdown基本语法","slug":"Markdown基本语法","date":"2018-01-25T09:27:31.000Z","updated":"2018-07-25T12:24:19.763Z","comments":true,"path":"2018/01/25/Markdown基本语法/","link":"","permalink":"https://github.com/caozhenwei/2018/01/25/Markdown基本语法/","excerpt":"插入数学公式 &lt;script type=&quot;text/javascript&quot; src=&quot;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default&quot;&gt;&lt;/script&gt; $$x=\\frac{-b\\pm\\sqrt{b^2-4ac}}{2a}$$","text":"插入数学公式 &lt;script type=&quot;text/javascript&quot; src=&quot;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default&quot;&gt;&lt;/script&gt; $$x=\\frac{-b\\pm\\sqrt{b^2-4ac}}{2a}$$ $$x=\\frac{-b\\pm\\sqrt{b^2-4ac}}{2a}$$ 代码高亮 ```bash 代码 ``` 表格 选项 说明 -p 按补丁格式显示每个更新之间的差异 –stat 显示每次更新的文件修改统计信息 –shortstat 只显示 –stat 中最后的行数修改添加移除统计 加粗字体 将需要设置为斜体的文字两端使用2个“*”或者“_”夹起来 我是被加粗的哦","categories":[],"tags":[]},{"title":"iOS 中 native 和 JavaScript 的交互原理","slug":"iOS-中-native-和-JavaScript-的交互原理","date":"2017-12-02T06:17:45.000Z","updated":"2018-06-29T07:25:34.503Z","comments":true,"path":"2017/12/02/iOS-中-native-和-JavaScript-的交互原理/","link":"","permalink":"https://github.com/caozhenwei/2017/12/02/iOS-中-native-和-JavaScript-的交互原理/","excerpt":"前言在 iOS 开发中经常要用到 UIWebView ( iOS8 中可以用 WKWebView，本文章以 UIWebView 为例 ) 来展示一些东西，其中就难免要和网页进行交互。服务端提供 H5 供多个平台使用，我们就不用在 native 中开发了，是不是很棒。Hybrid App 的优势很明显，这就要求我们必须具备 native 和网页交互的技能。学点儿 JavaScript 的知识能帮我们更好的理解交互的原理。本文主要来介绍 UIWebView 和 JavaScript 的交互原理以及 WebViewJavascriptBridge (github 地址) 源码分析。","text":"前言在 iOS 开发中经常要用到 UIWebView ( iOS8 中可以用 WKWebView，本文章以 UIWebView 为例 ) 来展示一些东西，其中就难免要和网页进行交互。服务端提供 H5 供多个平台使用，我们就不用在 native 中开发了，是不是很棒。Hybrid App 的优势很明显，这就要求我们必须具备 native 和网页交互的技能。学点儿 JavaScript 的知识能帮我们更好的理解交互的原理。本文主要来介绍 UIWebView 和 JavaScript 的交互原理以及 WebViewJavascriptBridge (github 地址) 源码分析。 UIWebView 和 JavaScript 的交互原理理解这个原理之前必须先明确以下两点： 1.JavaScript 能直接调用 native 方法吗？不可以。 2.native 能直接调用 JavaScript 代码吗？可以，可以通过以下方式来调用：[webView stringByEvaluatingJavaScriptFromString:javascriptCommand]; JavaScript 不能直接调用 native 的方法，但是可以间接的通过一些方法来实现。可以利用 UIWebView 的 webView: shouldStartLoadWithRequest: navigationType: 代理方法来做。 WKWebView 中可以通过 webView: decidePolicyForNavigationAction: decisionHandler: 代理方法来做（本文以 UIWebView 为例，WKWebView 与 JavaScript 交互的原理同 UIWebView 一样，后面不会赘述。以下用 webView 来代指 UIWebView 和 WKWebView ）。webView 发起的网络请求都会走上面的代理方法，那么就可以在代理里拦截，如果返回的是我们自己定义的 URL ，就不在加载网页，而是来处理一些我们想让它做的事情，从而实现 native 和 JavaScript 的交互。 WebViewJavascriptBridge 源码分析WebViewJavascriptBridge 是封装好的 native 和 JavaScript 交互的组件。下面主要是对它源码的一些分析，以及一些简单的 JavaScript 知识（对只会 Objective-C 程序猿理解 WebViewJavascriptBridge 很有帮助哦）。上面分析的原理是利用 webView 的代理来拦截 URL 从而实现交互。那么 webView 的代理方法 webView: shouldStartLoadWithRequest: navigationType 什么时候会被调用呢？给出的回答是这样的： Sent before a web view begins loading a frame 。如果代理方法只调用一次的话，没办法对其中的 URL 拦截判断（这里指的是我们自定义的 URL），所以就必须想办法在 H5 里做处理来触发 webView 的代理事件。有很多办法能解决这个问题，比如以下两种： 创建 iframe 标签，WebViewJavascriptBridge 中就是用的这种方法。 设置 window 的 location，例如 window.location = “/www/phpStudy/JS/helloJS.html”; 本文以尽可能按照代码的执行顺序来分析 WebViewJavascriptBridge 源代码。那现在正式开始，native 创建好 webView 后，来 load ExampleApp.html。先来看看 ExampleApp.html，其中主要的是 script 标签里面的代码，代码如下： &lt;script&gt; window.onerror = function(err) &#123; log('window.onerror: ' + err) &#125; function setupWebViewJavascriptBridge(callback) &#123; if (window.WebViewJavascriptBridge) &#123; //alert(\"0\"); return callback(WebViewJavascriptBridge); &#125; if (window.WVJBCallbacks) &#123; //alert(\"1\"); return window.WVJBCallbacks.push(callback); &#125; window.WVJBCallbacks = [callback]; var WVJBIframe = document.createElement('iframe'); WVJBIframe.style.display = 'none'; WVJBIframe.src = 'wvjbscheme://__BRIDGE_LOADED__'; document.documentElement.appendChild(WVJBIframe); setTimeout(function()&#123; document.documentElement.removeChild(WVJBIframe) &#125;, 0) &#125; setupWebViewJavascriptBridge(function(bridge) &#123; var uniqueId = 1 function log(message, data) &#123; var log = document.getElementById('log') var el = document.createElement('div') el.className = 'logLine' el.innerHTML = uniqueId++ + '. ' + message + ':&lt;br/&gt;' + JSON.stringify(data) if (log.children.length) &#123; log.insertBefore(el, log.children[0]) &#125; else &#123; log.appendChild(el) &#125; &#125; //alert(\"在exampleApp setupWebViewJavascriptBridge 中\"); bridge.registerHandler('testJavascriptHandler', function(data, responseCallback) &#123; log('ObjC called testJavascriptHandler with', data) var responseData = &#123; 'oc调用js后，js给oc的回调':'hello' &#125; log('JS responding with', responseData) responseCallback(responseData) &#125;) document.body.appendChild(document.createElement('br')) var callbackButton = document.getElementById('buttons').appendChild(document.createElement('button')) callbackButton.innerHTML = '测试 JS 调用 OC 函数' callbackButton.onclick = function(e) &#123; e.preventDefault() log('JS calling handler \"testObjcCallback\"') bridge.callHandler('testObjcCallback', &#123;'foo': 'bar'&#125;, function(response) &#123; log('JS 得到的回应数据：', response) &#125;) &#125; &#125;)&lt;/script&gt; 对 Objective-C 程序猿来说猛的一眼看不懂这是什么，其实就是一个简单的 JavaScript 函数调用，只不过是把另一个函数当做参数传给了 setupWebViewJavascriptBridge 函数。简化后如下： function setupWebViewJavascriptBridge(callback) {} setupWebViewJavascriptBridge(function(bridge) {}) 上面的 setupWebViewJavascriptBridge 函数中对 window.WebViewJavascriptBridge 和 window.WVJBCallbacks 做判断，第一次请求 H5 这两个属性都为空，根本就不回执行 if 里面的语句，可以像上面代码中注释的那样，用 alert 来证实。callback 被加到了 WVJBCallbacks 数组里，这里先记住，后面会用，这里提个醒留个印象。接着函数中还创建了一个隐藏的 iframe 标签，并设置它的 src 属性为 wvjbscheme://__BRIDGE_LOADED__。这样我们才能在 webView 的代理方法中对 URL 做判断，并做进一步的处理。 来看一下 wevView 的代理方法： - (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType &#123; if (webView != _webView) &#123; return YES; &#125; NSURL *url = [request URL]; __strong WVJB_WEBVIEW_DELEGATE_TYPE* strongDelegate = _webViewDelegate; if ([_base isCorrectProcotocolScheme:url]) &#123; if ([_base isBridgeLoadedURL:url]) &#123; //拦截到 wvjbscheme://__BRIDGE_LOADED__ [_base injectJavascriptFile]; &#125; else if ([_base isQueueMessageURL:url]) &#123; //拦截到 wvjbscheme://__WVJB_QUEUE_MESSAGE__ NSString *messageQueueString = [self _evaluateJavascript:[_base webViewJavascriptFetchQueyCommand]]; [_base flushMessageQueue:messageQueueString]; &#125; else &#123; [_base logUnkownMessage:url]; &#125; return NO; &#125; else if (strongDelegate &amp;&amp; [strongDelegate respondsToSelector:@selector(webView:shouldStartLoadWithRequest:navigationType:)]) &#123; return [strongDelegate webView:webView shouldStartLoadWithRequest:request navigationType:navigationType]; &#125; else &#123; return YES; &#125;&#125; 在这里面拦截到是我们定义的 wvjbscheme 后就调用相应的逻辑处理，否则的话就不处理。在这里拦截到 wvjbscheme://__BRIDGE_LOADED__，执行了 WebViewJavascriptBridge_js 里的 JavaScript 代码。来看看 WebViewJavascriptBridge_js 里的代码都干了点儿什么，先挑出现在能用上的，具体的用的时候再说。看看下面的代码片段： messagingIframe = document.createElement('iframe');messagingIframe.style.display = 'none';messagingIframe.src = CUSTOM_PROTOCOL_SCHEME + '://' + QUEUE_HAS_MESSAGE;document.documentElement.appendChild(messagingIframe); setTimeout(_callWVJBCallbacks, 0);function _callWVJBCallbacks() &#123; var callbacks = window.WVJBCallbacks; delete window.WVJBCallbacks; for (var i=0; i&lt;callbacks.length; i++) &#123; callbacks[i](WebViewJavascriptBridge); &#125;&#125; 一眼就能看到其中又创建了个 iframe 标签，把 src 设置成了 wvjbscheme://__WVJB_QUEUE_MESSAGE__，这样的话就能在 webView 的代理方法中拦截了。来说一下 setTimeout 的作用：setTimeout() 方法用于在指定的毫秒数后调用函数或计算表达式（setTimeout 函数介绍）。接着调用了 _callWVJBCallbacks 函数，在这个函数里面取出了上面让暂时记住的 window.WVJBCallbacks (在 ExampleApp.html 里把 callback 放入进 WVJBCallbacks 里)，取出里面所有的方法（其实现在就一个 callback 方法）并且执行。让我们来跳到 ExampleApp.html 里面，看看 callback （就是setupWebViewJavascriptBridge 调用处传进来的匿名函数）里都做了什么。log 方法用来打印信息。接着调用了 bridge 的 registerHandler 方法（这个主要是供 native 端来调用的）。创建了一个 callbackButton 并绑定它的 onclick 事件。先来看看 registerHandler 方法都干了什么，跳到 WebViewJavascriptBridge_JS.m 里找到的 registerHandler 如下： function registerHandler(handlerName, handler) &#123; messageHandlers[handlerName] = handler;&#125; 这里是把 registerHandler 里传过来的参数放到了 messageHandlers 数组里，以后 native 调用 JavaScript 方法的时候就会来这里取。 Objective-C 程序猿的加油站：JavaScript 拥有动态类型 我们申明 messageHandlers 时是这样申明的 var messageHandlers = {}; 可是在用的时候就把它当数组用了，对 Objective-C 程序猿来说是很奇怪的。其实JavaScript 拥有动态类型。这意味着相同的变量可用作不同的类型。 native 调用 JavaScript 方法native 调用 JavaScript 方法是这样的： [_bridge callHandler:@\"testJavascriptHandler\" data:data responseCallback:^(id response) &#123; NSLog(@\"testJavascriptHandler responded: %@\", response);&#125;] 通过上面的函数，一路跟下去，发现是把调用的 JavaScript 的方法名，参数和回调拼装好后在本地执行了 _handleMessageFromObjC 方法，其中 _handleMessageFromObjC 的参数是上面拼装好的字典。来看看 _handleMessageFromObjC 里做了什么。 function _handleMessageFromObjC(messageJSON) &#123; _dispatchMessageFromObjC(messageJSON);&#125; function _dispatchMessageFromObjC(messageJSON) &#123; //messageJSON 里面包含 data callbackId handlerName setTimeout(function _timeoutDispatchMessageFromObjC() &#123; //使用 JSON.parse 将 JSON 字符串转换为对象 var message = JSON.parse(messageJSON); var messageHandler; var responseCallback; if (message.responseId) &#123; responseCallback = responseCallbacks[message.responseId]; if (!responseCallback) &#123; return; &#125; responseCallback(message.responseData); delete responseCallbacks[message.responseId]; &#125; else &#123; if (message.callbackId) &#123; var callbackResponseId = message.callbackId; responseCallback = function(responseData) &#123; _doSend(&#123; responseId:callbackResponseId, responseData:responseData &#125;); &#125;; &#125; var handler = messageHandlers[message.handlerName]; try &#123; handler(message.data, responseCallback); &#125; catch(exception) &#123; console.log(\"WebViewJavascriptBridge: WARNING: javascript handler threw.\", message, exception); &#125; if (!handler) &#123; console.log(\"WebViewJavascriptBridge: WARNING: no handler for message from ObjC:\", message); &#125; &#125; &#125;);&#125; 在 _handleMessageFromObjC 里面又调用了 _dispatchMessageFromObjC。在这里面又发现了 setTimeout，和上面提到的一样，它会执行 _timeoutDispatchMessageFromObjC 方法。该函数里首先对 message.responseId 做了判断，我们知道它肯定是空的，因为传过来的参数只有 data ,callbackId 和 handlerName。在 else 里面取出来 callbackId 赋值给了 callbackResponseId。从 messageHandlers 中取出 handlerName 给了 handler，这里的 handler 就是 JavaScript 注册到这里的方法。执行 handler 并把回调给 native。执行回调的过程中 使用了 _doSend 函数，我们来看一下： function _doSend(message, responseCallback) &#123; //mesage 包含responseId,responseData //responseCallback为空 if (responseCallback) &#123; var callbackId = 'cb_'+(uniqueId++)+'_'+new Date().getTime(); responseCallbacks[callbackId] = responseCallback; message['callbackId'] = callbackId; &#125; sendMessageQueue.push(message); messagingIframe.src = CUSTOM_PROTOCOL_SCHEME + '://' + QUEUE_HAS_MESSAGE;&#125; 此时的 responseCallback 为空，不进 if 里面。然后把 message 放到了 sendMessageQueue 数组里，并把 messagingIframe.src 的设置成了 wvjbscheme://__WVJB_QUEUE_MESSAGE__，就又会执行 webView 的代理方法，在代理方法里判断 URL 为 wvjbscheme://__WVJB_QUEUE_MESSAGE__ 的话就会去 通过 _fetchQueue 来取 sendMessageQueue 的数据，并且回调 native 方法。至此，native 调用 JavaScript 注册的方法结束。 Objective-C 程序猿的加油站：stringify() 在上面的 _fetchQueue 中用到了 stringify()，下面说说 stringify() 是干什么用的stringify()用于从一个对象解析出字符串，例如：var a = {a:1,b:2}；执行JSON.stringify(a)后的结果为：“{“a”:1,”b”:2}” JavaScript 调用 native 方法native 调用的 JavaScript 的方法是在 JavaScript 里提前注册好的。同理，JavaScript 想调用 native 的方法，native 必须也要先注册。 在 ExampleUIWebViewController.m 中[_bridge registerHandler:@\"testObjcCallback\" handler:^(id data, WVJBResponseCallback responseCallback) &#123; NSLog(@\"testObjcCallback called: %@\", data); responseCallback(@&#123; @\"name\":@\"OC回调给js的参数\" &#125;); &#125;];//在 WebViewJavascriptBridge.m 中- (void)registerHandler:(NSString *)handlerName handler:(WVJBHandler)handler &#123; _base.messageHandlers[handlerName] = [handler copy];&#125; 在代码层面来看，native 的注册其实就是把 native 中需要被调用的名字和回调放到了 messageHandlers 的字典中。那我们来看看调用 native 方法的具体流程。在点击 webView 上的按钮（在 ExampleApp.html 里面创建的 callbackButton）后，调用了 callHandler 方法，传递的参数为要调用的 native 的方法名，参数和回调。来看看 callHandler 里有什么。 function callHandler(handlerName, data, responseCallback) &#123; if (arguments.length == 2 &amp;&amp; typeof data == 'function') &#123; responseCallback = data; data = null; &#125; _doSend(&#123; handlerName:handlerName, data:data &#125;, responseCallback);&#125; 这里做了容错判断（在下面的 Objective-C 程序猿加油站中有说明）后，和 native 调用 JavaScript 一样，都是调用了 _doSend 方法。在里面为 responseCallback 生成了 唯一的 callbackId 并放到 message 里，接下来的流程和 native 调用 JavaScript 大同小异，这里不再赘述。 Objective-C 程序猿的 js 加油站：arguments 在 JavaScript 中 arguments 对象是比较特别的一个对象，实际上是当前函数的一个内置属性，它的长度是由实参个数而不是形参个数决定的。那么就很容易理解了，上面的是一个冗错处理，也就是说在调用 callHandler 的时候可以不传调用 native 方法中的参数，只传递调用 nativie 方法中的方法名字和回调方法即可。 参考文章或链接setTimeout 函数介绍 JSON 教程 WebViewJavascript github 地址","categories":[],"tags":[]}]}